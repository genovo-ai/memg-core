{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"memg-core","text":"<p>The foundation of structured memory for AI agents.</p> <p>memg-core is the deterministic, schema-driven memory engine at the heart of the larger MEMG system. It gives AI developers a fast, reliable, testable memory layer powered by:</p> <ul> <li>YAML-based schema definition (for custom memory types)</li> <li>Dual-store backend (Qdrant for vectors, Kuzu for graph queries)</li> <li>Public Python API for all memory operations</li> <li>Built-in support for auditability, structured workflows, and self-managed memory loops</li> </ul> <p>It's designed for AI agents that build, debug, and improve themselves \u2014 and for humans who demand clean, explainable, memory-driven systems.</p> <p>\ud83e\udde9 This is just the core. The full memg system builds on this to add multi-agent coordination, long-term memory policies, and deeper retrieval pipelines \u2014 currently in progress.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Vector Search: Fast semantic search with Qdrant</li> <li>Graph Storage: Optional relationship analysis with Kuzu</li> <li>Offline-First: 100% local embeddings with FastEmbed - no API keys needed</li> <li>Type-Agnostic: Configurable memory types via YAML schemas</li> <li>See Also Discovery: Knowledge graph-style associative memory retrieval</li> <li>Lightweight: Minimal dependencies, optimized for performance</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code>pip install memg-core\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>from memg_core.api.public import add_memory, search, delete_memory\n\n# Add a note\nnote_hrid = add_memory(\n    memory_type=\"note\",\n    payload={\n        \"statement\": \"Set up Postgres with Docker for local development\",\n        \"project\": \"backend-setup\"\n    },\n    user_id=\"demo_user\"\n)\nprint(f\"Created note: {note_hrid}\")  # Returns HRID like \"NOTE_AAA001\"\n\n# Search for memories\nresults = search(\n    query=\"postgres docker setup\",\n    user_id=\"demo_user\",\n    limit=5\n)\nfor r in results:\n    print(f\"[{r.memory.memory_type}] {r.memory.hrid}: {r.memory.payload['statement']} - Score: {r.score:.2f}\")\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<p>memg-core provides a deterministic, YAML-driven memory layer with dual storage:</p> <ul> <li>YAML-driven schema engine - Define custom memory types with zero hardcoded fields</li> <li>Qdrant/Kuzu dual-store - Vector similarity + graph relationships</li> <li>Public Python API - Clean interface for all memory operations</li> <li>Configurable schemas - Examples in <code>config/</code> for different use cases</li> </ul>"},{"location":"#in-scope","title":"In Scope","text":"<ul> <li>\u2705 YAML schema definition and validation</li> <li>\u2705 Memory CRUD operations with dual storage</li> <li>\u2705 Semantic search with memory type filtering</li> <li>\u2705 Public Python API with HRID-based interface</li> <li>\u2705 User isolation with per-user HRID scoping</li> </ul>"},{"location":"#coming-in-full-memg-system","title":"Coming in Full MEMG System","text":"<ul> <li>\ud83d\udd04 Schema contracts and multi-agent coordination</li> <li>\ud83d\udd04 Async job processing and bulk operations</li> <li>\ud83d\udd04 Advanced memory policies and retention</li> <li>\ud83d\udd04 Multi-agent memory orchestration</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> <li>No API keys required!</li> </ul>"},{"location":"#links","title":"Links","text":"<ul> <li>Repository</li> <li>Issues</li> <li>PyPI Package</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - see LICENSE file for details.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to memg-core will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>MkDocs documentation site with Material theme</li> <li>Comprehensive API reference documentation</li> <li>Usage guide with examples and configuration details</li> <li>GitHub Actions workflow for automated documentation deployment</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Improved README with badges and better structure</li> <li>Enhanced project metadata for PyPI integration</li> </ul>"},{"location":"changelog/#010-2024-01-xx","title":"[0.1.0] - 2024-01-XX","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial release of memg-core</li> <li>YAML-based schema definition system</li> <li>Dual-store backend (Qdrant + Kuzu)</li> <li>Public Python API for memory operations</li> <li>Vector search with semantic similarity</li> <li>Graph storage for relationships</li> <li>Offline-first embeddings with FastEmbed</li> <li>User isolation and HRID-based memory identification</li> <li>See Also discovery for associative memory retrieval</li> <li>Support for custom memory types via YAML schemas</li> <li>Built-in schemas for common use cases (memo, note, document, task, bug, solution)</li> <li>Comprehensive test suite</li> <li>Development tools (linting, type checking, testing)</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Memory Operations: Add, search, delete memories with full CRUD support</li> <li>Schema Flexibility: Define custom memory types without code changes</li> <li>Performance: Optimized for fast semantic search and retrieval</li> <li>Reliability: Deterministic behavior with comprehensive error handling</li> <li>Developer Experience: Clean API, good documentation, extensive testing</li> </ul>"},{"location":"changelog/#technical-details","title":"Technical Details","text":"<ul> <li>Python 3.11+ support</li> <li>FastEmbed for local embeddings (no API keys required)</li> <li>Qdrant for vector storage and similarity search</li> <li>Kuzu for graph relationships and complex queries</li> <li>Pydantic for data validation and serialization</li> <li>Comprehensive type hints and documentation</li> </ul>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide covers installation, configuration, and common usage patterns for memg-core.</p>"},{"location":"usage/#installation","title":"Installation","text":""},{"location":"usage/#from-pypi","title":"From PyPI","text":"<pre><code>pip install memg-core\n</code></pre>"},{"location":"usage/#development-setup","title":"Development Setup","text":"<pre><code># 1) Clone the repository\ngit clone https://github.com/genovo-ai/memg-core.git\ncd memg-core\n\n# 2) Create virtualenv and install dependencies\npython3 -m venv .venv &amp;&amp; source .venv/bin/activate\npip install -r requirements.txt\n\n# 3) For development, install dev dependencies\npip install -r requirements-dev.txt\n\n# 4) Run tests\nexport YAML_PATH=\"config/core.test.yaml\"\nexport QDRANT_STORAGE_PATH=\"$HOME/.local/share/qdrant\"\nexport KUZU_DB_PATH=\"$HOME/.local/share/kuzu/memg\"\nmkdir -p \"$QDRANT_STORAGE_PATH\" \"$HOME/.local/share/kuzu\"\nPYTHONPATH=$(pwd)/src pytest -q\n</code></pre>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>Configure memg-core using environment variables:</p>"},{"location":"usage/#required-variables","title":"Required Variables","text":"<pre><code># Storage paths\nexport QDRANT_STORAGE_PATH=\"/path/to/qdrant\"\nexport KUZU_DB_PATH=\"/path/to/kuzu/database\"\nexport YAML_PATH=\"config/core.memo.yaml\"\n</code></pre>"},{"location":"usage/#optional-variables","title":"Optional Variables","text":"<pre><code># Embeddings configuration\nexport EMBEDDER_MODEL=\"Snowflake/snowflake-arctic-embed-xs\"  # Default\n\n# For MCP server (if using)\nexport MEMORY_SYSTEM_MCP_PORT=8787\n</code></pre>"},{"location":"usage/#yaml-schema-configuration","title":"YAML Schema Configuration","text":"<p>memg-core uses YAML schemas to define memory types. Core ships with example schemas:</p> <ul> <li><code>config/core.memo.yaml</code>: Basic memory types (<code>memo</code>, <code>note</code>, <code>document</code>, <code>task</code>)</li> <li><code>config/software_dev.yaml</code>: Enhanced schema with <code>bug</code> and <code>solution</code> types</li> <li><code>config/core.test.yaml</code>: Test configuration for development</li> </ul>"},{"location":"usage/#using-different-schemas","title":"Using Different Schemas","text":"<pre><code># Basic schema\nexport YAML_PATH=\"config/core.memo.yaml\"\n\n# Enhanced development schema\nexport YAML_PATH=\"config/software_dev.yaml\"\n\n# Test schema\nexport YAML_PATH=\"config/core.test.yaml\"\n</code></pre>"},{"location":"usage/#basic-operations","title":"Basic Operations","text":""},{"location":"usage/#adding-memories","title":"Adding Memories","text":"<pre><code>from memg_core.api.public import add_memory\n\n# Add a simple note\nnote_hrid = add_memory(\n    memory_type=\"note\",\n    payload={\n        \"statement\": \"Remember to update the API documentation\",\n        \"project\": \"docs-update\"\n    },\n    user_id=\"user123\"\n)\nprint(f\"Created: {note_hrid}\")  # Returns \"NOTE_AAA001\"\n\n# Add a document with more details\ndoc_hrid = add_memory(\n    memory_type=\"document\",\n    payload={\n        \"statement\": \"API Authentication Guide\",\n        \"details\": \"Complete guide for implementing JWT authentication in our API\",\n        \"project\": \"backend-auth\",\n        \"url\": \"https://wiki.company.com/auth-guide\"\n    },\n    user_id=\"user123\"\n)\n\n# Add a task\ntask_hrid = add_memory(\n    memory_type=\"task\",\n    payload={\n        \"statement\": \"Implement user registration endpoint\",\n        \"assignee\": \"john.doe\",\n        \"priority\": \"high\",\n        \"status\": \"in_progress\",\n        \"project\": \"backend-auth\"\n    },\n    user_id=\"user123\"\n)\n</code></pre>"},{"location":"usage/#searching-memories","title":"Searching Memories","text":"<pre><code>from memg_core.api.public import search\n\n# Basic search\nresults = search(\n    query=\"authentication API\",\n    user_id=\"user123\",\n    limit=10\n)\n\nfor result in results:\n    memory = result.memory\n    print(f\"[{memory.memory_type}] {memory.hrid}: {memory.payload['statement']}\")\n    print(f\"Score: {result.score:.3f}\")\n    print(\"---\")\n\n# Search with memory type filtering\ntask_results = search(\n    query=\"registration\",\n    user_id=\"user123\",\n    memory_type=\"task\",\n    limit=5\n)\n\n# Search with project filtering\nproject_results = search(\n    query=\"backend authentication\",\n    user_id=\"user123\",\n    project=\"backend-auth\",\n    limit=10\n)\n</code></pre>"},{"location":"usage/#deleting-memories","title":"Deleting Memories","text":"<pre><code>from memg_core.api.public import delete_memory\n\n# Delete by HRID\nsuccess = delete_memory(hrid=\"NOTE_AAA001\", user_id=\"user123\")\nprint(f\"Deletion successful: {success}\")\n\n# Delete by UUID (if you have it)\nsuccess = delete_memory(memory_id=\"550e8400-e29b-41d4-a716-446655440000\", user_id=\"user123\")\n</code></pre>"},{"location":"usage/#advanced-usage","title":"Advanced Usage","text":""},{"location":"usage/#memory-types-and-schemas","title":"Memory Types and Schemas","text":"<p>The available memory types depend on your YAML schema. Common types include:</p>"},{"location":"usage/#basic-types-corememoyaml","title":"Basic Types (core.memo.yaml)","text":"<ul> <li>memo: Simple statements or observations</li> <li>note: Notes with optional project association</li> <li>document: Structured documents with details and optional URLs</li> <li>task: Task items with assignee, priority, and status</li> </ul>"},{"location":"usage/#enhanced-types-software_devyaml","title":"Enhanced Types (software_dev.yaml)","text":"<ul> <li>bug: Bug reports with severity, status, and reproduction steps</li> <li>solution: Solutions with code snippets and test status</li> </ul>"},{"location":"usage/#working-with-projects","title":"Working with Projects","text":"<p>Use the <code>project</code> field to organize memories:</p> <pre><code># Add memories to a project\nadd_memory(\n    memory_type=\"note\",\n    payload={\"statement\": \"Database migration notes\", \"project\": \"v2-migration\"},\n    user_id=\"user123\"\n)\n\n# Search within a project\nresults = search(\n    query=\"migration\",\n    user_id=\"user123\",\n    project=\"v2-migration\"\n)\n</code></pre>"},{"location":"usage/#embedding-configuration","title":"Embedding Configuration","text":"<p>memg-core uses FastEmbed for local, offline embeddings:</p> <pre><code># Default model (recommended)\nexport EMBEDDER_MODEL=\"Snowflake/snowflake-arctic-embed-xs\"\n\n# Alternative models\nexport EMBEDDER_MODEL=\"intfloat/e5-small\"\nexport EMBEDDER_MODEL=\"BAAI/bge-small-en-v1.5\"\n</code></pre>"},{"location":"usage/#user-isolation","title":"User Isolation","text":"<p>All operations are user-scoped. Each user has their own: - Memory namespace - HRID sequences (NOTE_AAA001, NOTE_BBB001, etc.) - Search results</p> <pre><code># User A's memories\nadd_memory(memory_type=\"note\", payload={\"statement\": \"User A note\"}, user_id=\"userA\")\n\n# User B's memories (completely isolated)\nadd_memory(memory_type=\"note\", payload={\"statement\": \"User B note\"}, user_id=\"userB\")\n\n# Search only returns memories for the specified user\nresults_a = search(query=\"note\", user_id=\"userA\")  # Only User A's memories\nresults_b = search(query=\"note\", user_id=\"userB\")  # Only User B's memories\n</code></pre>"},{"location":"usage/#error-handling","title":"Error Handling","text":"<pre><code>from memg_core.core.exceptions import MemgCoreError\n\ntry:\n    result = add_memory(\n        memory_type=\"invalid_type\",\n        payload={\"statement\": \"This will fail\"},\n        user_id=\"user123\"\n    )\nexcept MemgCoreError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"usage/#performance-tips","title":"Performance Tips","text":"<ol> <li>Batch Operations: For multiple memories, consider batching your operations</li> <li>Appropriate Limits: Use reasonable search limits (5-50 results typically)</li> <li>Memory Types: Use specific memory type filters when possible</li> <li>Project Filtering: Leverage project-based filtering for better performance</li> </ol>"},{"location":"usage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"usage/#common-issues","title":"Common Issues","text":"<ol> <li>Storage Path Errors: Ensure storage directories exist and are writable</li> <li>YAML Schema Errors: Validate your YAML schema file exists and is valid</li> <li>Memory Type Errors: Ensure memory types match your YAML schema</li> <li>User Isolation: Remember that all operations are user-scoped</li> </ol>"},{"location":"usage/#debug-mode","title":"Debug Mode","text":"<p>Enable debug logging:</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre>"},{"location":"usage/#checking-configuration","title":"Checking Configuration","text":"<pre><code>from memg_core.core.config import get_config\n\nconfig = get_config()\nprint(f\"YAML Path: {config.yaml_path}\")\nprint(f\"Qdrant Path: {config.qdrant_storage_path}\")\nprint(f\"Kuzu Path: {config.kuzu_db_path}\")\n</code></pre>"},{"location":"reference/api/","title":"API Reference","text":"<p>This page provides comprehensive API documentation for memg-core.</p>"},{"location":"reference/api/#public-api","title":"Public API","text":"<p>The main interface for memg-core is through the public API module:</p> <p>Public API for memg-core - designed for long-running servers.</p> <p>Provides MemgClient for explicit initialization and module-level functions for environment-based usage.</p>"},{"location":"reference/api/#memg_core.api.public._CLIENT","title":"<code>_CLIENT = None</code>  <code>module-attribute</code>","text":""},{"location":"reference/api/#memg_core.api.public.DatabaseClients","title":"<code>DatabaseClients</code>","text":"<p>DDL-only database setup - creates schemas and returns raw clients.</p> <p>NO INTERFACES - pure schema creation only. Consumer must create interfaces separately using returned raw clients.</p> <p>Attributes:</p> Name Type Description <code>qdrant_client</code> <code>QdrantClient | None</code> <p>Pre-initialized QdrantClient.</p> <code>kuzu_connection</code> <code>Connection | None</code> <p>Pre-initialized Kuzu connection.</p> <code>db_name</code> <p>Database name.</p> <code>qdrant_path</code> <p>Path to Qdrant database.</p> <code>kuzu_path</code> <p>Path to Kuzu database.</p> <code>yaml_translator</code> <p>YAML translator instance.</p> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>class DatabaseClients:\n    \"\"\"DDL-only database setup - creates schemas and returns raw clients.\n\n    NO INTERFACES - pure schema creation only.\n    Consumer must create interfaces separately using returned raw clients.\n\n    Attributes:\n        qdrant_client: Pre-initialized QdrantClient.\n        kuzu_connection: Pre-initialized Kuzu connection.\n        db_name: Database name.\n        qdrant_path: Path to Qdrant database.\n        kuzu_path: Path to Kuzu database.\n        yaml_translator: YAML translator instance.\n    \"\"\"\n\n    def __init__(self, yaml_path: str | None = None):\n        \"\"\"Create DDL-only database client wrapper.\n\n        Args:\n            yaml_path: Path to YAML schema file. User must provide - no defaults.\n        \"\"\"\n        self.qdrant_client: QdrantClient | None = None\n        self.kuzu_connection: kuzu.Connection | None = None\n        self.db_name = \"memg\"\n        self.qdrant_path = \"qdrant\"\n        self.kuzu_path = \"kuzu\"\n\n        self.yaml_translator = YamlTranslator(yaml_path) if yaml_path else None\n\n    def init_dbs(self, db_path: str, db_name: str):\n        \"\"\"Initialize databases with structured paths.\n\n        Args:\n            db_path: Base database directory.\n            db_name: Database name (used for collection and file names).\n        \"\"\"\n        # Structure paths\n        qdrant_path = os.path.join(db_path, \"qdrant\")\n        kuzu_path = os.path.join(db_path, \"kuzu\", db_name)\n\n        # Store paths and names\n        self.qdrant_path = qdrant_path\n        self.kuzu_path = kuzu_path\n        self.db_name = db_name\n\n        # Ensure directories exist\n        os.makedirs(qdrant_path, exist_ok=True)\n        os.makedirs(Path(kuzu_path).parent, exist_ok=True)\n\n        # Create raw database clients directly\n        qdrant_client = QdrantClient(path=qdrant_path)\n        kuzu_db = kuzu.Database(kuzu_path)\n        kuzu_conn = kuzu.Connection(kuzu_db)\n\n        # Store raw clients for interface creation\n        self.qdrant_client = qdrant_client\n        self.kuzu_connection = kuzu_conn\n\n        # DDL operations - create collection and tables\n        self._setup_qdrant_collection(qdrant_client, self.db_name)\n        self._setup_kuzu_tables_with_graph_register(kuzu_conn)\n\n    def _setup_qdrant_collection(self, client: QdrantClient, collection_name: str) -&gt; None:\n        \"\"\"Create Qdrant collection if it doesn't exist.\n\n        Args:\n            client: Qdrant client instance.\n            collection_name: Name of the collection to create.\n\n        Raises:\n            DatabaseError: If collection creation fails.\n        \"\"\"\n        try:\n            config = get_config()\n            vector_dimension = config.memg.vector_dimension\n\n            collections = client.get_collections()\n            if not any(col.name == collection_name for col in collections.collections):\n                client.create_collection(\n                    collection_name=collection_name,\n                    vectors_config=VectorParams(size=vector_dimension, distance=Distance.COSINE),\n                )\n        except Exception as e:\n            raise DatabaseError(\n                \"Failed to setup Qdrant collection\",\n                operation=\"_setup_qdrant_collection\",\n                original_error=e,\n            ) from e\n\n    def _setup_kuzu_tables_with_graph_register(self, conn: kuzu.Connection) -&gt; None:\n        \"\"\"Create Kuzu tables using GraphRegister for DDL generation.\n\n        Args:\n            conn: Kuzu database connection.\n\n        Raises:\n            DatabaseError: If YAML translator not initialized or table creation fails.\n        \"\"\"\n        if not self.yaml_translator:\n            raise DatabaseError(\n                \"YAML translator not initialized. Provide yaml_path to constructor.\",\n                operation=\"_setup_kuzu_tables_with_graph_register\",\n            )\n\n        try:\n            # Create GraphRegister with YamlTranslator for complete DDL generation\n            graph_register = GraphRegister(yaml_translator=self.yaml_translator)\n\n            # Generate all DDL statements using GraphRegister\n            ddl_statements = graph_register.generate_all_ddl()\n\n            # Execute all DDL statements\n            for ddl in ddl_statements:\n                conn.execute(ddl)\n\n        except Exception as e:\n            raise DatabaseError(\n                \"Failed to setup Kuzu tables using GraphRegister\",\n                operation=\"_setup_kuzu_tables_with_graph_register\",\n                original_error=e,\n            ) from e\n\n    # ===== INTERFACE ACCESS METHODS =====\n    # After DDL operations, provide access to CRUD interfaces\n\n    def get_qdrant_interface(self) -&gt; QdrantInterface:\n        \"\"\"Get Qdrant interface using the initialized client.\n\n        Returns:\n            QdrantInterface: Configured with the DDL-created client and collection.\n\n        Raises:\n            DatabaseError: If client not initialized (call init_dbs first).\n        \"\"\"\n        if self.qdrant_client is None:\n            raise DatabaseError(\n                \"Qdrant client not initialized. Call init_dbs() first.\",\n                operation=\"get_qdrant_interface\",\n            )\n        return QdrantInterface(self.qdrant_client, self.db_name)\n\n    def get_kuzu_interface(self) -&gt; KuzuInterface:\n        \"\"\"Get Kuzu interface using the initialized connection.\n\n        Returns:\n            KuzuInterface: Configured with the DDL-created connection.\n\n        Raises:\n            DatabaseError: If connection not initialized (call init_dbs first).\n        \"\"\"\n        if self.kuzu_connection is None:\n            raise DatabaseError(\n                \"Kuzu connection not initialized. Call init_dbs() first.\",\n                operation=\"get_kuzu_interface\",\n            )\n        return KuzuInterface(self.kuzu_connection, self.yaml_translator)\n\n    def get_embedder(self) -&gt; Embedder:\n        \"\"\"Get embedder instance.\n\n        Returns:\n            Embedder: Instance for generating vectors.\n        \"\"\"\n        return Embedder()\n\n    def get_yaml_translator(self) -&gt; YamlTranslator:\n        \"\"\"Get the YAML translator used for schema operations.\n\n        Returns:\n            YamlTranslator: Instance used during DDL operations.\n\n        Raises:\n            DatabaseError: If YAML translator not initialized.\n        \"\"\"\n        if self.yaml_translator is None:\n            raise DatabaseError(\n                \"YAML translator not initialized. Provide yaml_path to constructor.\",\n                operation=\"get_yaml_translator\",\n            )\n        return self.yaml_translator\n\n    def close(self):\n        \"\"\"Close all database connections and cleanup resources.\n\n        Should be called when database clients are no longer needed.\n        \"\"\"\n        if self.qdrant_client is not None:\n            with suppress(Exception):\n                # Ignore cleanup errors - best effort\n                self.qdrant_client.close()\n            self.qdrant_client = None\n\n        if self.kuzu_connection is not None:\n            with suppress(Exception):\n                # Ignore cleanup errors - best effort\n                self.kuzu_connection.close()\n            self.kuzu_connection = None\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.DatabaseClients.__init__","title":"<code>__init__(yaml_path=None)</code>","text":"<p>Create DDL-only database client wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_path</code> <code>str | None</code> <p>Path to YAML schema file. User must provide - no defaults.</p> <code>None</code> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def __init__(self, yaml_path: str | None = None):\n    \"\"\"Create DDL-only database client wrapper.\n\n    Args:\n        yaml_path: Path to YAML schema file. User must provide - no defaults.\n    \"\"\"\n    self.qdrant_client: QdrantClient | None = None\n    self.kuzu_connection: kuzu.Connection | None = None\n    self.db_name = \"memg\"\n    self.qdrant_path = \"qdrant\"\n    self.kuzu_path = \"kuzu\"\n\n    self.yaml_translator = YamlTranslator(yaml_path) if yaml_path else None\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.DatabaseClients.close","title":"<code>close()</code>","text":"<p>Close all database connections and cleanup resources.</p> <p>Should be called when database clients are no longer needed.</p> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def close(self):\n    \"\"\"Close all database connections and cleanup resources.\n\n    Should be called when database clients are no longer needed.\n    \"\"\"\n    if self.qdrant_client is not None:\n        with suppress(Exception):\n            # Ignore cleanup errors - best effort\n            self.qdrant_client.close()\n        self.qdrant_client = None\n\n    if self.kuzu_connection is not None:\n        with suppress(Exception):\n            # Ignore cleanup errors - best effort\n            self.kuzu_connection.close()\n        self.kuzu_connection = None\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.DatabaseClients.get_embedder","title":"<code>get_embedder()</code>","text":"<p>Get embedder instance.</p> <p>Returns:</p> Name Type Description <code>Embedder</code> <code>Embedder</code> <p>Instance for generating vectors.</p> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def get_embedder(self) -&gt; Embedder:\n    \"\"\"Get embedder instance.\n\n    Returns:\n        Embedder: Instance for generating vectors.\n    \"\"\"\n    return Embedder()\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.DatabaseClients.get_kuzu_interface","title":"<code>get_kuzu_interface()</code>","text":"<p>Get Kuzu interface using the initialized connection.</p> <p>Returns:</p> Name Type Description <code>KuzuInterface</code> <code>KuzuInterface</code> <p>Configured with the DDL-created connection.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If connection not initialized (call init_dbs first).</p> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def get_kuzu_interface(self) -&gt; KuzuInterface:\n    \"\"\"Get Kuzu interface using the initialized connection.\n\n    Returns:\n        KuzuInterface: Configured with the DDL-created connection.\n\n    Raises:\n        DatabaseError: If connection not initialized (call init_dbs first).\n    \"\"\"\n    if self.kuzu_connection is None:\n        raise DatabaseError(\n            \"Kuzu connection not initialized. Call init_dbs() first.\",\n            operation=\"get_kuzu_interface\",\n        )\n    return KuzuInterface(self.kuzu_connection, self.yaml_translator)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.DatabaseClients.get_qdrant_interface","title":"<code>get_qdrant_interface()</code>","text":"<p>Get Qdrant interface using the initialized client.</p> <p>Returns:</p> Name Type Description <code>QdrantInterface</code> <code>QdrantInterface</code> <p>Configured with the DDL-created client and collection.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If client not initialized (call init_dbs first).</p> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def get_qdrant_interface(self) -&gt; QdrantInterface:\n    \"\"\"Get Qdrant interface using the initialized client.\n\n    Returns:\n        QdrantInterface: Configured with the DDL-created client and collection.\n\n    Raises:\n        DatabaseError: If client not initialized (call init_dbs first).\n    \"\"\"\n    if self.qdrant_client is None:\n        raise DatabaseError(\n            \"Qdrant client not initialized. Call init_dbs() first.\",\n            operation=\"get_qdrant_interface\",\n        )\n    return QdrantInterface(self.qdrant_client, self.db_name)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.DatabaseClients.get_yaml_translator","title":"<code>get_yaml_translator()</code>","text":"<p>Get the YAML translator used for schema operations.</p> <p>Returns:</p> Name Type Description <code>YamlTranslator</code> <code>YamlTranslator</code> <p>Instance used during DDL operations.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If YAML translator not initialized.</p> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def get_yaml_translator(self) -&gt; YamlTranslator:\n    \"\"\"Get the YAML translator used for schema operations.\n\n    Returns:\n        YamlTranslator: Instance used during DDL operations.\n\n    Raises:\n        DatabaseError: If YAML translator not initialized.\n    \"\"\"\n    if self.yaml_translator is None:\n        raise DatabaseError(\n            \"YAML translator not initialized. Provide yaml_path to constructor.\",\n            operation=\"get_yaml_translator\",\n        )\n    return self.yaml_translator\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.DatabaseClients.init_dbs","title":"<code>init_dbs(db_path, db_name)</code>","text":"<p>Initialize databases with structured paths.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>str</code> <p>Base database directory.</p> required <code>db_name</code> <code>str</code> <p>Database name (used for collection and file names).</p> required Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def init_dbs(self, db_path: str, db_name: str):\n    \"\"\"Initialize databases with structured paths.\n\n    Args:\n        db_path: Base database directory.\n        db_name: Database name (used for collection and file names).\n    \"\"\"\n    # Structure paths\n    qdrant_path = os.path.join(db_path, \"qdrant\")\n    kuzu_path = os.path.join(db_path, \"kuzu\", db_name)\n\n    # Store paths and names\n    self.qdrant_path = qdrant_path\n    self.kuzu_path = kuzu_path\n    self.db_name = db_name\n\n    # Ensure directories exist\n    os.makedirs(qdrant_path, exist_ok=True)\n    os.makedirs(Path(kuzu_path).parent, exist_ok=True)\n\n    # Create raw database clients directly\n    qdrant_client = QdrantClient(path=qdrant_path)\n    kuzu_db = kuzu.Database(kuzu_path)\n    kuzu_conn = kuzu.Connection(kuzu_db)\n\n    # Store raw clients for interface creation\n    self.qdrant_client = qdrant_client\n    self.kuzu_connection = kuzu_conn\n\n    # DDL operations - create collection and tables\n    self._setup_qdrant_collection(qdrant_client, self.db_name)\n    self._setup_kuzu_tables_with_graph_register(kuzu_conn)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemgClient","title":"<code>MemgClient</code>","text":"<p>Client for memg-core operations - initialize once, use throughout server lifetime.</p> <p>Provides a clean interface for memory operations with explicit resource management.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>class MemgClient:\n    \"\"\"Client for memg-core operations - initialize once, use throughout server lifetime.\n\n    Provides a clean interface for memory operations with explicit resource management.\n    \"\"\"\n\n    def __init__(self, yaml_path: str, db_path: str):\n        \"\"\"Initialize client for long-running server usage.\n\n        Args:\n            yaml_path: Path to YAML schema configuration file.\n            db_path: Base directory path for database storage.\n        \"\"\"\n        self._db_clients = DatabaseClients(yaml_path=yaml_path)\n        self._db_clients.init_dbs(db_path=db_path, db_name=self._db_clients.db_name)\n\n        self._memory_service = create_memory_service(self._db_clients)\n        self._search_service = create_search_service(self._db_clients)\n\n        if not all([self._memory_service, self._search_service]):\n            raise RuntimeError(\"Failed to initialize memg-core services\")\n\n    def add_memory(self, memory_type: str, payload: dict[str, Any], user_id: str) -&gt; str:\n        \"\"\"Add memory and return HRID.\n\n        Args:\n            memory_type: Entity type from YAML schema (e.g., 'task', 'note').\n            payload: Memory data conforming to YAML schema.\n            user_id: Owner of the memory.\n\n        Returns:\n            str: Human-readable ID (HRID) for the created memory.\n        \"\"\"\n        return self._memory_service.add_memory(memory_type, payload, user_id)\n\n    def search(\n        self,\n        query: str,\n        user_id: str,\n        memory_type: str | None = None,\n        limit: int = 10,\n        score_threshold: float | None = None,\n        decay_rate: float | None = None,\n        decay_threshold: float | None = None,\n        **kwargs,\n    ) -&gt; SearchResult:\n        \"\"\"Search memories with explicit seed/neighbor separation.\n\n        Args:\n            query: Text to search for.\n            user_id: User ID for filtering results.\n            memory_type: Optional memory type filter.\n            limit: Maximum number of results to return.\n            score_threshold: Minimum similarity score threshold (0.0-1.0).\n            decay_rate: Score decay factor per hop (default: 1.0 = no decay).\n            decay_threshold: Explicit neighbor score threshold (overrides decay_rate).\n            **kwargs: Additional search parameters.\n\n        Returns:\n            SearchResult: Search result with explicit seed/neighbor separation,\n                including full payloads for seeds and relationships.\n        \"\"\"\n        clean_query = query.strip() if query else \"\"\n        return self._search_service.search(\n            clean_query,\n            user_id,\n            memory_type=memory_type,\n            limit=limit,\n            score_threshold=score_threshold,\n            decay_rate=decay_rate,\n            decay_threshold=decay_threshold,\n            **kwargs,\n        )\n\n    def delete_memory(self, hrid: str, user_id: str, memory_type: str | None = None) -&gt; bool:\n        \"\"\"Delete memory by HRID.\n\n        Args:\n            hrid: Human-readable ID of the memory to delete.\n            user_id: User ID for ownership verification.\n            memory_type: Optional memory type hint.\n\n        Returns:\n            bool: True if deletion succeeded, False otherwise.\n        \"\"\"\n        if memory_type is None:\n            memory_type = hrid.split(\"_\")[0].lower()\n        return self._memory_service.delete_memory(hrid, memory_type, user_id)\n\n    def update_memory(\n        self,\n        hrid: str,\n        payload_updates: dict[str, Any],\n        user_id: str,\n        memory_type: str | None = None,\n    ) -&gt; bool:\n        \"\"\"Update memory with partial payload changes (patch-style update).\n\n        Args:\n            hrid: Memory HRID to update.\n            payload_updates: Dictionary of fields to update (only changed fields).\n            user_id: User ID for ownership verification.\n            memory_type: Optional memory type hint (inferred from HRID if not provided).\n\n        Returns:\n            bool: True if update succeeded, False otherwise.\n        \"\"\"\n        return self._memory_service.update_memory(hrid, payload_updates, user_id, memory_type)\n\n    def add_relationship(\n        self,\n        from_memory_hrid: str,\n        to_memory_hrid: str,\n        relation_type: str,\n        from_memory_type: str,\n        to_memory_type: str,\n        user_id: str,\n        properties: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Add relationship between memories.\n\n        Args:\n            from_memory_hrid: Source memory HRID.\n            to_memory_hrid: Target memory HRID.\n            relation_type: Relationship type from YAML schema.\n            from_memory_type: Source memory entity type.\n            to_memory_type: Target memory entity type.\n            user_id: User ID for ownership verification.\n            properties: Optional relationship properties.\n        \"\"\"\n        self._memory_service.add_relationship(\n            from_memory_hrid,\n            to_memory_hrid,\n            relation_type,\n            from_memory_type,\n            to_memory_type,\n            user_id,\n            properties,\n        )\n\n    def delete_relationship(\n        self,\n        from_memory_hrid: str,\n        to_memory_hrid: str,\n        relation_type: str,\n        from_memory_type: str | None = None,\n        to_memory_type: str | None = None,\n        user_id: str | None = None,\n    ) -&gt; bool:\n        \"\"\"Delete relationship between memories.\n\n        Args:\n            from_memory_hrid: Source memory HRID.\n            to_memory_hrid: Target memory HRID.\n            relation_type: Relationship type from YAML schema.\n            from_memory_type: Source memory entity type (inferred from HRID if not provided).\n            to_memory_type: Target memory entity type (inferred from HRID if not provided).\n            user_id: User ID for ownership verification (required).\n\n        Returns:\n            bool: True if deletion succeeded, False if relationship not found.\n        \"\"\"\n        return self._memory_service.delete_relationship(\n            from_memory_hrid,\n            to_memory_hrid,\n            relation_type,\n            from_memory_type,\n            to_memory_type,\n            user_id,\n        )\n\n    def get_memory(\n        self,\n        hrid: str,\n        user_id: str,\n        memory_type: str | None = None,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Get a single memory by HRID.\n\n        Args:\n            hrid: Human-readable identifier of the memory.\n            user_id: User ID for ownership verification.\n            memory_type: Optional memory type hint (inferred from HRID if not provided).\n\n        Returns:\n            dict[str, Any] | None: Memory data with full payload, or None if not found.\n        \"\"\"\n        return self._search_service.get_memory(hrid, user_id, memory_type)\n\n    def get_memories(\n        self,\n        user_id: str,\n        memory_type: str | None = None,\n        filters: dict[str, Any] | None = None,\n        limit: int = 50,\n        offset: int = 0,\n        include_neighbors: bool = False,\n        hops: int = 1,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Get multiple memories with filtering and optional graph expansion.\n\n        Args:\n            user_id: User ID for ownership verification.\n            memory_type: Optional memory type filter (e.g., \"task\", \"note\").\n            filters: Optional field filters (e.g., {\"status\": \"open\", \"priority\": \"high\"}).\n            limit: Maximum number of memories to return (default 50).\n            offset: Number of memories to skip for pagination (default 0).\n            include_neighbors: Whether to include neighbor nodes via graph traversal.\n            hops: Number of hops for neighbor expansion (default 1).\n\n        Returns:\n            list[dict[str, Any]]: List of memory data with full payloads.\n        \"\"\"\n        return self._search_service.get_memories(\n            user_id, memory_type, filters, limit, offset, include_neighbors, hops\n        )\n\n    def close(self):\n        \"\"\"Close client and cleanup resources.\n\n        Should be called when the client is no longer needed to free database connections.\n        \"\"\"\n        if hasattr(self, \"_db_clients\") and self._db_clients:\n            self._db_clients.close()\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemgClient.__init__","title":"<code>__init__(yaml_path, db_path)</code>","text":"<p>Initialize client for long-running server usage.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_path</code> <code>str</code> <p>Path to YAML schema configuration file.</p> required <code>db_path</code> <code>str</code> <p>Base directory path for database storage.</p> required Source code in <code>src/memg_core/api/public.py</code> <pre><code>def __init__(self, yaml_path: str, db_path: str):\n    \"\"\"Initialize client for long-running server usage.\n\n    Args:\n        yaml_path: Path to YAML schema configuration file.\n        db_path: Base directory path for database storage.\n    \"\"\"\n    self._db_clients = DatabaseClients(yaml_path=yaml_path)\n    self._db_clients.init_dbs(db_path=db_path, db_name=self._db_clients.db_name)\n\n    self._memory_service = create_memory_service(self._db_clients)\n    self._search_service = create_search_service(self._db_clients)\n\n    if not all([self._memory_service, self._search_service]):\n        raise RuntimeError(\"Failed to initialize memg-core services\")\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemgClient.add_memory","title":"<code>add_memory(memory_type, payload, user_id)</code>","text":"<p>Add memory and return HRID.</p> <p>Parameters:</p> Name Type Description Default <code>memory_type</code> <code>str</code> <p>Entity type from YAML schema (e.g., 'task', 'note').</p> required <code>payload</code> <code>dict[str, Any]</code> <p>Memory data conforming to YAML schema.</p> required <code>user_id</code> <code>str</code> <p>Owner of the memory.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable ID (HRID) for the created memory.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def add_memory(self, memory_type: str, payload: dict[str, Any], user_id: str) -&gt; str:\n    \"\"\"Add memory and return HRID.\n\n    Args:\n        memory_type: Entity type from YAML schema (e.g., 'task', 'note').\n        payload: Memory data conforming to YAML schema.\n        user_id: Owner of the memory.\n\n    Returns:\n        str: Human-readable ID (HRID) for the created memory.\n    \"\"\"\n    return self._memory_service.add_memory(memory_type, payload, user_id)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemgClient.add_relationship","title":"<code>add_relationship(from_memory_hrid, to_memory_hrid, relation_type, from_memory_type, to_memory_type, user_id, properties=None)</code>","text":"<p>Add relationship between memories.</p> <p>Parameters:</p> Name Type Description Default <code>from_memory_hrid</code> <code>str</code> <p>Source memory HRID.</p> required <code>to_memory_hrid</code> <code>str</code> <p>Target memory HRID.</p> required <code>relation_type</code> <code>str</code> <p>Relationship type from YAML schema.</p> required <code>from_memory_type</code> <code>str</code> <p>Source memory entity type.</p> required <code>to_memory_type</code> <code>str</code> <p>Target memory entity type.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>properties</code> <code>dict[str, Any] | None</code> <p>Optional relationship properties.</p> <code>None</code> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def add_relationship(\n    self,\n    from_memory_hrid: str,\n    to_memory_hrid: str,\n    relation_type: str,\n    from_memory_type: str,\n    to_memory_type: str,\n    user_id: str,\n    properties: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Add relationship between memories.\n\n    Args:\n        from_memory_hrid: Source memory HRID.\n        to_memory_hrid: Target memory HRID.\n        relation_type: Relationship type from YAML schema.\n        from_memory_type: Source memory entity type.\n        to_memory_type: Target memory entity type.\n        user_id: User ID for ownership verification.\n        properties: Optional relationship properties.\n    \"\"\"\n    self._memory_service.add_relationship(\n        from_memory_hrid,\n        to_memory_hrid,\n        relation_type,\n        from_memory_type,\n        to_memory_type,\n        user_id,\n        properties,\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemgClient.close","title":"<code>close()</code>","text":"<p>Close client and cleanup resources.</p> <p>Should be called when the client is no longer needed to free database connections.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def close(self):\n    \"\"\"Close client and cleanup resources.\n\n    Should be called when the client is no longer needed to free database connections.\n    \"\"\"\n    if hasattr(self, \"_db_clients\") and self._db_clients:\n        self._db_clients.close()\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemgClient.delete_memory","title":"<code>delete_memory(hrid, user_id, memory_type=None)</code>","text":"<p>Delete memory by HRID.</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>Human-readable ID of the memory to delete.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type hint.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if deletion succeeded, False otherwise.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def delete_memory(self, hrid: str, user_id: str, memory_type: str | None = None) -&gt; bool:\n    \"\"\"Delete memory by HRID.\n\n    Args:\n        hrid: Human-readable ID of the memory to delete.\n        user_id: User ID for ownership verification.\n        memory_type: Optional memory type hint.\n\n    Returns:\n        bool: True if deletion succeeded, False otherwise.\n    \"\"\"\n    if memory_type is None:\n        memory_type = hrid.split(\"_\")[0].lower()\n    return self._memory_service.delete_memory(hrid, memory_type, user_id)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemgClient.delete_relationship","title":"<code>delete_relationship(from_memory_hrid, to_memory_hrid, relation_type, from_memory_type=None, to_memory_type=None, user_id=None)</code>","text":"<p>Delete relationship between memories.</p> <p>Parameters:</p> Name Type Description Default <code>from_memory_hrid</code> <code>str</code> <p>Source memory HRID.</p> required <code>to_memory_hrid</code> <code>str</code> <p>Target memory HRID.</p> required <code>relation_type</code> <code>str</code> <p>Relationship type from YAML schema.</p> required <code>from_memory_type</code> <code>str | None</code> <p>Source memory entity type (inferred from HRID if not provided).</p> <code>None</code> <code>to_memory_type</code> <code>str | None</code> <p>Target memory entity type (inferred from HRID if not provided).</p> <code>None</code> <code>user_id</code> <code>str | None</code> <p>User ID for ownership verification (required).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if deletion succeeded, False if relationship not found.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def delete_relationship(\n    self,\n    from_memory_hrid: str,\n    to_memory_hrid: str,\n    relation_type: str,\n    from_memory_type: str | None = None,\n    to_memory_type: str | None = None,\n    user_id: str | None = None,\n) -&gt; bool:\n    \"\"\"Delete relationship between memories.\n\n    Args:\n        from_memory_hrid: Source memory HRID.\n        to_memory_hrid: Target memory HRID.\n        relation_type: Relationship type from YAML schema.\n        from_memory_type: Source memory entity type (inferred from HRID if not provided).\n        to_memory_type: Target memory entity type (inferred from HRID if not provided).\n        user_id: User ID for ownership verification (required).\n\n    Returns:\n        bool: True if deletion succeeded, False if relationship not found.\n    \"\"\"\n    return self._memory_service.delete_relationship(\n        from_memory_hrid,\n        to_memory_hrid,\n        relation_type,\n        from_memory_type,\n        to_memory_type,\n        user_id,\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemgClient.get_memories","title":"<code>get_memories(user_id, memory_type=None, filters=None, limit=50, offset=0, include_neighbors=False, hops=1)</code>","text":"<p>Get multiple memories with filtering and optional graph expansion.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type filter (e.g., \"task\", \"note\").</p> <code>None</code> <code>filters</code> <code>dict[str, Any] | None</code> <p>Optional field filters (e.g., {\"status\": \"open\", \"priority\": \"high\"}).</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of memories to return (default 50).</p> <code>50</code> <code>offset</code> <code>int</code> <p>Number of memories to skip for pagination (default 0).</p> <code>0</code> <code>include_neighbors</code> <code>bool</code> <p>Whether to include neighbor nodes via graph traversal.</p> <code>False</code> <code>hops</code> <code>int</code> <p>Number of hops for neighbor expansion (default 1).</p> <code>1</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: List of memory data with full payloads.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def get_memories(\n    self,\n    user_id: str,\n    memory_type: str | None = None,\n    filters: dict[str, Any] | None = None,\n    limit: int = 50,\n    offset: int = 0,\n    include_neighbors: bool = False,\n    hops: int = 1,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Get multiple memories with filtering and optional graph expansion.\n\n    Args:\n        user_id: User ID for ownership verification.\n        memory_type: Optional memory type filter (e.g., \"task\", \"note\").\n        filters: Optional field filters (e.g., {\"status\": \"open\", \"priority\": \"high\"}).\n        limit: Maximum number of memories to return (default 50).\n        offset: Number of memories to skip for pagination (default 0).\n        include_neighbors: Whether to include neighbor nodes via graph traversal.\n        hops: Number of hops for neighbor expansion (default 1).\n\n    Returns:\n        list[dict[str, Any]]: List of memory data with full payloads.\n    \"\"\"\n    return self._search_service.get_memories(\n        user_id, memory_type, filters, limit, offset, include_neighbors, hops\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemgClient.get_memory","title":"<code>get_memory(hrid, user_id, memory_type=None)</code>","text":"<p>Get a single memory by HRID.</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>Human-readable identifier of the memory.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type hint (inferred from HRID if not provided).</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>dict[str, Any] | None: Memory data with full payload, or None if not found.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def get_memory(\n    self,\n    hrid: str,\n    user_id: str,\n    memory_type: str | None = None,\n) -&gt; dict[str, Any] | None:\n    \"\"\"Get a single memory by HRID.\n\n    Args:\n        hrid: Human-readable identifier of the memory.\n        user_id: User ID for ownership verification.\n        memory_type: Optional memory type hint (inferred from HRID if not provided).\n\n    Returns:\n        dict[str, Any] | None: Memory data with full payload, or None if not found.\n    \"\"\"\n    return self._search_service.get_memory(hrid, user_id, memory_type)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemgClient.search","title":"<code>search(query, user_id, memory_type=None, limit=10, score_threshold=None, decay_rate=None, decay_threshold=None, **kwargs)</code>","text":"<p>Search memories with explicit seed/neighbor separation.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Text to search for.</p> required <code>user_id</code> <code>str</code> <p>User ID for filtering results.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type filter.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of results to return.</p> <code>10</code> <code>score_threshold</code> <code>float | None</code> <p>Minimum similarity score threshold (0.0-1.0).</p> <code>None</code> <code>decay_rate</code> <code>float | None</code> <p>Score decay factor per hop (default: 1.0 = no decay).</p> <code>None</code> <code>decay_threshold</code> <code>float | None</code> <p>Explicit neighbor score threshold (overrides decay_rate).</p> <code>None</code> <code>**kwargs</code> <p>Additional search parameters.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>SearchResult</code> <code>SearchResult</code> <p>Search result with explicit seed/neighbor separation, including full payloads for seeds and relationships.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def search(\n    self,\n    query: str,\n    user_id: str,\n    memory_type: str | None = None,\n    limit: int = 10,\n    score_threshold: float | None = None,\n    decay_rate: float | None = None,\n    decay_threshold: float | None = None,\n    **kwargs,\n) -&gt; SearchResult:\n    \"\"\"Search memories with explicit seed/neighbor separation.\n\n    Args:\n        query: Text to search for.\n        user_id: User ID for filtering results.\n        memory_type: Optional memory type filter.\n        limit: Maximum number of results to return.\n        score_threshold: Minimum similarity score threshold (0.0-1.0).\n        decay_rate: Score decay factor per hop (default: 1.0 = no decay).\n        decay_threshold: Explicit neighbor score threshold (overrides decay_rate).\n        **kwargs: Additional search parameters.\n\n    Returns:\n        SearchResult: Search result with explicit seed/neighbor separation,\n            including full payloads for seeds and relationships.\n    \"\"\"\n    clean_query = query.strip() if query else \"\"\n    return self._search_service.search(\n        clean_query,\n        user_id,\n        memory_type=memory_type,\n        limit=limit,\n        score_threshold=score_threshold,\n        decay_rate=decay_rate,\n        decay_threshold=decay_threshold,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemgClient.update_memory","title":"<code>update_memory(hrid, payload_updates, user_id, memory_type=None)</code>","text":"<p>Update memory with partial payload changes (patch-style update).</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>Memory HRID to update.</p> required <code>payload_updates</code> <code>dict[str, Any]</code> <p>Dictionary of fields to update (only changed fields).</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type hint (inferred from HRID if not provided).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if update succeeded, False otherwise.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def update_memory(\n    self,\n    hrid: str,\n    payload_updates: dict[str, Any],\n    user_id: str,\n    memory_type: str | None = None,\n) -&gt; bool:\n    \"\"\"Update memory with partial payload changes (patch-style update).\n\n    Args:\n        hrid: Memory HRID to update.\n        payload_updates: Dictionary of fields to update (only changed fields).\n        user_id: User ID for ownership verification.\n        memory_type: Optional memory type hint (inferred from HRID if not provided).\n\n    Returns:\n        bool: True if update succeeded, False otherwise.\n    \"\"\"\n    return self._memory_service.update_memory(hrid, payload_updates, user_id, memory_type)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemoryService","title":"<code>MemoryService</code>","text":"<p>Unified memory service - handles indexing, search, and deletion operations.</p> <p>Provides a clean, class-based interface for all memory operations using DatabaseClients for both DDL initialization and CRUD interface access. Eliminates the need for scattered interface creation.</p> <p>Attributes:</p> Name Type Description <code>qdrant</code> <p>Qdrant interface instance.</p> <code>kuzu</code> <p>Kuzu interface instance.</p> <code>embedder</code> <p>Embedder instance.</p> <code>yaml_translator</code> <p>YAML translator instance.</p> <code>hrid_tracker</code> <p>HRID tracker instance.</p> Source code in <code>src/memg_core/core/pipelines/indexer.py</code> <pre><code>class MemoryService:\n    \"\"\"Unified memory service - handles indexing, search, and deletion operations.\n\n    Provides a clean, class-based interface for all memory operations using\n    DatabaseClients for both DDL initialization and CRUD interface access.\n    Eliminates the need for scattered interface creation.\n\n    Attributes:\n        qdrant: Qdrant interface instance.\n        kuzu: Kuzu interface instance.\n        embedder: Embedder instance.\n        yaml_translator: YAML translator instance.\n        hrid_tracker: HRID tracker instance.\n    \"\"\"\n\n    def __init__(self, db_clients):\n        \"\"\"Initialize MemoryService with DatabaseClients.\n\n        Args:\n            db_clients: DatabaseClients instance (after init_dbs() called).\n        \"\"\"\n        if not isinstance(db_clients, DatabaseClients):\n            raise TypeError(\"db_clients must be a DatabaseClients instance\")\n\n        # Get interfaces from DatabaseClients (reuses DDL-created clients)\n        self.qdrant = db_clients.get_qdrant_interface()\n        self.kuzu = db_clients.get_kuzu_interface()\n        self.embedder = db_clients.get_embedder()\n        self.yaml_translator = db_clients.get_yaml_translator()\n        self.hrid_tracker = HridTracker(self.kuzu)\n\n        # Initialize memory serializer for packing/unpacking\n        from .retrieval import MemorySerializer\n\n        self.memory_serializer = MemorySerializer(self.hrid_tracker)\n\n    def add_memory(\n        self,\n        memory_type: str,\n        payload: dict[str, Any],\n        user_id: str,\n        collection: str | None = None,\n    ) -&gt; str:\n        \"\"\"Add a memory to both graph and vector storage.\n\n        Args:\n            memory_type: Entity type from YAML schema (e.g., 'task', 'note').\n            payload: Memory data conforming to YAML schema.\n            user_id: Owner of the memory.\n            collection: Optional Qdrant collection override.\n\n        Returns:\n            str: Memory HRID (Human-readable ID string).\n\n        Raises:\n            ProcessingError: If validation fails or storage operations fail.\n        \"\"\"\n        try:\n            # Create and validate memory from YAML schema using our instance\n            memory = self.yaml_translator.create_memory_from_yaml(memory_type, payload, user_id)\n\n            # Stamp timestamps\n            now = datetime.now(UTC)\n            if not memory.created_at:\n                memory.created_at = now\n            memory.updated_at = now\n\n            # Generate HRID using tracker\n            hrid = generate_hrid(memory_type, user_id, self.hrid_tracker)\n\n            # Get anchor text from YAML-defined anchor field using our instance\n            anchor_text = self.yaml_translator.build_anchor_text(memory)\n            if not anchor_text:\n                raise ProcessingError(\n                    f\"Empty anchor text for memory type '{memory_type}'\",\n                    operation=\"add_memory\",\n                    context={\"memory_id\": memory.id, \"memory_type\": memory_type},\n                )\n\n            # Generate embedding from anchor text\n            vector = self.embedder.get_embedding(anchor_text)\n\n            # Use centralized serializer for packing\n            flat_payload = self.memory_serializer.to_qdrant_payload(memory, hrid)\n            kuzu_data = self.memory_serializer.to_kuzu_data(memory)\n\n            # Add to Qdrant (vector storage) with complete payload\n            success, _point_id = self.qdrant.add_point(\n                vector=vector,\n                payload=flat_payload,\n                point_id=memory.id,\n                collection=collection,\n            )\n            if not success:\n                raise ProcessingError(\n                    \"Failed to add memory to vector storage\",\n                    operation=\"add_memory\",\n                    context={\"memory_id\": memory.id},\n                )\n\n            # Add to Kuzu (graph storage) - use entity-specific table\n            self.kuzu.add_node(memory_type, kuzu_data)\n\n            # Create HRID mapping after successful storage\n            self.hrid_tracker.create_mapping(hrid, memory.id, memory_type, user_id)\n\n            return hrid  # Return HRID, not UUID\n\n        except Exception as e:\n            if isinstance(e, ProcessingError):\n                raise\n            raise ProcessingError(\n                \"Failed to add memory\",\n                operation=\"add_memory\",\n                context={\"memory_type\": memory_type, \"user_id\": user_id},\n                original_error=e,\n            ) from e\n\n    def update_memory(\n        self,\n        hrid: str,\n        payload_updates: dict[str, Any],\n        user_id: str,\n        memory_type: str | None = None,\n        collection: str | None = None,\n    ) -&gt; bool:\n        \"\"\"Update memory with partial payload changes (patch-style update).\n\n        Args:\n            hrid: Memory HRID to update.\n            payload_updates: Dictionary of fields to update (only changed fields).\n            user_id: User ID for ownership verification.\n            memory_type: Optional memory type hint (inferred from HRID if not provided).\n            collection: Optional Qdrant collection override.\n\n        Returns:\n            bool: True if update succeeded.\n\n        Raises:\n            ProcessingError: If update fails or memory not found.\n        \"\"\"\n        try:\n            # Infer memory type from HRID if not provided\n            if memory_type is None:\n                memory_type = hrid.split(\"_\")[0].lower()\n\n            # Get existing UUID to preserve relationships\n            uuid = self.hrid_tracker.get_uuid(hrid, user_id)\n\n            # Get current memory data from Qdrant to merge with updates\n            current_point = self.qdrant.get_point(uuid, collection)\n            if not current_point:\n                raise ProcessingError(\n                    f\"Memory not found for HRID {hrid}\",\n                    operation=\"update_memory\",\n                    context={\"hrid\": hrid, \"user_id\": user_id},\n                )\n\n            # Merge current payload with updates\n            current_payload = current_point.get(\"payload\", {})\n            # Remove system fields from current payload to get user fields only\n            user_fields = {\n                k: v\n                for k, v in current_payload.items()\n                if k\n                not in (\n                    \"id\",\n                    \"user_id\",\n                    \"memory_type\",\n                    \"created_at\",\n                    \"updated_at\",\n                    \"hrid\",\n                )\n            }\n\n            # Merge updates into user fields\n            updated_user_payload = {**user_fields, **payload_updates}\n\n            # Validate merged payload against YAML schema\n            memory = self.yaml_translator.create_memory_from_yaml(\n                memory_type, updated_user_payload, user_id\n            )\n            memory.id = uuid  # Preserve existing UUID for relationships\n\n            # Update timestamps - preserve created_at, update updated_at\n            memory.created_at = datetime.fromisoformat(current_payload.get(\"created_at\"))\n            memory.updated_at = datetime.now(UTC)\n\n            # Get anchor text for vector update\n            anchor_text = self.yaml_translator.build_anchor_text(memory)\n            if not anchor_text:\n                raise ProcessingError(\n                    f\"Empty anchor text for memory type '{memory_type}'\",\n                    operation=\"update_memory\",\n                    context={\"memory_id\": memory.id, \"memory_type\": memory_type},\n                )\n\n            # Generate new embedding from updated anchor text\n            vector = self.embedder.get_embedding(anchor_text)\n\n            # Use centralized serializer for packing\n            flat_payload = self.memory_serializer.to_qdrant_payload(memory, hrid)\n            kuzu_data = self.memory_serializer.to_kuzu_data(memory)\n\n            # Update Qdrant point (upsert with same UUID)\n            success, _point_id = self.qdrant.add_point(\n                vector=vector,\n                payload=flat_payload,\n                point_id=memory.id,  # Same UUID preserves relationships\n                collection=collection,\n            )\n            if not success:\n                raise ProcessingError(\n                    \"Failed to update memory in vector storage\",\n                    operation=\"update_memory\",\n                    context={\"memory_id\": memory.id, \"hrid\": hrid},\n                )\n\n            # Update Kuzu node using efficient update_node method\n            # This preserves relationships and is more efficient than delete+add\n            success = self.kuzu.update_node(memory_type, uuid, kuzu_data, user_id)\n            if not success:\n                raise ProcessingError(\n                    \"Failed to update memory in graph storage - memory not found\",\n                    operation=\"update_memory\",\n                    context={\"memory_id\": uuid, \"hrid\": hrid, \"user_id\": user_id},\n                )\n\n            return True\n\n        except Exception as e:\n            if isinstance(e, ProcessingError):\n                raise\n            raise ProcessingError(\n                \"Failed to update memory\",\n                operation=\"update_memory\",\n                context={\"hrid\": hrid, \"user_id\": user_id, \"memory_type\": memory_type},\n                original_error=e,\n            ) from e\n\n    def add_relationship(\n        self,\n        from_memory_hrid: str,\n        to_memory_hrid: str,\n        relation_type: str,\n        from_memory_type: str,\n        to_memory_type: str,\n        user_id: str,\n        properties: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Add a relationship between two memories using HRIDs.\n\n        Args:\n            from_memory_hrid: Source memory HRID.\n            to_memory_hrid: Target memory HRID.\n            relation_type: Relationship type from YAML schema (e.g., 'ANNOTATES').\n            from_memory_type: Source memory entity type.\n            to_memory_type: Target memory entity type.\n            user_id: User ID for ownership verification.\n            properties: Optional relationship properties.\n\n        Raises:\n            ProcessingError: If relationship creation fails.\n        \"\"\"\n        try:\n            # Translate HRIDs to UUIDs\n            from_uuid = self.hrid_tracker.get_uuid(from_memory_hrid, user_id)\n            to_uuid = self.hrid_tracker.get_uuid(to_memory_hrid, user_id)\n\n            self.kuzu.add_relationship(\n                from_table=from_memory_type,\n                to_table=to_memory_type,\n                rel_type=relation_type,\n                from_id=from_uuid,\n                to_id=to_uuid,\n                user_id=user_id,\n                props=properties or {},\n            )\n        except Exception as e:\n            raise ProcessingError(\n                \"Failed to add relationship\",\n                operation=\"add_relationship\",\n                context={\n                    \"from_hrid\": from_memory_hrid,\n                    \"to_hrid\": to_memory_hrid,\n                    \"relation_type\": relation_type,\n                },\n                original_error=e,\n            ) from e\n\n    def delete_relationship(\n        self,\n        from_memory_hrid: str,\n        to_memory_hrid: str,\n        relation_type: str,\n        from_memory_type: str | None = None,\n        to_memory_type: str | None = None,\n        user_id: str | None = None,\n    ) -&gt; bool:\n        \"\"\"Delete a relationship between two memories using HRIDs.\n\n        Args:\n            from_memory_hrid: Source memory HRID.\n            to_memory_hrid: Target memory HRID.\n            relation_type: Relationship type from YAML schema (e.g., 'ANNOTATES').\n            from_memory_type: Source memory entity type (inferred from HRID if not provided).\n            to_memory_type: Target memory entity type (inferred from HRID if not provided).\n            user_id: User ID for ownership verification (required).\n\n        Returns:\n            bool: True if deletion succeeded, False if relationship not found.\n\n        Raises:\n            ProcessingError: If relationship deletion fails or parameters invalid.\n        \"\"\"\n        try:\n            # Validate required user_id\n            if not user_id:\n                raise ProcessingError(\n                    \"user_id is required for relationship deletion\",\n                    operation=\"delete_relationship\",\n                    context={\"from_hrid\": from_memory_hrid, \"to_hrid\": to_memory_hrid},\n                )\n\n            # Infer memory types from HRIDs if not provided\n            if from_memory_type is None:\n                from_memory_type = from_memory_hrid.split(\"_\")[0].lower()\n            if to_memory_type is None:\n                to_memory_type = to_memory_hrid.split(\"_\")[0].lower()\n\n            # Translate HRIDs to UUIDs\n            from_uuid = self.hrid_tracker.get_uuid(from_memory_hrid, user_id)\n            to_uuid = self.hrid_tracker.get_uuid(to_memory_hrid, user_id)\n\n            # Delete relationship using Kuzu interface\n            return self.kuzu.delete_relationship(\n                from_table=from_memory_type,\n                to_table=to_memory_type,\n                rel_type=relation_type,\n                from_id=from_uuid,\n                to_id=to_uuid,\n                user_id=user_id,\n            )\n\n        except Exception as e:\n            if isinstance(e, ProcessingError):\n                raise\n            raise ProcessingError(\n                \"Failed to delete relationship\",\n                operation=\"delete_relationship\",\n                context={\n                    \"from_hrid\": from_memory_hrid,\n                    \"to_hrid\": to_memory_hrid,\n                    \"relation_type\": relation_type,\n                },\n                original_error=e,\n            ) from e\n\n    def delete_memory(self, memory_hrid: str, memory_type: str, user_id: str) -&gt; bool:\n        \"\"\"Delete a memory from both storages using HRID.\n\n        Args:\n            memory_hrid: Memory HRID to delete.\n            memory_type: Memory entity type.\n            user_id: User ID for ownership verification.\n\n        Returns:\n            bool: True if deletion succeeded.\n        \"\"\"\n        try:\n            # Translate HRID to UUID\n            uuid = self.hrid_tracker.get_uuid(memory_hrid, user_id)\n\n            # Delete from Qdrant (with user ownership verification)\n            qdrant_success = self.qdrant.delete_points([uuid], user_id)\n\n            # Delete from Kuzu (with user_id verification)\n            kuzu_success = self.kuzu.delete_node(memory_type, uuid, user_id)\n\n            # Mark HRID as deleted (soft delete in mapping)\n            if qdrant_success and kuzu_success:\n                self.hrid_tracker.mark_deleted(memory_hrid)\n\n            return qdrant_success and kuzu_success\n\n        except Exception as e:\n            raise ProcessingError(\n                \"Failed to delete memory\",\n                operation=\"delete_memory\",\n                context={\"memory_hrid\": memory_hrid, \"memory_type\": memory_type},\n                original_error=e,\n            ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemoryService.__init__","title":"<code>__init__(db_clients)</code>","text":"<p>Initialize MemoryService with DatabaseClients.</p> <p>Parameters:</p> Name Type Description Default <code>db_clients</code> <p>DatabaseClients instance (after init_dbs() called).</p> required Source code in <code>src/memg_core/core/pipelines/indexer.py</code> <pre><code>def __init__(self, db_clients):\n    \"\"\"Initialize MemoryService with DatabaseClients.\n\n    Args:\n        db_clients: DatabaseClients instance (after init_dbs() called).\n    \"\"\"\n    if not isinstance(db_clients, DatabaseClients):\n        raise TypeError(\"db_clients must be a DatabaseClients instance\")\n\n    # Get interfaces from DatabaseClients (reuses DDL-created clients)\n    self.qdrant = db_clients.get_qdrant_interface()\n    self.kuzu = db_clients.get_kuzu_interface()\n    self.embedder = db_clients.get_embedder()\n    self.yaml_translator = db_clients.get_yaml_translator()\n    self.hrid_tracker = HridTracker(self.kuzu)\n\n    # Initialize memory serializer for packing/unpacking\n    from .retrieval import MemorySerializer\n\n    self.memory_serializer = MemorySerializer(self.hrid_tracker)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemoryService.add_memory","title":"<code>add_memory(memory_type, payload, user_id, collection=None)</code>","text":"<p>Add a memory to both graph and vector storage.</p> <p>Parameters:</p> Name Type Description Default <code>memory_type</code> <code>str</code> <p>Entity type from YAML schema (e.g., 'task', 'note').</p> required <code>payload</code> <code>dict[str, Any]</code> <p>Memory data conforming to YAML schema.</p> required <code>user_id</code> <code>str</code> <p>Owner of the memory.</p> required <code>collection</code> <code>str | None</code> <p>Optional Qdrant collection override.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Memory HRID (Human-readable ID string).</p> <p>Raises:</p> Type Description <code>ProcessingError</code> <p>If validation fails or storage operations fail.</p> Source code in <code>src/memg_core/core/pipelines/indexer.py</code> <pre><code>def add_memory(\n    self,\n    memory_type: str,\n    payload: dict[str, Any],\n    user_id: str,\n    collection: str | None = None,\n) -&gt; str:\n    \"\"\"Add a memory to both graph and vector storage.\n\n    Args:\n        memory_type: Entity type from YAML schema (e.g., 'task', 'note').\n        payload: Memory data conforming to YAML schema.\n        user_id: Owner of the memory.\n        collection: Optional Qdrant collection override.\n\n    Returns:\n        str: Memory HRID (Human-readable ID string).\n\n    Raises:\n        ProcessingError: If validation fails or storage operations fail.\n    \"\"\"\n    try:\n        # Create and validate memory from YAML schema using our instance\n        memory = self.yaml_translator.create_memory_from_yaml(memory_type, payload, user_id)\n\n        # Stamp timestamps\n        now = datetime.now(UTC)\n        if not memory.created_at:\n            memory.created_at = now\n        memory.updated_at = now\n\n        # Generate HRID using tracker\n        hrid = generate_hrid(memory_type, user_id, self.hrid_tracker)\n\n        # Get anchor text from YAML-defined anchor field using our instance\n        anchor_text = self.yaml_translator.build_anchor_text(memory)\n        if not anchor_text:\n            raise ProcessingError(\n                f\"Empty anchor text for memory type '{memory_type}'\",\n                operation=\"add_memory\",\n                context={\"memory_id\": memory.id, \"memory_type\": memory_type},\n            )\n\n        # Generate embedding from anchor text\n        vector = self.embedder.get_embedding(anchor_text)\n\n        # Use centralized serializer for packing\n        flat_payload = self.memory_serializer.to_qdrant_payload(memory, hrid)\n        kuzu_data = self.memory_serializer.to_kuzu_data(memory)\n\n        # Add to Qdrant (vector storage) with complete payload\n        success, _point_id = self.qdrant.add_point(\n            vector=vector,\n            payload=flat_payload,\n            point_id=memory.id,\n            collection=collection,\n        )\n        if not success:\n            raise ProcessingError(\n                \"Failed to add memory to vector storage\",\n                operation=\"add_memory\",\n                context={\"memory_id\": memory.id},\n            )\n\n        # Add to Kuzu (graph storage) - use entity-specific table\n        self.kuzu.add_node(memory_type, kuzu_data)\n\n        # Create HRID mapping after successful storage\n        self.hrid_tracker.create_mapping(hrid, memory.id, memory_type, user_id)\n\n        return hrid  # Return HRID, not UUID\n\n    except Exception as e:\n        if isinstance(e, ProcessingError):\n            raise\n        raise ProcessingError(\n            \"Failed to add memory\",\n            operation=\"add_memory\",\n            context={\"memory_type\": memory_type, \"user_id\": user_id},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemoryService.add_relationship","title":"<code>add_relationship(from_memory_hrid, to_memory_hrid, relation_type, from_memory_type, to_memory_type, user_id, properties=None)</code>","text":"<p>Add a relationship between two memories using HRIDs.</p> <p>Parameters:</p> Name Type Description Default <code>from_memory_hrid</code> <code>str</code> <p>Source memory HRID.</p> required <code>to_memory_hrid</code> <code>str</code> <p>Target memory HRID.</p> required <code>relation_type</code> <code>str</code> <p>Relationship type from YAML schema (e.g., 'ANNOTATES').</p> required <code>from_memory_type</code> <code>str</code> <p>Source memory entity type.</p> required <code>to_memory_type</code> <code>str</code> <p>Target memory entity type.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>properties</code> <code>dict[str, Any] | None</code> <p>Optional relationship properties.</p> <code>None</code> <p>Raises:</p> Type Description <code>ProcessingError</code> <p>If relationship creation fails.</p> Source code in <code>src/memg_core/core/pipelines/indexer.py</code> <pre><code>def add_relationship(\n    self,\n    from_memory_hrid: str,\n    to_memory_hrid: str,\n    relation_type: str,\n    from_memory_type: str,\n    to_memory_type: str,\n    user_id: str,\n    properties: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Add a relationship between two memories using HRIDs.\n\n    Args:\n        from_memory_hrid: Source memory HRID.\n        to_memory_hrid: Target memory HRID.\n        relation_type: Relationship type from YAML schema (e.g., 'ANNOTATES').\n        from_memory_type: Source memory entity type.\n        to_memory_type: Target memory entity type.\n        user_id: User ID for ownership verification.\n        properties: Optional relationship properties.\n\n    Raises:\n        ProcessingError: If relationship creation fails.\n    \"\"\"\n    try:\n        # Translate HRIDs to UUIDs\n        from_uuid = self.hrid_tracker.get_uuid(from_memory_hrid, user_id)\n        to_uuid = self.hrid_tracker.get_uuid(to_memory_hrid, user_id)\n\n        self.kuzu.add_relationship(\n            from_table=from_memory_type,\n            to_table=to_memory_type,\n            rel_type=relation_type,\n            from_id=from_uuid,\n            to_id=to_uuid,\n            user_id=user_id,\n            props=properties or {},\n        )\n    except Exception as e:\n        raise ProcessingError(\n            \"Failed to add relationship\",\n            operation=\"add_relationship\",\n            context={\n                \"from_hrid\": from_memory_hrid,\n                \"to_hrid\": to_memory_hrid,\n                \"relation_type\": relation_type,\n            },\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemoryService.delete_memory","title":"<code>delete_memory(memory_hrid, memory_type, user_id)</code>","text":"<p>Delete a memory from both storages using HRID.</p> <p>Parameters:</p> Name Type Description Default <code>memory_hrid</code> <code>str</code> <p>Memory HRID to delete.</p> required <code>memory_type</code> <code>str</code> <p>Memory entity type.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if deletion succeeded.</p> Source code in <code>src/memg_core/core/pipelines/indexer.py</code> <pre><code>def delete_memory(self, memory_hrid: str, memory_type: str, user_id: str) -&gt; bool:\n    \"\"\"Delete a memory from both storages using HRID.\n\n    Args:\n        memory_hrid: Memory HRID to delete.\n        memory_type: Memory entity type.\n        user_id: User ID for ownership verification.\n\n    Returns:\n        bool: True if deletion succeeded.\n    \"\"\"\n    try:\n        # Translate HRID to UUID\n        uuid = self.hrid_tracker.get_uuid(memory_hrid, user_id)\n\n        # Delete from Qdrant (with user ownership verification)\n        qdrant_success = self.qdrant.delete_points([uuid], user_id)\n\n        # Delete from Kuzu (with user_id verification)\n        kuzu_success = self.kuzu.delete_node(memory_type, uuid, user_id)\n\n        # Mark HRID as deleted (soft delete in mapping)\n        if qdrant_success and kuzu_success:\n            self.hrid_tracker.mark_deleted(memory_hrid)\n\n        return qdrant_success and kuzu_success\n\n    except Exception as e:\n        raise ProcessingError(\n            \"Failed to delete memory\",\n            operation=\"delete_memory\",\n            context={\"memory_hrid\": memory_hrid, \"memory_type\": memory_type},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemoryService.delete_relationship","title":"<code>delete_relationship(from_memory_hrid, to_memory_hrid, relation_type, from_memory_type=None, to_memory_type=None, user_id=None)</code>","text":"<p>Delete a relationship between two memories using HRIDs.</p> <p>Parameters:</p> Name Type Description Default <code>from_memory_hrid</code> <code>str</code> <p>Source memory HRID.</p> required <code>to_memory_hrid</code> <code>str</code> <p>Target memory HRID.</p> required <code>relation_type</code> <code>str</code> <p>Relationship type from YAML schema (e.g., 'ANNOTATES').</p> required <code>from_memory_type</code> <code>str | None</code> <p>Source memory entity type (inferred from HRID if not provided).</p> <code>None</code> <code>to_memory_type</code> <code>str | None</code> <p>Target memory entity type (inferred from HRID if not provided).</p> <code>None</code> <code>user_id</code> <code>str | None</code> <p>User ID for ownership verification (required).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if deletion succeeded, False if relationship not found.</p> <p>Raises:</p> Type Description <code>ProcessingError</code> <p>If relationship deletion fails or parameters invalid.</p> Source code in <code>src/memg_core/core/pipelines/indexer.py</code> <pre><code>def delete_relationship(\n    self,\n    from_memory_hrid: str,\n    to_memory_hrid: str,\n    relation_type: str,\n    from_memory_type: str | None = None,\n    to_memory_type: str | None = None,\n    user_id: str | None = None,\n) -&gt; bool:\n    \"\"\"Delete a relationship between two memories using HRIDs.\n\n    Args:\n        from_memory_hrid: Source memory HRID.\n        to_memory_hrid: Target memory HRID.\n        relation_type: Relationship type from YAML schema (e.g., 'ANNOTATES').\n        from_memory_type: Source memory entity type (inferred from HRID if not provided).\n        to_memory_type: Target memory entity type (inferred from HRID if not provided).\n        user_id: User ID for ownership verification (required).\n\n    Returns:\n        bool: True if deletion succeeded, False if relationship not found.\n\n    Raises:\n        ProcessingError: If relationship deletion fails or parameters invalid.\n    \"\"\"\n    try:\n        # Validate required user_id\n        if not user_id:\n            raise ProcessingError(\n                \"user_id is required for relationship deletion\",\n                operation=\"delete_relationship\",\n                context={\"from_hrid\": from_memory_hrid, \"to_hrid\": to_memory_hrid},\n            )\n\n        # Infer memory types from HRIDs if not provided\n        if from_memory_type is None:\n            from_memory_type = from_memory_hrid.split(\"_\")[0].lower()\n        if to_memory_type is None:\n            to_memory_type = to_memory_hrid.split(\"_\")[0].lower()\n\n        # Translate HRIDs to UUIDs\n        from_uuid = self.hrid_tracker.get_uuid(from_memory_hrid, user_id)\n        to_uuid = self.hrid_tracker.get_uuid(to_memory_hrid, user_id)\n\n        # Delete relationship using Kuzu interface\n        return self.kuzu.delete_relationship(\n            from_table=from_memory_type,\n            to_table=to_memory_type,\n            rel_type=relation_type,\n            from_id=from_uuid,\n            to_id=to_uuid,\n            user_id=user_id,\n        )\n\n    except Exception as e:\n        if isinstance(e, ProcessingError):\n            raise\n        raise ProcessingError(\n            \"Failed to delete relationship\",\n            operation=\"delete_relationship\",\n            context={\n                \"from_hrid\": from_memory_hrid,\n                \"to_hrid\": to_memory_hrid,\n                \"relation_type\": relation_type,\n            },\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.MemoryService.update_memory","title":"<code>update_memory(hrid, payload_updates, user_id, memory_type=None, collection=None)</code>","text":"<p>Update memory with partial payload changes (patch-style update).</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>Memory HRID to update.</p> required <code>payload_updates</code> <code>dict[str, Any]</code> <p>Dictionary of fields to update (only changed fields).</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type hint (inferred from HRID if not provided).</p> <code>None</code> <code>collection</code> <code>str | None</code> <p>Optional Qdrant collection override.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if update succeeded.</p> <p>Raises:</p> Type Description <code>ProcessingError</code> <p>If update fails or memory not found.</p> Source code in <code>src/memg_core/core/pipelines/indexer.py</code> <pre><code>def update_memory(\n    self,\n    hrid: str,\n    payload_updates: dict[str, Any],\n    user_id: str,\n    memory_type: str | None = None,\n    collection: str | None = None,\n) -&gt; bool:\n    \"\"\"Update memory with partial payload changes (patch-style update).\n\n    Args:\n        hrid: Memory HRID to update.\n        payload_updates: Dictionary of fields to update (only changed fields).\n        user_id: User ID for ownership verification.\n        memory_type: Optional memory type hint (inferred from HRID if not provided).\n        collection: Optional Qdrant collection override.\n\n    Returns:\n        bool: True if update succeeded.\n\n    Raises:\n        ProcessingError: If update fails or memory not found.\n    \"\"\"\n    try:\n        # Infer memory type from HRID if not provided\n        if memory_type is None:\n            memory_type = hrid.split(\"_\")[0].lower()\n\n        # Get existing UUID to preserve relationships\n        uuid = self.hrid_tracker.get_uuid(hrid, user_id)\n\n        # Get current memory data from Qdrant to merge with updates\n        current_point = self.qdrant.get_point(uuid, collection)\n        if not current_point:\n            raise ProcessingError(\n                f\"Memory not found for HRID {hrid}\",\n                operation=\"update_memory\",\n                context={\"hrid\": hrid, \"user_id\": user_id},\n            )\n\n        # Merge current payload with updates\n        current_payload = current_point.get(\"payload\", {})\n        # Remove system fields from current payload to get user fields only\n        user_fields = {\n            k: v\n            for k, v in current_payload.items()\n            if k\n            not in (\n                \"id\",\n                \"user_id\",\n                \"memory_type\",\n                \"created_at\",\n                \"updated_at\",\n                \"hrid\",\n            )\n        }\n\n        # Merge updates into user fields\n        updated_user_payload = {**user_fields, **payload_updates}\n\n        # Validate merged payload against YAML schema\n        memory = self.yaml_translator.create_memory_from_yaml(\n            memory_type, updated_user_payload, user_id\n        )\n        memory.id = uuid  # Preserve existing UUID for relationships\n\n        # Update timestamps - preserve created_at, update updated_at\n        memory.created_at = datetime.fromisoformat(current_payload.get(\"created_at\"))\n        memory.updated_at = datetime.now(UTC)\n\n        # Get anchor text for vector update\n        anchor_text = self.yaml_translator.build_anchor_text(memory)\n        if not anchor_text:\n            raise ProcessingError(\n                f\"Empty anchor text for memory type '{memory_type}'\",\n                operation=\"update_memory\",\n                context={\"memory_id\": memory.id, \"memory_type\": memory_type},\n            )\n\n        # Generate new embedding from updated anchor text\n        vector = self.embedder.get_embedding(anchor_text)\n\n        # Use centralized serializer for packing\n        flat_payload = self.memory_serializer.to_qdrant_payload(memory, hrid)\n        kuzu_data = self.memory_serializer.to_kuzu_data(memory)\n\n        # Update Qdrant point (upsert with same UUID)\n        success, _point_id = self.qdrant.add_point(\n            vector=vector,\n            payload=flat_payload,\n            point_id=memory.id,  # Same UUID preserves relationships\n            collection=collection,\n        )\n        if not success:\n            raise ProcessingError(\n                \"Failed to update memory in vector storage\",\n                operation=\"update_memory\",\n                context={\"memory_id\": memory.id, \"hrid\": hrid},\n            )\n\n        # Update Kuzu node using efficient update_node method\n        # This preserves relationships and is more efficient than delete+add\n        success = self.kuzu.update_node(memory_type, uuid, kuzu_data, user_id)\n        if not success:\n            raise ProcessingError(\n                \"Failed to update memory in graph storage - memory not found\",\n                operation=\"update_memory\",\n                context={\"memory_id\": uuid, \"hrid\": hrid, \"user_id\": user_id},\n            )\n\n        return True\n\n    except Exception as e:\n        if isinstance(e, ProcessingError):\n            raise\n        raise ProcessingError(\n            \"Failed to update memory\",\n            operation=\"update_memory\",\n            context={\"hrid\": hrid, \"user_id\": user_id, \"memory_type\": memory_type},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.SearchResult","title":"<code>SearchResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Search result with explicit seed/neighbor separation.</p> <p>Attributes:</p> Name Type Description <code>memories</code> <code>list[MemorySeed]</code> <p>List of memory seeds with full payloads and relationships.</p> <code>neighbors</code> <code>list[MemoryNeighbor]</code> <p>List of memory neighbors with anchor-only payloads.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>class SearchResult(BaseModel):\n    \"\"\"Search result with explicit seed/neighbor separation.\n\n    Attributes:\n        memories: List of memory seeds with full payloads and relationships.\n        neighbors: List of memory neighbors with anchor-only payloads.\n    \"\"\"\n\n    memories: list[MemorySeed] = Field(\n        default_factory=list, description=\"Memory seeds with full payloads\"\n    )\n    neighbors: list[MemoryNeighbor] = Field(\n        default_factory=list, description=\"Memory neighbors with anchor payloads\"\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.SearchService","title":"<code>SearchService</code>","text":"<p>Search orchestration service - coordinates specialized handlers for GraphRAG operations.</p> <p>Clean orchestration layer that delegates to specialized handlers: - VectorSearchHandler: Qdrant vector search and seed generation - GraphExpansionHandler: Kuzu graph traversal and neighbor expansion - MemorySerializer: Memory object packing/unpacking and conversion - PayloadProjector: Payload filtering and projection</p> <p>Attributes:</p> Name Type Description <code>vector_handler</code> <p>Handles vector search operations.</p> <code>graph_handler</code> <p>Handles graph expansion operations.</p> <code>memory_serializer</code> <p>Handles memory serialization and construction.</p> <code>payload_projector</code> <p>Handles payload projection.</p> Source code in <code>src/memg_core/core/pipelines/retrieval.py</code> <pre><code>class SearchService:\n    \"\"\"Search orchestration service - coordinates specialized handlers for GraphRAG operations.\n\n    Clean orchestration layer that delegates to specialized handlers:\n    - VectorSearchHandler: Qdrant vector search and seed generation\n    - GraphExpansionHandler: Kuzu graph traversal and neighbor expansion\n    - MemorySerializer: Memory object packing/unpacking and conversion\n    - PayloadProjector: Payload filtering and projection\n\n    Attributes:\n        vector_handler: Handles vector search operations.\n        graph_handler: Handles graph expansion operations.\n        memory_serializer: Handles memory serialization and construction.\n        payload_projector: Handles payload projection.\n    \"\"\"\n\n    def __init__(self, db_clients):\n        \"\"\"Initialize SearchService with DatabaseClients.\n\n        Args:\n            db_clients: DatabaseClients instance (after init_dbs() called).\n        \"\"\"\n        if not isinstance(db_clients, DatabaseClients):\n            raise TypeError(\"db_clients must be a DatabaseClients instance\")\n\n        # Get interfaces from DatabaseClients (reuses DDL-created clients)\n        self.qdrant = db_clients.get_qdrant_interface()\n        self.kuzu = db_clients.get_kuzu_interface()\n        self.embedder = db_clients.get_embedder()\n        self.yaml_translator = db_clients.get_yaml_translator()\n        self.hrid_tracker = HridTracker(self.kuzu)\n        self.config = get_config()\n\n        # Initialize utility classes\n        self.memory_serializer = MemorySerializer(self.hrid_tracker)\n        self.payload_projector = PayloadProjector(self.yaml_translator)\n\n        # Initialize handler classes\n        self.vector_handler = VectorSearchHandler(\n            self.qdrant, self.embedder, self.memory_serializer, self.payload_projector\n        )\n        self.graph_handler = GraphExpansionHandler(\n            self.kuzu,\n            self.embedder,\n            self.yaml_translator,\n            self.memory_serializer,\n            self.payload_projector,\n            self.hrid_tracker,\n        )\n\n    def search(\n        self,\n        query: str,\n        user_id: str,\n        limit: int = 5,\n        *,\n        memory_type: str | None = None,\n        relation_names: list[str] | None = None,\n        neighbor_limit: int = 5,\n        hops: int = 1,\n        include_details: str = \"self\",\n        modified_within_days: int | None = None,\n        filters: dict[str, Any] | None = None,\n        projection: dict[str, list[str]] | None = None,\n        score_threshold: float | None = None,\n        decay_rate: float | None = None,\n        decay_threshold: float | None = None,\n    ) -&gt; SearchResult:\n        \"\"\"GraphRAG search orchestration: vector seeds \u2192 graph expansion \u2192 result composition.\n\n        Pure orchestration method that delegates to specialized handlers for clean separation of concerns.\n\n        Args:\n            query: Search query text (required).\n            user_id: User ID for filtering (required).\n            limit: Maximum results to return (default: 5).\n            memory_type: Optional memory type filter.\n            relation_names: Specific relations to expand (None = all relations).\n            neighbor_limit: Max neighbors per seed (default: 5).\n            hops: Number of graph hops to expand (default: 1).\n            include_details: \"self\" (full payload) or \"none\" (anchor only) for seeds.\n            modified_within_days: Filter by recency (e.g., last 7 days).\n            filters: Custom field-based filtering (e.g., {\"project\": \"memg-core\"}).\n            projection: Control which fields to return per memory type.\n            score_threshold: Minimum similarity score threshold (0.0-1.0).\n            decay_rate: Score decay factor per hop (default: 1.0 = no decay).\n            decay_threshold: Explicit neighbor score threshold (overrides decay_rate).\n\n        Returns:\n            SearchResult: Search result with explicit seed/neighbor separation.\n        \"\"\"\n        # 1. Get seeds from vector search using handler\n        seeds = self.vector_handler.search_seeds(\n            query=query,\n            user_id=user_id,\n            limit=limit,\n            memory_type=memory_type,\n            modified_within_days=modified_within_days,\n            filters=filters,\n            projection=projection,\n            score_threshold=score_threshold,\n            include_details=include_details,\n        )\n\n        if not seeds:\n            return SearchResult()\n\n        # 2. Graph expansion (neighbors with anchor-only payloads)\n        neighbors: list[MemoryNeighbor] = []\n        if hops &gt; 0:\n            # Calculate neighbor filtering threshold\n            neighbor_threshold = self._calculate_neighbor_threshold(\n                score_threshold, decay_rate, decay_threshold, hops\n            )\n\n            neighbors = self.graph_handler.expand_neighbors(\n                seeds=seeds,\n                user_id=user_id,\n                relation_names=relation_names,\n                neighbor_limit=neighbor_limit,\n                hops=hops,\n                projection=projection,\n                neighbor_threshold=neighbor_threshold,\n            )\n\n        # Compose final SearchResult with seeds and neighbors\n        return SearchResult(\n            memories=seeds,\n            neighbors=neighbors,\n        )\n\n    def _calculate_neighbor_threshold(\n        self,\n        score_threshold: float | None,\n        decay_rate: float | None,\n        decay_threshold: float | None,\n        hops: int,\n    ) -&gt; float | None:\n        \"\"\"Calculate neighbor filtering threshold using elegant hierarchy.\n\n        Args:\n            score_threshold: Minimum similarity score for seeds.\n            decay_rate: Score decay factor per hop (1.0 = no decay).\n            decay_threshold: Explicit neighbor threshold (overrides decay_rate).\n            hops: Number of graph hops.\n\n        Returns:\n            float | None: Neighbor threshold or None (no filtering).\n        \"\"\"\n        # 1. Most explicit: User specified exact neighbor threshold\n        if decay_threshold is not None:\n            return decay_threshold\n\n        # 2. Dynamic decay: Calculate threshold based on hops\n        if score_threshold is not None and decay_rate is not None:\n            return score_threshold * (decay_rate**hops)\n\n        # 3. Conservative default: Same threshold for neighbors as seeds\n        if score_threshold is not None:\n            return score_threshold\n\n        # 4. No filtering\n        return None\n\n    def get_memory(\n        self,\n        hrid: str,\n        user_id: str,\n        memory_type: str | None = None,\n        collection: str | None = None,\n    ) -&gt; dict[str, Any] | None:\n        \"\"\"Get a single memory by HRID.\n\n        Args:\n            hrid: Human-readable identifier of the memory.\n            user_id: User ID for ownership verification.\n            memory_type: Optional memory type hint (inferred from HRID if not provided).\n            collection: Optional Qdrant collection override.\n\n        Returns:\n            dict[str, Any] | None: Memory data with full payload, or None if not found.\n        \"\"\"\n        try:\n            # Infer memory type from HRID if not provided\n            if memory_type is None:\n                memory_type = hrid.split(\"_\")[0].lower()\n\n            # Get UUID from HRID\n            uuid = self.hrid_tracker.get_uuid(hrid, user_id)\n            if not uuid:\n                return None\n\n            # Get memory data from Qdrant\n            point_data = self.qdrant.get_point(uuid, collection)\n            if not point_data:\n                return None\n\n            # Verify user ownership\n            payload = point_data.get(\"payload\", {})\n            if payload.get(\"user_id\") != user_id:\n                return None\n\n            # Build response with full memory information (HRID-only policy - no UUID exposure)\n            memory_data = {\n                \"hrid\": hrid,\n                \"memory_type\": payload.get(\"memory_type\", memory_type),\n                \"user_id\": user_id,\n                \"created_at\": payload.get(\"created_at\"),\n                \"updated_at\": payload.get(\"updated_at\"),\n                \"payload\": {\n                    k: v\n                    for k, v in payload.items()\n                    if k\n                    not in (\n                        \"id\",\n                        \"user_id\",\n                        \"memory_type\",\n                        \"created_at\",\n                        \"updated_at\",\n                        \"hrid\",\n                    )\n                },\n            }\n\n            return memory_data\n\n        except (DatabaseError, ValueError, KeyError):\n            return None\n\n    def get_memories(\n        self,\n        user_id: str,\n        memory_type: str | None = None,\n        filters: dict[str, Any] | None = None,\n        limit: int = 50,\n        offset: int = 0,\n        include_neighbors: bool = False,\n        hops: int = 1,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Get multiple memories with filtering and optional graph expansion.\n\n        Args:\n            user_id: User ID for ownership verification.\n            memory_type: Optional memory type filter (e.g., \"task\", \"note\").\n            filters: Optional field filters (e.g., {\"status\": \"open\", \"priority\": \"high\"}).\n            limit: Maximum number of memories to return (default 50).\n            offset: Number of memories to skip for pagination (default 0).\n            include_neighbors: Whether to include neighbor nodes via graph traversal.\n            hops: Number of hops for neighbor expansion (default 1).\n\n        Returns:\n            list[dict[str, Any]]: List of memory data with full payloads.\n        \"\"\"\n        try:\n            # Use KuzuInterface to get nodes with filtering\n            results = self.kuzu.get_nodes(\n                user_id=user_id,\n                node_type=memory_type,\n                filters=filters,\n                limit=limit,\n                offset=offset,\n            )\n\n            # Convert Kuzu results directly to memory data\n            memories = []\n            for result in results:\n                node_data = result.get(\"node\", {})\n\n                # Get HRID from UUID\n                uuid = result.get(\"id\")\n                hrid = self.hrid_tracker.get_hrid(uuid, user_id) if uuid else None\n\n                if not hrid:\n                    continue\n\n                # Filter out UUID fields from payload (consumers should only see HRIDs)\n                filtered_payload = {\n                    k: v for k, v in node_data.items() if k not in [\"id\", \"_id\", \"uuid\"]\n                }\n\n                # Build memory data directly\n                memory_data = {\n                    \"hrid\": hrid,\n                    \"memory_type\": result.get(\"memory_type\"),\n                    \"user_id\": user_id,\n                    \"created_at\": result.get(\"created_at\"),\n                    \"updated_at\": result.get(\"updated_at\"),\n                    \"payload\": filtered_payload,\n                    \"score\": 1.0,  # Not from vector search\n                    \"source\": \"kuzu_query\",\n                    \"metadata\": {\"query_type\": \"get_memories\"},\n                }\n\n                memories.append(memory_data)\n\n            # Apply graph expansion if requested\n            if include_neighbors and memories:\n                # Convert to MemorySeed objects for graph expansion\n                memory_seeds = []\n                for memory_data in memories:\n                    # Create MemorySeed directly from memory_data\n                    hrid = memory_data[\"hrid\"]\n\n                    # Create MemorySeed\n                    created_at = memory_data.get(\"created_at\")\n                    updated_at = memory_data.get(\"updated_at\")\n\n                    # Parse datetime strings if they exist, otherwise use current time\n                    if isinstance(created_at, str):\n                        created_at = _parse_datetime(created_at)\n                    elif created_at is None:\n                        created_at = datetime.now(UTC)\n\n                    if isinstance(updated_at, str):\n                        updated_at = _parse_datetime(updated_at)\n                    elif updated_at is None:\n                        updated_at = datetime.now(UTC)\n\n                    seed = MemorySeed(\n                        user_id=user_id,\n                        hrid=hrid,\n                        memory_type=memory_data[\"memory_type\"],\n                        created_at=created_at,\n                        updated_at=updated_at,\n                        payload=memory_data[\"payload\"],\n                        score=memory_data[\"score\"],\n                        relationships=[],  # Will be populated by graph expansion\n                    )\n                    memory_seeds.append(seed)\n\n                # Apply graph expansion using the graph handler\n                neighbors = self.graph_handler.expand_neighbors(\n                    seeds=memory_seeds,\n                    user_id=user_id,\n                    relation_names=None,  # All relations\n                    neighbor_limit=5,  # Default limit\n                    hops=hops,\n                    projection=None,\n                )\n\n                # Create SearchResult to maintain consistency\n                expanded_result = SearchResult(\n                    memories=memory_seeds,\n                    neighbors=neighbors,\n                )\n\n                # Convert back to dict format for API compatibility\n                expanded_memories = []\n                for seed in expanded_result.memories:\n                    memory_data = {\n                        \"hrid\": seed.hrid,\n                        \"memory_type\": seed.memory_type,\n                        \"user_id\": user_id,  # Use the user_id parameter\n                        \"created_at\": None,  # Not available in MemorySeed\n                        \"updated_at\": None,  # Not available in MemorySeed\n                        \"payload\": seed.payload,\n                        \"score\": seed.score,\n                        \"source\": \"kuzu_query_expanded\",\n                        \"metadata\": {\"query_type\": \"get_memories_expanded\"},\n                        \"relationships\": [\n                            {\n                                \"relation_type\": rel.relation_type,\n                                \"target_hrid\": rel.target_hrid,\n                                \"score\": rel.score,\n                            }\n                            for rel in seed.relationships\n                        ],\n                    }\n                    expanded_memories.append(memory_data)\n\n                return expanded_memories\n\n            return memories\n\n        except (DatabaseError, ValueError, KeyError) as e:\n            # Log the error instead of silently failing\n            logging.error(f\"get_memories() failed: {type(e).__name__}: {e}\", exc_info=True)\n            return []\n\n    def get_memory_neighbors(\n        self,\n        memory_id: str,\n        memory_type: str,\n        user_id: str,\n        relation_types: list[str] | None = None,\n        direction: str = \"any\",\n        limit: int = 10,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Get related memories through graph relationships.\n\n        Args:\n            memory_id: Memory ID to find neighbors for\n            memory_type: Memory entity type\n            user_id: User ID for isolation\n            relation_types: Filter by specific relationship types\n            direction: \"in\", \"out\", or \"any\"\n            limit: Maximum number of neighbors\n\n        Returns:\n            List of neighbor memories with relationship info\n        \"\"\"\n        try:\n            return self.kuzu.neighbors(\n                node_label=memory_type,\n                node_uuid=memory_id,\n                user_id=user_id,\n                rel_types=relation_types,\n                direction=direction,\n                limit=limit,\n            )\n        except Exception as e:\n            raise ProcessingError(\n                \"Failed to get memory neighbors\",\n                operation=\"get_memory_neighbors\",\n                context={\"memory_id\": memory_id, \"memory_type\": memory_type},\n                original_error=e,\n            ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.SearchService.__init__","title":"<code>__init__(db_clients)</code>","text":"<p>Initialize SearchService with DatabaseClients.</p> <p>Parameters:</p> Name Type Description Default <code>db_clients</code> <p>DatabaseClients instance (after init_dbs() called).</p> required Source code in <code>src/memg_core/core/pipelines/retrieval.py</code> <pre><code>def __init__(self, db_clients):\n    \"\"\"Initialize SearchService with DatabaseClients.\n\n    Args:\n        db_clients: DatabaseClients instance (after init_dbs() called).\n    \"\"\"\n    if not isinstance(db_clients, DatabaseClients):\n        raise TypeError(\"db_clients must be a DatabaseClients instance\")\n\n    # Get interfaces from DatabaseClients (reuses DDL-created clients)\n    self.qdrant = db_clients.get_qdrant_interface()\n    self.kuzu = db_clients.get_kuzu_interface()\n    self.embedder = db_clients.get_embedder()\n    self.yaml_translator = db_clients.get_yaml_translator()\n    self.hrid_tracker = HridTracker(self.kuzu)\n    self.config = get_config()\n\n    # Initialize utility classes\n    self.memory_serializer = MemorySerializer(self.hrid_tracker)\n    self.payload_projector = PayloadProjector(self.yaml_translator)\n\n    # Initialize handler classes\n    self.vector_handler = VectorSearchHandler(\n        self.qdrant, self.embedder, self.memory_serializer, self.payload_projector\n    )\n    self.graph_handler = GraphExpansionHandler(\n        self.kuzu,\n        self.embedder,\n        self.yaml_translator,\n        self.memory_serializer,\n        self.payload_projector,\n        self.hrid_tracker,\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.SearchService.get_memories","title":"<code>get_memories(user_id, memory_type=None, filters=None, limit=50, offset=0, include_neighbors=False, hops=1)</code>","text":"<p>Get multiple memories with filtering and optional graph expansion.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type filter (e.g., \"task\", \"note\").</p> <code>None</code> <code>filters</code> <code>dict[str, Any] | None</code> <p>Optional field filters (e.g., {\"status\": \"open\", \"priority\": \"high\"}).</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of memories to return (default 50).</p> <code>50</code> <code>offset</code> <code>int</code> <p>Number of memories to skip for pagination (default 0).</p> <code>0</code> <code>include_neighbors</code> <code>bool</code> <p>Whether to include neighbor nodes via graph traversal.</p> <code>False</code> <code>hops</code> <code>int</code> <p>Number of hops for neighbor expansion (default 1).</p> <code>1</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: List of memory data with full payloads.</p> Source code in <code>src/memg_core/core/pipelines/retrieval.py</code> <pre><code>def get_memories(\n    self,\n    user_id: str,\n    memory_type: str | None = None,\n    filters: dict[str, Any] | None = None,\n    limit: int = 50,\n    offset: int = 0,\n    include_neighbors: bool = False,\n    hops: int = 1,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Get multiple memories with filtering and optional graph expansion.\n\n    Args:\n        user_id: User ID for ownership verification.\n        memory_type: Optional memory type filter (e.g., \"task\", \"note\").\n        filters: Optional field filters (e.g., {\"status\": \"open\", \"priority\": \"high\"}).\n        limit: Maximum number of memories to return (default 50).\n        offset: Number of memories to skip for pagination (default 0).\n        include_neighbors: Whether to include neighbor nodes via graph traversal.\n        hops: Number of hops for neighbor expansion (default 1).\n\n    Returns:\n        list[dict[str, Any]]: List of memory data with full payloads.\n    \"\"\"\n    try:\n        # Use KuzuInterface to get nodes with filtering\n        results = self.kuzu.get_nodes(\n            user_id=user_id,\n            node_type=memory_type,\n            filters=filters,\n            limit=limit,\n            offset=offset,\n        )\n\n        # Convert Kuzu results directly to memory data\n        memories = []\n        for result in results:\n            node_data = result.get(\"node\", {})\n\n            # Get HRID from UUID\n            uuid = result.get(\"id\")\n            hrid = self.hrid_tracker.get_hrid(uuid, user_id) if uuid else None\n\n            if not hrid:\n                continue\n\n            # Filter out UUID fields from payload (consumers should only see HRIDs)\n            filtered_payload = {\n                k: v for k, v in node_data.items() if k not in [\"id\", \"_id\", \"uuid\"]\n            }\n\n            # Build memory data directly\n            memory_data = {\n                \"hrid\": hrid,\n                \"memory_type\": result.get(\"memory_type\"),\n                \"user_id\": user_id,\n                \"created_at\": result.get(\"created_at\"),\n                \"updated_at\": result.get(\"updated_at\"),\n                \"payload\": filtered_payload,\n                \"score\": 1.0,  # Not from vector search\n                \"source\": \"kuzu_query\",\n                \"metadata\": {\"query_type\": \"get_memories\"},\n            }\n\n            memories.append(memory_data)\n\n        # Apply graph expansion if requested\n        if include_neighbors and memories:\n            # Convert to MemorySeed objects for graph expansion\n            memory_seeds = []\n            for memory_data in memories:\n                # Create MemorySeed directly from memory_data\n                hrid = memory_data[\"hrid\"]\n\n                # Create MemorySeed\n                created_at = memory_data.get(\"created_at\")\n                updated_at = memory_data.get(\"updated_at\")\n\n                # Parse datetime strings if they exist, otherwise use current time\n                if isinstance(created_at, str):\n                    created_at = _parse_datetime(created_at)\n                elif created_at is None:\n                    created_at = datetime.now(UTC)\n\n                if isinstance(updated_at, str):\n                    updated_at = _parse_datetime(updated_at)\n                elif updated_at is None:\n                    updated_at = datetime.now(UTC)\n\n                seed = MemorySeed(\n                    user_id=user_id,\n                    hrid=hrid,\n                    memory_type=memory_data[\"memory_type\"],\n                    created_at=created_at,\n                    updated_at=updated_at,\n                    payload=memory_data[\"payload\"],\n                    score=memory_data[\"score\"],\n                    relationships=[],  # Will be populated by graph expansion\n                )\n                memory_seeds.append(seed)\n\n            # Apply graph expansion using the graph handler\n            neighbors = self.graph_handler.expand_neighbors(\n                seeds=memory_seeds,\n                user_id=user_id,\n                relation_names=None,  # All relations\n                neighbor_limit=5,  # Default limit\n                hops=hops,\n                projection=None,\n            )\n\n            # Create SearchResult to maintain consistency\n            expanded_result = SearchResult(\n                memories=memory_seeds,\n                neighbors=neighbors,\n            )\n\n            # Convert back to dict format for API compatibility\n            expanded_memories = []\n            for seed in expanded_result.memories:\n                memory_data = {\n                    \"hrid\": seed.hrid,\n                    \"memory_type\": seed.memory_type,\n                    \"user_id\": user_id,  # Use the user_id parameter\n                    \"created_at\": None,  # Not available in MemorySeed\n                    \"updated_at\": None,  # Not available in MemorySeed\n                    \"payload\": seed.payload,\n                    \"score\": seed.score,\n                    \"source\": \"kuzu_query_expanded\",\n                    \"metadata\": {\"query_type\": \"get_memories_expanded\"},\n                    \"relationships\": [\n                        {\n                            \"relation_type\": rel.relation_type,\n                            \"target_hrid\": rel.target_hrid,\n                            \"score\": rel.score,\n                        }\n                        for rel in seed.relationships\n                    ],\n                }\n                expanded_memories.append(memory_data)\n\n            return expanded_memories\n\n        return memories\n\n    except (DatabaseError, ValueError, KeyError) as e:\n        # Log the error instead of silently failing\n        logging.error(f\"get_memories() failed: {type(e).__name__}: {e}\", exc_info=True)\n        return []\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.SearchService.get_memory","title":"<code>get_memory(hrid, user_id, memory_type=None, collection=None)</code>","text":"<p>Get a single memory by HRID.</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>Human-readable identifier of the memory.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type hint (inferred from HRID if not provided).</p> <code>None</code> <code>collection</code> <code>str | None</code> <p>Optional Qdrant collection override.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>dict[str, Any] | None: Memory data with full payload, or None if not found.</p> Source code in <code>src/memg_core/core/pipelines/retrieval.py</code> <pre><code>def get_memory(\n    self,\n    hrid: str,\n    user_id: str,\n    memory_type: str | None = None,\n    collection: str | None = None,\n) -&gt; dict[str, Any] | None:\n    \"\"\"Get a single memory by HRID.\n\n    Args:\n        hrid: Human-readable identifier of the memory.\n        user_id: User ID for ownership verification.\n        memory_type: Optional memory type hint (inferred from HRID if not provided).\n        collection: Optional Qdrant collection override.\n\n    Returns:\n        dict[str, Any] | None: Memory data with full payload, or None if not found.\n    \"\"\"\n    try:\n        # Infer memory type from HRID if not provided\n        if memory_type is None:\n            memory_type = hrid.split(\"_\")[0].lower()\n\n        # Get UUID from HRID\n        uuid = self.hrid_tracker.get_uuid(hrid, user_id)\n        if not uuid:\n            return None\n\n        # Get memory data from Qdrant\n        point_data = self.qdrant.get_point(uuid, collection)\n        if not point_data:\n            return None\n\n        # Verify user ownership\n        payload = point_data.get(\"payload\", {})\n        if payload.get(\"user_id\") != user_id:\n            return None\n\n        # Build response with full memory information (HRID-only policy - no UUID exposure)\n        memory_data = {\n            \"hrid\": hrid,\n            \"memory_type\": payload.get(\"memory_type\", memory_type),\n            \"user_id\": user_id,\n            \"created_at\": payload.get(\"created_at\"),\n            \"updated_at\": payload.get(\"updated_at\"),\n            \"payload\": {\n                k: v\n                for k, v in payload.items()\n                if k\n                not in (\n                    \"id\",\n                    \"user_id\",\n                    \"memory_type\",\n                    \"created_at\",\n                    \"updated_at\",\n                    \"hrid\",\n                )\n            },\n        }\n\n        return memory_data\n\n    except (DatabaseError, ValueError, KeyError):\n        return None\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.SearchService.get_memory_neighbors","title":"<code>get_memory_neighbors(memory_id, memory_type, user_id, relation_types=None, direction='any', limit=10)</code>","text":"<p>Get related memories through graph relationships.</p> <p>Parameters:</p> Name Type Description Default <code>memory_id</code> <code>str</code> <p>Memory ID to find neighbors for</p> required <code>memory_type</code> <code>str</code> <p>Memory entity type</p> required <code>user_id</code> <code>str</code> <p>User ID for isolation</p> required <code>relation_types</code> <code>list[str] | None</code> <p>Filter by specific relationship types</p> <code>None</code> <code>direction</code> <code>str</code> <p>\"in\", \"out\", or \"any\"</p> <code>'any'</code> <code>limit</code> <code>int</code> <p>Maximum number of neighbors</p> <code>10</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of neighbor memories with relationship info</p> Source code in <code>src/memg_core/core/pipelines/retrieval.py</code> <pre><code>def get_memory_neighbors(\n    self,\n    memory_id: str,\n    memory_type: str,\n    user_id: str,\n    relation_types: list[str] | None = None,\n    direction: str = \"any\",\n    limit: int = 10,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Get related memories through graph relationships.\n\n    Args:\n        memory_id: Memory ID to find neighbors for\n        memory_type: Memory entity type\n        user_id: User ID for isolation\n        relation_types: Filter by specific relationship types\n        direction: \"in\", \"out\", or \"any\"\n        limit: Maximum number of neighbors\n\n    Returns:\n        List of neighbor memories with relationship info\n    \"\"\"\n    try:\n        return self.kuzu.neighbors(\n            node_label=memory_type,\n            node_uuid=memory_id,\n            user_id=user_id,\n            rel_types=relation_types,\n            direction=direction,\n            limit=limit,\n        )\n    except Exception as e:\n        raise ProcessingError(\n            \"Failed to get memory neighbors\",\n            operation=\"get_memory_neighbors\",\n            context={\"memory_id\": memory_id, \"memory_type\": memory_type},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.SearchService.search","title":"<code>search(query, user_id, limit=5, *, memory_type=None, relation_names=None, neighbor_limit=5, hops=1, include_details='self', modified_within_days=None, filters=None, projection=None, score_threshold=None, decay_rate=None, decay_threshold=None)</code>","text":"<p>GraphRAG search orchestration: vector seeds \u2192 graph expansion \u2192 result composition.</p> <p>Pure orchestration method that delegates to specialized handlers for clean separation of concerns.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Search query text (required).</p> required <code>user_id</code> <code>str</code> <p>User ID for filtering (required).</p> required <code>limit</code> <code>int</code> <p>Maximum results to return (default: 5).</p> <code>5</code> <code>memory_type</code> <code>str | None</code> <p>Optional memory type filter.</p> <code>None</code> <code>relation_names</code> <code>list[str] | None</code> <p>Specific relations to expand (None = all relations).</p> <code>None</code> <code>neighbor_limit</code> <code>int</code> <p>Max neighbors per seed (default: 5).</p> <code>5</code> <code>hops</code> <code>int</code> <p>Number of graph hops to expand (default: 1).</p> <code>1</code> <code>include_details</code> <code>str</code> <p>\"self\" (full payload) or \"none\" (anchor only) for seeds.</p> <code>'self'</code> <code>modified_within_days</code> <code>int | None</code> <p>Filter by recency (e.g., last 7 days).</p> <code>None</code> <code>filters</code> <code>dict[str, Any] | None</code> <p>Custom field-based filtering (e.g., {\"project\": \"memg-core\"}).</p> <code>None</code> <code>projection</code> <code>dict[str, list[str]] | None</code> <p>Control which fields to return per memory type.</p> <code>None</code> <code>score_threshold</code> <code>float | None</code> <p>Minimum similarity score threshold (0.0-1.0).</p> <code>None</code> <code>decay_rate</code> <code>float | None</code> <p>Score decay factor per hop (default: 1.0 = no decay).</p> <code>None</code> <code>decay_threshold</code> <code>float | None</code> <p>Explicit neighbor score threshold (overrides decay_rate).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SearchResult</code> <code>SearchResult</code> <p>Search result with explicit seed/neighbor separation.</p> Source code in <code>src/memg_core/core/pipelines/retrieval.py</code> <pre><code>def search(\n    self,\n    query: str,\n    user_id: str,\n    limit: int = 5,\n    *,\n    memory_type: str | None = None,\n    relation_names: list[str] | None = None,\n    neighbor_limit: int = 5,\n    hops: int = 1,\n    include_details: str = \"self\",\n    modified_within_days: int | None = None,\n    filters: dict[str, Any] | None = None,\n    projection: dict[str, list[str]] | None = None,\n    score_threshold: float | None = None,\n    decay_rate: float | None = None,\n    decay_threshold: float | None = None,\n) -&gt; SearchResult:\n    \"\"\"GraphRAG search orchestration: vector seeds \u2192 graph expansion \u2192 result composition.\n\n    Pure orchestration method that delegates to specialized handlers for clean separation of concerns.\n\n    Args:\n        query: Search query text (required).\n        user_id: User ID for filtering (required).\n        limit: Maximum results to return (default: 5).\n        memory_type: Optional memory type filter.\n        relation_names: Specific relations to expand (None = all relations).\n        neighbor_limit: Max neighbors per seed (default: 5).\n        hops: Number of graph hops to expand (default: 1).\n        include_details: \"self\" (full payload) or \"none\" (anchor only) for seeds.\n        modified_within_days: Filter by recency (e.g., last 7 days).\n        filters: Custom field-based filtering (e.g., {\"project\": \"memg-core\"}).\n        projection: Control which fields to return per memory type.\n        score_threshold: Minimum similarity score threshold (0.0-1.0).\n        decay_rate: Score decay factor per hop (default: 1.0 = no decay).\n        decay_threshold: Explicit neighbor score threshold (overrides decay_rate).\n\n    Returns:\n        SearchResult: Search result with explicit seed/neighbor separation.\n    \"\"\"\n    # 1. Get seeds from vector search using handler\n    seeds = self.vector_handler.search_seeds(\n        query=query,\n        user_id=user_id,\n        limit=limit,\n        memory_type=memory_type,\n        modified_within_days=modified_within_days,\n        filters=filters,\n        projection=projection,\n        score_threshold=score_threshold,\n        include_details=include_details,\n    )\n\n    if not seeds:\n        return SearchResult()\n\n    # 2. Graph expansion (neighbors with anchor-only payloads)\n    neighbors: list[MemoryNeighbor] = []\n    if hops &gt; 0:\n        # Calculate neighbor filtering threshold\n        neighbor_threshold = self._calculate_neighbor_threshold(\n            score_threshold, decay_rate, decay_threshold, hops\n        )\n\n        neighbors = self.graph_handler.expand_neighbors(\n            seeds=seeds,\n            user_id=user_id,\n            relation_names=relation_names,\n            neighbor_limit=neighbor_limit,\n            hops=hops,\n            projection=projection,\n            neighbor_threshold=neighbor_threshold,\n        )\n\n    # Compose final SearchResult with seeds and neighbors\n    return SearchResult(\n        memories=seeds,\n        neighbors=neighbors,\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator","title":"<code>YamlTranslator</code>","text":"<p>Translates YAML schema definitions to Pydantic models for strict validation.</p> <p>Attributes:</p> Name Type Description <code>yaml_path</code> <p>Path to YAML schema file.</p> <code>_schema</code> <code>dict[str, Any] | None</code> <p>Cached schema dictionary.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>class YamlTranslator:\n    \"\"\"Translates YAML schema definitions to Pydantic models for strict validation.\n\n    Attributes:\n        yaml_path: Path to YAML schema file.\n        _schema: Cached schema dictionary.\n    \"\"\"\n\n    def __init__(self, yaml_path: str | None = None) -&gt; None:\n        \"\"\"Initialize YamlTranslator with YAML schema path.\n\n        Args:\n            yaml_path: Path to YAML schema file. If None, uses MEMG_YAML_SCHEMA env var.\n\n        Raises:\n            YamlTranslatorError: If YAML path not provided or TypeRegistry initialization fails.\n        \"\"\"\n        # Require explicit YAML path - no silent defaults\n        if yaml_path:\n            self.yaml_path = yaml_path\n        else:\n            env_path = os.getenv(\"MEMG_YAML_SCHEMA\")\n            if not env_path:\n                raise YamlTranslatorError(\n                    \"YAML schema path required. Set MEMG_YAML_SCHEMA environment variable \"\n                    \"or provide yaml_path parameter. No defaults allowed.\"\n                )\n            self.yaml_path = env_path\n\n        self._schema: dict[str, Any] | None = None\n        # NO model cache - TypeRegistry handles all caching\n\n        # Initialize TypeRegistry from YAML - crash early if invalid\n        try:\n            initialize_types_from_yaml(self.yaml_path)\n        except Exception as e:\n            raise YamlTranslatorError(f\"Failed to initialize TypeRegistry from YAML: {e}\") from e\n\n    @property\n    def schema(self) -&gt; dict[str, Any]:\n        \"\"\"Get the loaded YAML schema, loading it if necessary.\"\"\"\n        if self._schema is not None:\n            return self._schema\n\n        # Load schema from the required path - no fallbacks\n        if not self.yaml_path:\n            raise YamlTranslatorError(\n                \"YAML schema path not set. This should not happen after __init__.\"\n            )\n\n        self._schema = self._load_schema()\n        return self._schema\n\n    def _load_schema(self) -&gt; dict[str, Any]:\n        \"\"\"Load schema from the current yaml_path.\"\"\"\n        if not self.yaml_path:\n            raise YamlTranslatorError(\"YAML path is None\")\n        path = Path(self.yaml_path)\n        if not path.exists():\n            raise YamlTranslatorError(f\"YAML schema not found at {path}\")\n        try:\n            with path.open(encoding=\"utf-8\") as f:\n                data = yaml.safe_load(f)\n            if not data:\n                raise YamlTranslatorError(\"Empty YAML schema\")\n            if not isinstance(data, dict):\n                raise YamlTranslatorError(\"YAML schema root must be a mapping\")\n            return data\n        except yaml.YAMLError as e:\n            raise YamlTranslatorError(f\"Invalid YAML syntax: {e}\") from e\n\n    def _entities_map(self) -&gt; dict[str, dict[str, Any]]:\n        sch = self.schema\n        ents = sch.get(\"entities\")\n        if not ents:\n            return {}\n        if isinstance(ents, dict):\n            # Normalize keys to lower\n            return {str(k).lower(): v for k, v in ents.items()}\n        # list form\n        out: dict[str, dict[str, Any]] = {}\n        for item in ents:\n            if not isinstance(item, dict):\n                continue\n            key = (item.get(\"name\") or item.get(\"type\") or \"\").lower()\n            if key:\n                out[key] = item\n        return out\n\n    def get_entity_types(self) -&gt; list[str]:\n        \"\"\"Get list of available entity types from YAML schema.\"\"\"\n        return list(self._entities_map().keys())\n\n    # ================== RELATIONSHIP PARSING (TARGET-FIRST FORMAT) ==================\n\n    def _get_relations_mapping_for_entity(\n        self, entity_name: str\n    ) -&gt; dict[str, list[dict[str, Any]]]:\n        \"\"\"Return raw relations mapping for an entity in target-first schema format.\n\n        The expected YAML shape under an entity is:\n            relations:\n              target_entity_name:\n                - name: ...\n                  description: ...\n                  predicate: PREDICATE_NAME\n                  directed: true|false\n\n        Returns an empty dict when no relations are defined.\n        \"\"\"\n        entity_spec = self._resolve_entity_with_inheritance(entity_name)\n        relations_section = entity_spec.get(\"relations\")\n        if not relations_section or not isinstance(relations_section, dict):\n            return {}\n\n        # Normalize keys to lower for targets; keep items as-is\n        normalized: dict[str, list[dict[str, Any]]] = {}\n        for target_name, items in relations_section.items():\n            if not isinstance(items, list):\n                # Skip invalid shapes silently at this layer; validation is higher-level\n                continue\n            normalized[str(target_name).lower()] = [i for i in items if isinstance(i, dict)]\n        return normalized\n\n    def get_relations_for_source(self, entity_name: str) -&gt; list[dict[str, Any]]:\n        \"\"\"Get normalized relation specs for a source entity in target-first schema.\n\n        Returns list of dicts with keys:\n            - source (str)\n            - target (str)\n            - name (str | None)\n            - description (str | None)\n            - predicate (str)\n            - directed (bool)\n        \"\"\"\n        if not entity_name:\n            raise YamlTranslatorError(\"Empty entity name\")\n\n        source_l = entity_name.lower()\n        relations_map = self._get_relations_mapping_for_entity(source_l)\n        if not relations_map:\n            return []\n\n        out: list[dict[str, Any]] = []\n        for target_l, items in relations_map.items():\n            for item in items:\n                predicate = item.get(\"predicate\")\n                if not predicate or not isinstance(predicate, str):\n                    # Skip invalid entries - strict behavior can be added later\n                    continue\n                directed = bool(item.get(\"directed\", True))\n                out.append(\n                    {\n                        \"source\": source_l,\n                        \"target\": target_l,\n                        \"name\": item.get(\"name\"),\n                        \"description\": item.get(\"description\"),\n                        \"predicate\": predicate.upper(),\n                        \"directed\": directed,\n                    }\n                )\n        return out\n\n    @staticmethod\n    def relationship_table_name(\n        source: str,\n        predicate: str,\n        target: str,\n        *,\n        directed: bool = True,  # noqa: unused-argument\n    ) -&gt; str:\n        \"\"\"Generate relationship table name.\n\n        For now, table name does not encode direction; direction affects creation/query semantics.\n        Canonicalization for undirected pairs can be added here later if decided.\n        \"\"\"\n        return f\"{str(source).upper()}_{str(predicate).upper()}_{str(target).upper()}\"\n\n    def get_labels_for_predicates(\n        self,\n        source_type: str,\n        predicates: list[str] | None,\n        neighbor_label: str | None = None,\n    ) -&gt; list[str]:\n        \"\"\"Expand predicate names to concrete relationship labels for a given source.\n\n        Args:\n            source_type: Source entity type name\n            predicates: List of predicate names to include (case-insensitive). If None, include all.\n            neighbor_label: Optional target entity type filter (case-insensitive)\n\n        Returns:\n            List of concrete relationship labels (table names) matching the filter.\n        \"\"\"\n        if not source_type:\n            raise YamlTranslatorError(\"Empty source_type\")\n\n        preds_u = set(p.upper() for p in predicates) if predicates else None\n        neighbor_l = neighbor_label.lower() if neighbor_label else None\n\n        labels: list[str] = []\n        for spec in self.get_relations_for_source(source_type):\n            if preds_u is not None and spec[\"predicate\"].upper() not in preds_u:\n                continue\n            if neighbor_l is not None and spec[\"target\"].lower() != neighbor_l:\n                continue\n            labels.append(\n                self.relationship_table_name(\n                    source=spec[\"source\"],\n                    predicate=spec[\"predicate\"],\n                    target=spec[\"target\"],\n                    directed=spec[\"directed\"],\n                )\n            )\n        return labels\n\n    def debug_relation_map(self) -&gt; dict[str, dict[str, list[dict[str, Any]]]]:\n        \"\"\"Return a nested relation map for debugging/printing.\n\n        Structure:\n        {\n          source: {\n            target: [ {name, predicate, directed, description} ... ]\n          }\n        }\n        \"\"\"\n        out: dict[str, dict[str, list[dict[str, Any]]]] = {}\n        for source in self.get_entity_types():\n            specs = self.get_relations_for_source(source)\n            if not specs:\n                continue\n            if source not in out:\n                out[source] = {}\n            for spec in specs:\n                target = spec[\"target\"]\n                out[source].setdefault(target, [])\n                out[source][target].append(\n                    {\n                        \"name\": spec.get(\"name\"),\n                        \"predicate\": spec.get(\"predicate\"),\n                        \"directed\": spec.get(\"directed\", True),\n                        \"description\": spec.get(\"description\"),\n                    }\n                )\n        return out\n\n    def get_anchor_field(self, entity_name: str) -&gt; str:\n        \"\"\"Get the anchor field name for the given entity type from YAML schema.\n\n        Now reads from vector.anchored_to instead of separate anchor field.\n\n        Args:\n            entity_name: Name of the entity type.\n\n        Returns:\n            str: Anchor field name.\n\n        Raises:\n            YamlTranslatorError: If anchor field not found.\n        \"\"\"\n        if not entity_name:\n            raise YamlTranslatorError(\"Empty entity name\")\n\n        # Get entity spec with inheritance resolution\n        entity_spec = self._resolve_entity_with_inheritance(entity_name)\n\n        # Look for vector field with anchored_to\n        fields = entity_spec.get(\"fields\", {})\n        for _field_name, field_def in fields.items():\n            if isinstance(field_def, dict) and field_def.get(\"type\") == \"vector\":\n                anchored_to = field_def.get(\"anchored_to\")\n                if anchored_to:\n                    return str(anchored_to)\n\n        raise YamlTranslatorError(\n            f\"Entity '{entity_name}' has no vector field with 'anchored_to' property\"\n        )\n\n    def _resolve_entity_with_inheritance(self, entity_name: str) -&gt; dict[str, Any]:\n        \"\"\"Resolve entity specification with full inheritance chain.\"\"\"\n        name_l = entity_name.lower()\n        emap = self._entities_map()\n        spec_raw = emap.get(name_l)\n        if not spec_raw:\n            raise YamlTranslatorError(f\"Entity '{entity_name}' not found in YAML schema\")\n\n        # If no parent, return as-is\n        parent_name = spec_raw.get(\"parent\")\n        if not parent_name:\n            return spec_raw\n\n        # Recursively resolve parent and merge fields\n        parent_spec = self._resolve_entity_with_inheritance(parent_name)\n\n        # Merge parent fields with child fields (child overrides parent)\n        merged_fields = parent_spec.get(\"fields\", {}).copy()\n        merged_fields.update(spec_raw.get(\"fields\", {}))\n\n        # Create merged spec\n        merged_spec = spec_raw.copy()\n        merged_spec[\"fields\"] = merged_fields\n\n        return merged_spec\n\n    def get_see_also_config(self, entity_name: str) -&gt; dict[str, Any] | None:\n        \"\"\"Get the see_also configuration for the given entity type from YAML schema.\n\n        Returns:\n            Dict with keys: enabled, threshold, limit, target_types\n            None if see_also is not configured for this entity\n        \"\"\"\n        if not entity_name:\n            raise YamlTranslatorError(\"Empty entity name\")\n        name_l = entity_name.lower()\n        emap = self._entities_map()\n        spec_raw = emap.get(name_l)\n        if not spec_raw:\n            raise YamlTranslatorError(f\"Entity '{entity_name}' not found in YAML schema\")\n\n        see_also = spec_raw.get(\"see_also\")\n        if not see_also or not isinstance(see_also, dict):\n            return None\n\n        # Validate required fields\n        if not see_also.get(\"enabled\", False):\n            return None\n\n        return {\n            \"enabled\": see_also.get(\"enabled\", False),\n            \"threshold\": float(see_also.get(\"threshold\", 0.7)),\n            \"limit\": int(see_also.get(\"limit\", 3)),\n            \"target_types\": list(see_also.get(\"target_types\", [])),\n        }\n\n    def build_anchor_text(self, memory) -&gt; str:\n        \"\"\"Build anchor text for embedding from YAML-defined anchor field.\n\n        NO hardcoded field names - reads anchor field from YAML schema.\n\n        Args:\n            memory: Memory object containing payload data.\n\n        Returns:\n            str: Anchor text for embedding.\n\n        Raises:\n            YamlTranslatorError: If anchor field is missing or invalid.\n        \"\"\"\n        mem_type = getattr(memory, \"memory_type\", None)\n        if not mem_type:\n            raise YamlTranslatorError(\n                \"Memory object missing 'memory_type' field\",\n                operation=\"build_anchor_text\",\n            )\n\n        # Get anchor field from YAML schema\n        anchor_field = self.get_anchor_field(mem_type)\n\n        # Try to get anchor text from the specified field\n        anchor_text = None\n\n        # First check if it's a core field on the Memory object\n        if hasattr(memory, anchor_field):\n            anchor_text = getattr(memory, anchor_field, None)\n        # Otherwise check in the payload\n        elif hasattr(memory, \"payload\") and isinstance(memory.payload, dict):\n            anchor_text = memory.payload.get(anchor_field)\n\n        if isinstance(anchor_text, str):\n            stripped_text = anchor_text.strip()\n            if stripped_text:\n                return stripped_text\n\n        # Anchor field missing, empty, or invalid\n        raise YamlTranslatorError(\n            f\"Anchor field '{anchor_field}' is missing, empty, or invalid \"\n            f\"for memory type '{mem_type}'\",\n            operation=\"build_anchor_text\",\n            context={\n                \"memory_type\": mem_type,\n                \"anchor_field\": anchor_field,\n                \"anchor_value\": anchor_text,\n            },\n        )\n\n    def _fields_contract(self, spec: dict[str, Any]) -&gt; tuple[list[str], list[str]]:\n        \"\"\"Extract required and optional fields from entity specification.\n\n        Supports either:\n        - fields: {required:[...], optional:[...]} format\n        - Individual field definitions with required flags\n\n        Args:\n            spec: Entity specification dictionary.\n\n        Returns:\n            tuple[list[str], list[str]]: (required_fields, optional_fields)\n        \"\"\"\n        # supports either fields: {required:[...], optional:[...]} OR flat dict\n        fields = spec.get(\"fields\") or {}\n        if \"required\" in fields or \"optional\" in fields:\n            req = [str(x) for x in fields.get(\"required\", [])]\n            opt = [str(x) for x in fields.get(\"optional\", [])]\n            return req, opt\n\n        # Resolve all fields including inherited ones\n        all_fields = self._resolve_inherited_fields(spec)\n\n        # Parse individual field definitions for required flag\n        required_fields = []\n        optional_fields = []\n\n        for field_name, field_def in all_fields.items():\n            if isinstance(field_def, dict) and field_def.get(\"required\", False):\n                # Skip system fields - they're handled by the system\n                if not field_def.get(\"system\", False):\n                    required_fields.append(field_name)\n                else:\n                    optional_fields.append(field_name)\n            else:\n                optional_fields.append(field_name)\n\n        return required_fields, optional_fields\n\n    def _resolve_inherited_fields(self, spec: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Resolve all fields including inherited ones from parent entities.\n\n        Args:\n            spec: Entity specification dictionary.\n\n        Returns:\n            dict[str, Any]: Dictionary containing all fields (inherited + current).\n        \"\"\"\n        all_fields = {}\n        entities_map = self._entities_map()\n\n        # If entity has a parent, resolve parent fields first\n        parent_name = spec.get(\"parent\")\n        if parent_name:\n            parent_spec = entities_map.get(parent_name.lower())\n            if parent_spec:\n                # Recursively resolve parent fields\n                parent_fields = self._resolve_inherited_fields(parent_spec)\n                all_fields.update(parent_fields)\n\n        # Add/override with current entity's fields\n        current_fields = spec.get(\"fields\") or {}\n        all_fields.update(current_fields)\n\n        return all_fields\n\n    def _get_system_fields(self, spec: dict[str, Any]) -&gt; set[str]:\n        \"\"\"Extract system fields from YAML schema (fields marked with system: true).\n\n        Args:\n            spec: Entity specification dictionary.\n\n        Returns:\n            set[str]: Set of field names that are marked as system fields.\n        \"\"\"\n        system_fields = set()\n        all_fields = self._resolve_inherited_fields(spec)\n\n        for field_name, field_def in all_fields.items():\n            if isinstance(field_def, dict) and field_def.get(\"system\", False):\n                system_fields.add(field_name)\n\n        return system_fields\n\n    def _validate_enum_fields(self, memory_type: str, payload: dict[str, Any]) -&gt; None:\n        \"\"\"Validate enum fields against YAML schema choices.\n\n        Args:\n            memory_type: Entity type from YAML schema.\n            payload: Memory data to validate.\n\n        Raises:\n            YamlTranslatorError: If enum field has invalid value.\n        \"\"\"\n        emap = self._entities_map()\n        spec = emap.get(memory_type.lower())\n        if not spec:\n            return  # Entity validation happens elsewhere\n\n        # Get field definitions for this entity type\n        fields = spec.get(\"fields\", {})\n\n        # Check each field in the payload\n        for field_name, field_value in payload.items():\n            if field_name in fields:\n                field_def = fields[field_name]\n\n                # Check if this is an enum field\n                if field_def.get(\"type\") == \"enum\":\n                    choices = field_def.get(\"choices\", [])\n\n                    # Validate the value against choices\n                    if field_value is not None and field_value not in choices:\n                        raise YamlTranslatorError(\n                            f\"Invalid {field_name} value '{field_value}'. Valid choices: {choices}\",\n                            context={\n                                \"memory_type\": memory_type,\n                                \"field_name\": field_name,\n                                \"invalid_value\": field_value,\n                                \"valid_choices\": choices,\n                            },\n                        )\n\n    def validate_memory_against_yaml(\n        self, memory_type: str, payload: dict[str, Any]\n    ) -&gt; dict[str, Any]:\n        \"\"\"Validate memory payload against YAML schema and return cleaned payload.\"\"\"\n        if not memory_type:\n            raise YamlTranslatorError(\"memory_type is required\")\n        if payload is None:\n            raise YamlTranslatorError(\"payload is required\")\n\n        # Strict validation - entity type MUST exist in YAML\n        emap = self._entities_map()\n        spec = emap.get(memory_type.lower())\n        if not spec:\n            raise YamlTranslatorError(\n                f\"Unknown entity type '{memory_type}'. All types must be defined in YAML schema.\",\n                context={\n                    \"memory_type\": memory_type,\n                    \"available_types\": list(emap.keys()),\n                },\n            )\n\n        req, _opt = self._fields_contract(spec)\n        missing = [k for k in req if not payload.get(k)]\n        if missing:\n            raise YamlTranslatorError(\n                f\"Missing required fields: {missing}\",\n                context={\"memory_type\": memory_type},\n            )\n\n        # Validate enum fields against YAML schema choices\n        self._validate_enum_fields(memory_type, payload)\n\n        # Validate that all fields are defined in YAML schema\n        req, opt = self._fields_contract(spec)\n        valid_fields = set(req + opt)\n        system_fields = self._get_system_fields(spec)\n        invalid_fields = set(payload.keys()) - valid_fields - system_fields\n        if invalid_fields:\n            raise YamlTranslatorError(\n                f\"Invalid fields not defined in schema: {sorted(invalid_fields)}\",\n                context={\n                    \"memory_type\": memory_type,\n                    \"valid_fields\": sorted(valid_fields),\n                    \"invalid_fields\": sorted(invalid_fields),\n                },\n            )\n\n        # Strip system-reserved fields if present\n        cleaned = dict(payload)\n        for syskey in system_fields:\n            cleaned.pop(syskey, None)\n        return cleaned\n\n    def create_memory_from_yaml(self, memory_type: str, payload: dict[str, Any], user_id: str):\n        \"\"\"Create a Memory object from YAML-validated payload.\"\"\"\n\n        # Get anchor field from YAML schema\n        anchor_field = self.get_anchor_field(memory_type)\n\n        # Extract anchor text from payload\n        anchor_text = payload.get(anchor_field)\n        if not anchor_text or not isinstance(anchor_text, str):\n            raise YamlTranslatorError(\n                f\"Missing or invalid anchor field '{anchor_field}' in payload \"\n                f\"for memory type '{memory_type}'\"\n            )\n\n        # Validate full payload against YAML schema\n        validated_payload = self.validate_memory_against_yaml(memory_type, payload)\n\n        # Construct Memory with YAML-defined payload only\n        return Memory(\n            memory_type=memory_type,\n            payload=validated_payload,\n            user_id=user_id,\n        )\n\n    def get_entity_model(self, entity_name: str):\n        \"\"\"Get Pydantic model from TypeRegistry - NO REDUNDANCY.\"\"\"\n        return get_entity_model(entity_name)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.schema","title":"<code>schema</code>  <code>property</code>","text":"<p>Get the loaded YAML schema, loading it if necessary.</p>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.__init__","title":"<code>__init__(yaml_path=None)</code>","text":"<p>Initialize YamlTranslator with YAML schema path.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_path</code> <code>str | None</code> <p>Path to YAML schema file. If None, uses MEMG_YAML_SCHEMA env var.</p> <code>None</code> <p>Raises:</p> Type Description <code>YamlTranslatorError</code> <p>If YAML path not provided or TypeRegistry initialization fails.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def __init__(self, yaml_path: str | None = None) -&gt; None:\n    \"\"\"Initialize YamlTranslator with YAML schema path.\n\n    Args:\n        yaml_path: Path to YAML schema file. If None, uses MEMG_YAML_SCHEMA env var.\n\n    Raises:\n        YamlTranslatorError: If YAML path not provided or TypeRegistry initialization fails.\n    \"\"\"\n    # Require explicit YAML path - no silent defaults\n    if yaml_path:\n        self.yaml_path = yaml_path\n    else:\n        env_path = os.getenv(\"MEMG_YAML_SCHEMA\")\n        if not env_path:\n            raise YamlTranslatorError(\n                \"YAML schema path required. Set MEMG_YAML_SCHEMA environment variable \"\n                \"or provide yaml_path parameter. No defaults allowed.\"\n            )\n        self.yaml_path = env_path\n\n    self._schema: dict[str, Any] | None = None\n    # NO model cache - TypeRegistry handles all caching\n\n    # Initialize TypeRegistry from YAML - crash early if invalid\n    try:\n        initialize_types_from_yaml(self.yaml_path)\n    except Exception as e:\n        raise YamlTranslatorError(f\"Failed to initialize TypeRegistry from YAML: {e}\") from e\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.build_anchor_text","title":"<code>build_anchor_text(memory)</code>","text":"<p>Build anchor text for embedding from YAML-defined anchor field.</p> <p>NO hardcoded field names - reads anchor field from YAML schema.</p> <p>Parameters:</p> Name Type Description Default <code>memory</code> <p>Memory object containing payload data.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Anchor text for embedding.</p> <p>Raises:</p> Type Description <code>YamlTranslatorError</code> <p>If anchor field is missing or invalid.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def build_anchor_text(self, memory) -&gt; str:\n    \"\"\"Build anchor text for embedding from YAML-defined anchor field.\n\n    NO hardcoded field names - reads anchor field from YAML schema.\n\n    Args:\n        memory: Memory object containing payload data.\n\n    Returns:\n        str: Anchor text for embedding.\n\n    Raises:\n        YamlTranslatorError: If anchor field is missing or invalid.\n    \"\"\"\n    mem_type = getattr(memory, \"memory_type\", None)\n    if not mem_type:\n        raise YamlTranslatorError(\n            \"Memory object missing 'memory_type' field\",\n            operation=\"build_anchor_text\",\n        )\n\n    # Get anchor field from YAML schema\n    anchor_field = self.get_anchor_field(mem_type)\n\n    # Try to get anchor text from the specified field\n    anchor_text = None\n\n    # First check if it's a core field on the Memory object\n    if hasattr(memory, anchor_field):\n        anchor_text = getattr(memory, anchor_field, None)\n    # Otherwise check in the payload\n    elif hasattr(memory, \"payload\") and isinstance(memory.payload, dict):\n        anchor_text = memory.payload.get(anchor_field)\n\n    if isinstance(anchor_text, str):\n        stripped_text = anchor_text.strip()\n        if stripped_text:\n            return stripped_text\n\n    # Anchor field missing, empty, or invalid\n    raise YamlTranslatorError(\n        f\"Anchor field '{anchor_field}' is missing, empty, or invalid \"\n        f\"for memory type '{mem_type}'\",\n        operation=\"build_anchor_text\",\n        context={\n            \"memory_type\": mem_type,\n            \"anchor_field\": anchor_field,\n            \"anchor_value\": anchor_text,\n        },\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.create_memory_from_yaml","title":"<code>create_memory_from_yaml(memory_type, payload, user_id)</code>","text":"<p>Create a Memory object from YAML-validated payload.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def create_memory_from_yaml(self, memory_type: str, payload: dict[str, Any], user_id: str):\n    \"\"\"Create a Memory object from YAML-validated payload.\"\"\"\n\n    # Get anchor field from YAML schema\n    anchor_field = self.get_anchor_field(memory_type)\n\n    # Extract anchor text from payload\n    anchor_text = payload.get(anchor_field)\n    if not anchor_text or not isinstance(anchor_text, str):\n        raise YamlTranslatorError(\n            f\"Missing or invalid anchor field '{anchor_field}' in payload \"\n            f\"for memory type '{memory_type}'\"\n        )\n\n    # Validate full payload against YAML schema\n    validated_payload = self.validate_memory_against_yaml(memory_type, payload)\n\n    # Construct Memory with YAML-defined payload only\n    return Memory(\n        memory_type=memory_type,\n        payload=validated_payload,\n        user_id=user_id,\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.debug_relation_map","title":"<code>debug_relation_map()</code>","text":"<p>Return a nested relation map for debugging/printing.</p> <p>Structure: {   source: {     target: [ {name, predicate, directed, description} ... ]   } }</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def debug_relation_map(self) -&gt; dict[str, dict[str, list[dict[str, Any]]]]:\n    \"\"\"Return a nested relation map for debugging/printing.\n\n    Structure:\n    {\n      source: {\n        target: [ {name, predicate, directed, description} ... ]\n      }\n    }\n    \"\"\"\n    out: dict[str, dict[str, list[dict[str, Any]]]] = {}\n    for source in self.get_entity_types():\n        specs = self.get_relations_for_source(source)\n        if not specs:\n            continue\n        if source not in out:\n            out[source] = {}\n        for spec in specs:\n            target = spec[\"target\"]\n            out[source].setdefault(target, [])\n            out[source][target].append(\n                {\n                    \"name\": spec.get(\"name\"),\n                    \"predicate\": spec.get(\"predicate\"),\n                    \"directed\": spec.get(\"directed\", True),\n                    \"description\": spec.get(\"description\"),\n                }\n            )\n    return out\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.get_anchor_field","title":"<code>get_anchor_field(entity_name)</code>","text":"<p>Get the anchor field name for the given entity type from YAML schema.</p> <p>Now reads from vector.anchored_to instead of separate anchor field.</p> <p>Parameters:</p> Name Type Description Default <code>entity_name</code> <code>str</code> <p>Name of the entity type.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Anchor field name.</p> <p>Raises:</p> Type Description <code>YamlTranslatorError</code> <p>If anchor field not found.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_anchor_field(self, entity_name: str) -&gt; str:\n    \"\"\"Get the anchor field name for the given entity type from YAML schema.\n\n    Now reads from vector.anchored_to instead of separate anchor field.\n\n    Args:\n        entity_name: Name of the entity type.\n\n    Returns:\n        str: Anchor field name.\n\n    Raises:\n        YamlTranslatorError: If anchor field not found.\n    \"\"\"\n    if not entity_name:\n        raise YamlTranslatorError(\"Empty entity name\")\n\n    # Get entity spec with inheritance resolution\n    entity_spec = self._resolve_entity_with_inheritance(entity_name)\n\n    # Look for vector field with anchored_to\n    fields = entity_spec.get(\"fields\", {})\n    for _field_name, field_def in fields.items():\n        if isinstance(field_def, dict) and field_def.get(\"type\") == \"vector\":\n            anchored_to = field_def.get(\"anchored_to\")\n            if anchored_to:\n                return str(anchored_to)\n\n    raise YamlTranslatorError(\n        f\"Entity '{entity_name}' has no vector field with 'anchored_to' property\"\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.get_entity_model","title":"<code>get_entity_model(entity_name)</code>","text":"<p>Get Pydantic model from TypeRegistry - NO REDUNDANCY.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_entity_model(self, entity_name: str):\n    \"\"\"Get Pydantic model from TypeRegistry - NO REDUNDANCY.\"\"\"\n    return get_entity_model(entity_name)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.get_entity_types","title":"<code>get_entity_types()</code>","text":"<p>Get list of available entity types from YAML schema.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_entity_types(self) -&gt; list[str]:\n    \"\"\"Get list of available entity types from YAML schema.\"\"\"\n    return list(self._entities_map().keys())\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.get_labels_for_predicates","title":"<code>get_labels_for_predicates(source_type, predicates, neighbor_label=None)</code>","text":"<p>Expand predicate names to concrete relationship labels for a given source.</p> <p>Parameters:</p> Name Type Description Default <code>source_type</code> <code>str</code> <p>Source entity type name</p> required <code>predicates</code> <code>list[str] | None</code> <p>List of predicate names to include (case-insensitive). If None, include all.</p> required <code>neighbor_label</code> <code>str | None</code> <p>Optional target entity type filter (case-insensitive)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of concrete relationship labels (table names) matching the filter.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_labels_for_predicates(\n    self,\n    source_type: str,\n    predicates: list[str] | None,\n    neighbor_label: str | None = None,\n) -&gt; list[str]:\n    \"\"\"Expand predicate names to concrete relationship labels for a given source.\n\n    Args:\n        source_type: Source entity type name\n        predicates: List of predicate names to include (case-insensitive). If None, include all.\n        neighbor_label: Optional target entity type filter (case-insensitive)\n\n    Returns:\n        List of concrete relationship labels (table names) matching the filter.\n    \"\"\"\n    if not source_type:\n        raise YamlTranslatorError(\"Empty source_type\")\n\n    preds_u = set(p.upper() for p in predicates) if predicates else None\n    neighbor_l = neighbor_label.lower() if neighbor_label else None\n\n    labels: list[str] = []\n    for spec in self.get_relations_for_source(source_type):\n        if preds_u is not None and spec[\"predicate\"].upper() not in preds_u:\n            continue\n        if neighbor_l is not None and spec[\"target\"].lower() != neighbor_l:\n            continue\n        labels.append(\n            self.relationship_table_name(\n                source=spec[\"source\"],\n                predicate=spec[\"predicate\"],\n                target=spec[\"target\"],\n                directed=spec[\"directed\"],\n            )\n        )\n    return labels\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.get_relations_for_source","title":"<code>get_relations_for_source(entity_name)</code>","text":"<p>Get normalized relation specs for a source entity in target-first schema.</p> Returns list of dicts with keys <ul> <li>source (str)</li> <li>target (str)</li> <li>name (str | None)</li> <li>description (str | None)</li> <li>predicate (str)</li> <li>directed (bool)</li> </ul> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_relations_for_source(self, entity_name: str) -&gt; list[dict[str, Any]]:\n    \"\"\"Get normalized relation specs for a source entity in target-first schema.\n\n    Returns list of dicts with keys:\n        - source (str)\n        - target (str)\n        - name (str | None)\n        - description (str | None)\n        - predicate (str)\n        - directed (bool)\n    \"\"\"\n    if not entity_name:\n        raise YamlTranslatorError(\"Empty entity name\")\n\n    source_l = entity_name.lower()\n    relations_map = self._get_relations_mapping_for_entity(source_l)\n    if not relations_map:\n        return []\n\n    out: list[dict[str, Any]] = []\n    for target_l, items in relations_map.items():\n        for item in items:\n            predicate = item.get(\"predicate\")\n            if not predicate or not isinstance(predicate, str):\n                # Skip invalid entries - strict behavior can be added later\n                continue\n            directed = bool(item.get(\"directed\", True))\n            out.append(\n                {\n                    \"source\": source_l,\n                    \"target\": target_l,\n                    \"name\": item.get(\"name\"),\n                    \"description\": item.get(\"description\"),\n                    \"predicate\": predicate.upper(),\n                    \"directed\": directed,\n                }\n            )\n    return out\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.get_see_also_config","title":"<code>get_see_also_config(entity_name)</code>","text":"<p>Get the see_also configuration for the given entity type from YAML schema.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dict with keys: enabled, threshold, limit, target_types</p> <code>dict[str, Any] | None</code> <p>None if see_also is not configured for this entity</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_see_also_config(self, entity_name: str) -&gt; dict[str, Any] | None:\n    \"\"\"Get the see_also configuration for the given entity type from YAML schema.\n\n    Returns:\n        Dict with keys: enabled, threshold, limit, target_types\n        None if see_also is not configured for this entity\n    \"\"\"\n    if not entity_name:\n        raise YamlTranslatorError(\"Empty entity name\")\n    name_l = entity_name.lower()\n    emap = self._entities_map()\n    spec_raw = emap.get(name_l)\n    if not spec_raw:\n        raise YamlTranslatorError(f\"Entity '{entity_name}' not found in YAML schema\")\n\n    see_also = spec_raw.get(\"see_also\")\n    if not see_also or not isinstance(see_also, dict):\n        return None\n\n    # Validate required fields\n    if not see_also.get(\"enabled\", False):\n        return None\n\n    return {\n        \"enabled\": see_also.get(\"enabled\", False),\n        \"threshold\": float(see_also.get(\"threshold\", 0.7)),\n        \"limit\": int(see_also.get(\"limit\", 3)),\n        \"target_types\": list(see_also.get(\"target_types\", [])),\n    }\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.relationship_table_name","title":"<code>relationship_table_name(source, predicate, target, *, directed=True)</code>  <code>staticmethod</code>","text":"<p>Generate relationship table name.</p> <p>For now, table name does not encode direction; direction affects creation/query semantics. Canonicalization for undirected pairs can be added here later if decided.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>@staticmethod\ndef relationship_table_name(\n    source: str,\n    predicate: str,\n    target: str,\n    *,\n    directed: bool = True,  # noqa: unused-argument\n) -&gt; str:\n    \"\"\"Generate relationship table name.\n\n    For now, table name does not encode direction; direction affects creation/query semantics.\n    Canonicalization for undirected pairs can be added here later if decided.\n    \"\"\"\n    return f\"{str(source).upper()}_{str(predicate).upper()}_{str(target).upper()}\"\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.YamlTranslator.validate_memory_against_yaml","title":"<code>validate_memory_against_yaml(memory_type, payload)</code>","text":"<p>Validate memory payload against YAML schema and return cleaned payload.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def validate_memory_against_yaml(\n    self, memory_type: str, payload: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Validate memory payload against YAML schema and return cleaned payload.\"\"\"\n    if not memory_type:\n        raise YamlTranslatorError(\"memory_type is required\")\n    if payload is None:\n        raise YamlTranslatorError(\"payload is required\")\n\n    # Strict validation - entity type MUST exist in YAML\n    emap = self._entities_map()\n    spec = emap.get(memory_type.lower())\n    if not spec:\n        raise YamlTranslatorError(\n            f\"Unknown entity type '{memory_type}'. All types must be defined in YAML schema.\",\n            context={\n                \"memory_type\": memory_type,\n                \"available_types\": list(emap.keys()),\n            },\n        )\n\n    req, _opt = self._fields_contract(spec)\n    missing = [k for k in req if not payload.get(k)]\n    if missing:\n        raise YamlTranslatorError(\n            f\"Missing required fields: {missing}\",\n            context={\"memory_type\": memory_type},\n        )\n\n    # Validate enum fields against YAML schema choices\n    self._validate_enum_fields(memory_type, payload)\n\n    # Validate that all fields are defined in YAML schema\n    req, opt = self._fields_contract(spec)\n    valid_fields = set(req + opt)\n    system_fields = self._get_system_fields(spec)\n    invalid_fields = set(payload.keys()) - valid_fields - system_fields\n    if invalid_fields:\n        raise YamlTranslatorError(\n            f\"Invalid fields not defined in schema: {sorted(invalid_fields)}\",\n            context={\n                \"memory_type\": memory_type,\n                \"valid_fields\": sorted(valid_fields),\n                \"invalid_fields\": sorted(invalid_fields),\n            },\n        )\n\n    # Strip system-reserved fields if present\n    cleaned = dict(payload)\n    for syskey in system_fields:\n        cleaned.pop(syskey, None)\n    return cleaned\n</code></pre>"},{"location":"reference/api/#memg_core.api.public._get_client","title":"<code>_get_client()</code>","text":"<p>Get or create singleton client from environment variables.</p> <p>Returns:</p> Name Type Description <code>MemgClient</code> <code>MemgClient</code> <p>Singleton client instance.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If required environment variables are not set.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def _get_client() -&gt; MemgClient:\n    \"\"\"Get or create singleton client from environment variables.\n\n    Returns:\n        MemgClient: Singleton client instance.\n\n    Raises:\n        RuntimeError: If required environment variables are not set.\n    \"\"\"\n    global _CLIENT\n    if _CLIENT is None:\n        yaml_path = os.environ.get(\"MEMG_YAML_PATH\")\n        db_path = os.environ.get(\"MEMG_DB_PATH\")\n\n        if not yaml_path or not db_path:\n            raise RuntimeError(\"MEMG_YAML_PATH and MEMG_DB_PATH environment variables must be set\")\n\n        _CLIENT = MemgClient(yaml_path, db_path)\n    return _CLIENT\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.add_memory","title":"<code>add_memory(memory_type, payload, user_id)</code>","text":"<p>Add memory using environment-based client.</p> <p>Parameters:</p> Name Type Description Default <code>memory_type</code> <code>str</code> <p>Entity type from YAML schema (e.g., 'task', 'note').</p> required <code>payload</code> <code>dict[str, Any]</code> <p>Memory data conforming to YAML schema.</p> required <code>user_id</code> <code>str</code> <p>Owner of the memory.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable ID (HRID) for the created memory.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def add_memory(memory_type: str, payload: dict[str, Any], user_id: str) -&gt; str:\n    \"\"\"Add memory using environment-based client.\n\n    Args:\n        memory_type: Entity type from YAML schema (e.g., 'task', 'note').\n        payload: Memory data conforming to YAML schema.\n        user_id: Owner of the memory.\n\n    Returns:\n        str: Human-readable ID (HRID) for the created memory.\n    \"\"\"\n    return _get_client().add_memory(memory_type, payload, user_id)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.add_relationship","title":"<code>add_relationship(from_memory_hrid, to_memory_hrid, relation_type, from_memory_type, to_memory_type, user_id, properties=None)</code>","text":"<p>Add relationship using environment-based client.</p> <p>Parameters:</p> Name Type Description Default <code>from_memory_hrid</code> <code>str</code> <p>Source memory HRID.</p> required <code>to_memory_hrid</code> <code>str</code> <p>Target memory HRID.</p> required <code>relation_type</code> <code>str</code> <p>Relationship type from YAML schema.</p> required <code>from_memory_type</code> <code>str</code> <p>Source memory entity type.</p> required <code>to_memory_type</code> <code>str</code> <p>Target memory entity type.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>properties</code> <code>dict[str, Any] | None</code> <p>Optional relationship properties.</p> <code>None</code> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def add_relationship(\n    from_memory_hrid: str,\n    to_memory_hrid: str,\n    relation_type: str,\n    from_memory_type: str,\n    to_memory_type: str,\n    user_id: str,\n    properties: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Add relationship using environment-based client.\n\n    Args:\n        from_memory_hrid: Source memory HRID.\n        to_memory_hrid: Target memory HRID.\n        relation_type: Relationship type from YAML schema.\n        from_memory_type: Source memory entity type.\n        to_memory_type: Target memory entity type.\n        user_id: User ID for ownership verification.\n        properties: Optional relationship properties.\n    \"\"\"\n    _get_client().add_relationship(\n        from_memory_hrid,\n        to_memory_hrid,\n        relation_type,\n        from_memory_type,\n        to_memory_type,\n        user_id,\n        properties,\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.create_memory_service","title":"<code>create_memory_service(db_clients)</code>","text":"<p>Factory function to create a MemoryService instance.</p> <p>Parameters:</p> Name Type Description Default <code>db_clients</code> <p>DatabaseClients instance (after init_dbs() called).</p> required <p>Returns:</p> Name Type Description <code>MemoryService</code> <code>MemoryService</code> <p>Configured MemoryService instance.</p> Source code in <code>src/memg_core/core/pipelines/indexer.py</code> <pre><code>def create_memory_service(db_clients) -&gt; MemoryService:\n    \"\"\"Factory function to create a MemoryService instance.\n\n    Args:\n        db_clients: DatabaseClients instance (after init_dbs() called).\n\n    Returns:\n        MemoryService: Configured MemoryService instance.\n    \"\"\"\n    return MemoryService(db_clients)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.create_search_service","title":"<code>create_search_service(db_clients)</code>","text":"<p>Factory function to create a SearchService instance.</p> <p>Parameters:</p> Name Type Description Default <code>db_clients</code> <p>DatabaseClients instance (after init_dbs() called).</p> required <p>Returns:</p> Name Type Description <code>SearchService</code> <code>SearchService</code> <p>Configured SearchService instance.</p> Source code in <code>src/memg_core/core/pipelines/retrieval.py</code> <pre><code>def create_search_service(db_clients) -&gt; SearchService:\n    \"\"\"Factory function to create a SearchService instance.\n\n    Args:\n        db_clients: DatabaseClients instance (after init_dbs() called).\n\n    Returns:\n        SearchService: Configured SearchService instance.\n    \"\"\"\n    return SearchService(db_clients)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.delete_memory","title":"<code>delete_memory(hrid, user_id, memory_type=None)</code>","text":"<p>Delete memory using environment-based client.</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>Human-readable ID of the memory to delete.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type hint.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if deletion succeeded, False otherwise.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def delete_memory(hrid: str, user_id: str, memory_type: str | None = None) -&gt; bool:\n    \"\"\"Delete memory using environment-based client.\n\n    Args:\n        hrid: Human-readable ID of the memory to delete.\n        user_id: User ID for ownership verification.\n        memory_type: Optional memory type hint.\n\n    Returns:\n        bool: True if deletion succeeded, False otherwise.\n    \"\"\"\n    return _get_client().delete_memory(hrid, user_id, memory_type)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.delete_relationship","title":"<code>delete_relationship(from_memory_hrid, to_memory_hrid, relation_type, from_memory_type=None, to_memory_type=None, user_id=None)</code>","text":"<p>Delete relationship using environment-based client.</p> <p>Parameters:</p> Name Type Description Default <code>from_memory_hrid</code> <code>str</code> <p>Source memory HRID.</p> required <code>to_memory_hrid</code> <code>str</code> <p>Target memory HRID.</p> required <code>relation_type</code> <code>str</code> <p>Relationship type from YAML schema.</p> required <code>from_memory_type</code> <code>str | None</code> <p>Source memory entity type (inferred from HRID if not provided).</p> <code>None</code> <code>to_memory_type</code> <code>str | None</code> <p>Target memory entity type (inferred from HRID if not provided).</p> <code>None</code> <code>user_id</code> <code>str | None</code> <p>User ID for ownership verification (required).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if deletion succeeded, False if relationship not found.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def delete_relationship(\n    from_memory_hrid: str,\n    to_memory_hrid: str,\n    relation_type: str,\n    from_memory_type: str | None = None,\n    to_memory_type: str | None = None,\n    user_id: str | None = None,\n) -&gt; bool:\n    \"\"\"Delete relationship using environment-based client.\n\n    Args:\n        from_memory_hrid: Source memory HRID.\n        to_memory_hrid: Target memory HRID.\n        relation_type: Relationship type from YAML schema.\n        from_memory_type: Source memory entity type (inferred from HRID if not provided).\n        to_memory_type: Target memory entity type (inferred from HRID if not provided).\n        user_id: User ID for ownership verification (required).\n\n    Returns:\n        bool: True if deletion succeeded, False if relationship not found.\n    \"\"\"\n    return _get_client().delete_relationship(\n        from_memory_hrid,\n        to_memory_hrid,\n        relation_type,\n        from_memory_type,\n        to_memory_type,\n        user_id,\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.get_memories","title":"<code>get_memories(user_id, memory_type=None, filters=None, limit=50, offset=0, include_neighbors=False, hops=1)</code>","text":"<p>Get memories using environment-based client.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type filter (e.g., \"task\", \"note\").</p> <code>None</code> <code>filters</code> <code>dict[str, Any] | None</code> <p>Optional field filters (e.g., {\"status\": \"open\", \"priority\": \"high\"}).</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of memories to return (default 50).</p> <code>50</code> <code>offset</code> <code>int</code> <p>Number of memories to skip for pagination (default 0).</p> <code>0</code> <code>include_neighbors</code> <code>bool</code> <p>Whether to include neighbor nodes via graph traversal.</p> <code>False</code> <code>hops</code> <code>int</code> <p>Number of hops for neighbor expansion (default 1).</p> <code>1</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: List of memory data with full payloads.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def get_memories(\n    user_id: str,\n    memory_type: str | None = None,\n    filters: dict[str, Any] | None = None,\n    limit: int = 50,\n    offset: int = 0,\n    include_neighbors: bool = False,\n    hops: int = 1,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Get memories using environment-based client.\n\n    Args:\n        user_id: User ID for ownership verification.\n        memory_type: Optional memory type filter (e.g., \"task\", \"note\").\n        filters: Optional field filters (e.g., {\"status\": \"open\", \"priority\": \"high\"}).\n        limit: Maximum number of memories to return (default 50).\n        offset: Number of memories to skip for pagination (default 0).\n        include_neighbors: Whether to include neighbor nodes via graph traversal.\n        hops: Number of hops for neighbor expansion (default 1).\n\n    Returns:\n        list[dict[str, Any]]: List of memory data with full payloads.\n    \"\"\"\n    return _get_client().get_memories(\n        user_id, memory_type, filters, limit, offset, include_neighbors, hops\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.get_memory","title":"<code>get_memory(hrid, user_id, memory_type=None)</code>","text":"<p>Get memory using environment-based client.</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>Human-readable identifier of the memory.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type hint (inferred from HRID if not provided).</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>dict[str, Any] | None: Memory data with full payload, or None if not found.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def get_memory(\n    hrid: str,\n    user_id: str,\n    memory_type: str | None = None,\n) -&gt; dict[str, Any] | None:\n    \"\"\"Get memory using environment-based client.\n\n    Args:\n        hrid: Human-readable identifier of the memory.\n        user_id: User ID for ownership verification.\n        memory_type: Optional memory type hint (inferred from HRID if not provided).\n\n    Returns:\n        dict[str, Any] | None: Memory data with full payload, or None if not found.\n    \"\"\"\n    return _get_client().get_memory(hrid, user_id, memory_type)\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.get_services","title":"<code>get_services()</code>","text":"<p>Get services from singleton client (MCP server compatibility).</p> <p>Returns:</p> Type Description <code>tuple[MemoryService, SearchService, YamlTranslator]</code> <p>tuple[MemoryService, SearchService, YamlTranslator]: Service instances for direct access.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def get_services() -&gt; tuple[MemoryService, SearchService, YamlTranslator]:\n    \"\"\"Get services from singleton client (MCP server compatibility).\n\n    Returns:\n        tuple[MemoryService, SearchService, YamlTranslator]: Service instances for direct access.\n    \"\"\"\n    client = _get_client()\n    yaml_translator = YamlTranslator(os.environ.get(\"MEMG_YAML_PATH\"))\n    return client._memory_service, client._search_service, yaml_translator\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.search","title":"<code>search(query, user_id, memory_type=None, limit=10, score_threshold=None, decay_rate=None, decay_threshold=None, **kwargs)</code>","text":"<p>Search memories using environment-based client.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Text to search for.</p> required <code>user_id</code> <code>str</code> <p>User ID for filtering results.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type filter.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of results to return.</p> <code>10</code> <code>score_threshold</code> <code>float | None</code> <p>Minimum similarity score threshold (0.0-1.0).</p> <code>None</code> <code>decay_rate</code> <code>float | None</code> <p>Score decay factor per hop (default: 1.0 = no decay).</p> <code>None</code> <code>decay_threshold</code> <code>float | None</code> <p>Explicit neighbor score threshold (overrides decay_rate).</p> <code>None</code> <code>**kwargs</code> <p>Additional search parameters.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>SearchResult</code> <code>SearchResult</code> <p>Search result with explicit seed/neighbor separation, including full payloads for seeds and relationships.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def search(\n    query: str,\n    user_id: str,\n    memory_type: str | None = None,\n    limit: int = 10,\n    score_threshold: float | None = None,\n    decay_rate: float | None = None,\n    decay_threshold: float | None = None,\n    **kwargs,\n) -&gt; SearchResult:\n    \"\"\"Search memories using environment-based client.\n\n    Args:\n        query: Text to search for.\n        user_id: User ID for filtering results.\n        memory_type: Optional memory type filter.\n        limit: Maximum number of results to return.\n        score_threshold: Minimum similarity score threshold (0.0-1.0).\n        decay_rate: Score decay factor per hop (default: 1.0 = no decay).\n        decay_threshold: Explicit neighbor score threshold (overrides decay_rate).\n        **kwargs: Additional search parameters.\n\n    Returns:\n        SearchResult: Search result with explicit seed/neighbor separation,\n            including full payloads for seeds and relationships.\n    \"\"\"\n    return _get_client().search(\n        query,\n        user_id,\n        memory_type,\n        limit,\n        score_threshold=score_threshold,\n        decay_rate=decay_rate,\n        decay_threshold=decay_threshold,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.shutdown_services","title":"<code>shutdown_services()</code>","text":"<p>Shutdown singleton client.</p> <p>Closes database connections and cleans up resources.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def shutdown_services():\n    \"\"\"Shutdown singleton client.\n\n    Closes database connections and cleans up resources.\n    \"\"\"\n    global _CLIENT\n    if _CLIENT:\n        _CLIENT.close()\n        _CLIENT = None\n</code></pre>"},{"location":"reference/api/#memg_core.api.public.update_memory","title":"<code>update_memory(hrid, payload_updates, user_id, memory_type=None)</code>","text":"<p>Update memory using environment-based client.</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>Memory HRID to update.</p> required <code>payload_updates</code> <code>dict[str, Any]</code> <p>Dictionary of fields to update (only changed fields).</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>memory_type</code> <code>str | None</code> <p>Optional memory type hint (inferred from HRID if not provided).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if update succeeded, False otherwise.</p> Source code in <code>src/memg_core/api/public.py</code> <pre><code>def update_memory(\n    hrid: str,\n    payload_updates: dict[str, Any],\n    user_id: str,\n    memory_type: str | None = None,\n) -&gt; bool:\n    \"\"\"Update memory using environment-based client.\n\n    Args:\n        hrid: Memory HRID to update.\n        payload_updates: Dictionary of fields to update (only changed fields).\n        user_id: User ID for ownership verification.\n        memory_type: Optional memory type hint (inferred from HRID if not provided).\n\n    Returns:\n        bool: True if update succeeded, False otherwise.\n    \"\"\"\n    return _get_client().update_memory(hrid, payload_updates, user_id, memory_type)\n</code></pre>"},{"location":"reference/api/#core-models","title":"Core Models","text":"<p>Core data models and types:</p> <p>Core models for the memory system.</p>"},{"location":"reference/api/#memg_core.core.models._MAX_SCORE_TOLERANCE","title":"<code>_MAX_SCORE_TOLERANCE = 1.001</code>  <code>module-attribute</code>","text":""},{"location":"reference/api/#memg_core.core.models.Memory","title":"<code>Memory</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Core memory model with YAML-driven payload validation.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier (UUID or HRID).</p> <code>user_id</code> <code>str</code> <p>Owner of the memory.</p> <code>memory_type</code> <code>str</code> <p>Entity type from YAML schema.</p> <code>payload</code> <code>dict[str, Any]</code> <p>Entity-specific fields.</p> <code>vector</code> <code>list[float] | None</code> <p>Embedding vector.</p> <code>created_at</code> <code>datetime</code> <p>Creation timestamp.</p> <code>updated_at</code> <code>datetime | None</code> <p>Last update timestamp.</p> <code>hrid</code> <code>str | None</code> <p>Human-readable identifier.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>class Memory(BaseModel):\n    \"\"\"Core memory model with YAML-driven payload validation.\n\n    Attributes:\n        id: Unique identifier (UUID or HRID).\n        user_id: Owner of the memory.\n        memory_type: Entity type from YAML schema.\n        payload: Entity-specific fields.\n        vector: Embedding vector.\n        created_at: Creation timestamp.\n        updated_at: Last update timestamp.\n        hrid: Human-readable identifier.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    # Core fields only - NO hardcoded entity-specific fields\n    # NO DEFAULTS - crash early if required fields missing\n    id: str = Field(default_factory=lambda: str(uuid4()))  # System-generated ID only\n    user_id: str  # REQUIRED - no default\n    memory_type: str  # REQUIRED - no default, must come from YAML\n    payload: dict[str, Any] = Field(default_factory=dict)  # Entity fields container\n    vector: list[float] | None = None  # System-generated vector\n    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))  # System timestamp\n    updated_at: datetime | None = None\n\n    # Human-readable id (e.g., MEMO_AAA001)\n    hrid: str | None = None\n\n    @field_validator(\"memory_type\")\n    @classmethod\n    def memory_type_not_empty(cls, v: str) -&gt; str:\n        \"\"\"Validate that memory_type is not empty.\n\n        Args:\n            v: Memory type value.\n\n        Returns:\n            str: Stripped memory type.\n\n        Raises:\n            ValueError: If memory_type is empty or whitespace.\n        \"\"\"\n        if not v or not v.strip():\n            raise ValueError(\"memory_type cannot be empty\")\n        return v.strip()\n\n    # (properties removed \u2013 dynamic __getattr__ handles field access)\n\n    def __getattr__(self, item: str):\n        \"\"\"Dynamic attribute access for YAML-defined payload fields ONLY.\n\n        No fallback logic, no backward compatibility. If the field is not\n        in the payload dictionary, raises AttributeError immediately.\n        This enforces strict YAML schema compliance.\n\n        Args:\n            item: Field name to access.\n\n        Returns:\n            Any: Field value from payload.\n\n        Raises:\n            AttributeError: If field is not in payload.\n        \"\"\"\n        payload = self.__dict__.get(\"payload\")\n        if isinstance(payload, dict) and item in payload:\n            return payload[item]\n        raise AttributeError(f\"'{type(self).__name__}' object has no attribute '{item}'\")\n\n    # ---------------------------------------------------------------------\n    # YAML \u2192 Dynamic entity model projection helpers\n    # ---------------------------------------------------------------------\n    def to_entity_model(self):\n        \"\"\"Project this Memory into a dynamic Pydantic entity model.\n\n        Returns an instance of the auto-generated model class that matches\n        the entity type defined in the YAML schema. Only non-system fields\n        are included.\n\n        Returns:\n            BaseModel: Dynamic Pydantic model instance.\n        \"\"\"\n        model_cls = get_entity_model(self.memory_type)\n        # Pass only fields that the model expects\n        model_fields = {\n            k: v for k, v in (self.payload or {}).items() if k in model_cls.model_fields\n        }\n        return model_cls(**model_fields)\n</code></pre>"},{"location":"reference/api/#memg_core.core.models.Memory.__getattr__","title":"<code>__getattr__(item)</code>","text":"<p>Dynamic attribute access for YAML-defined payload fields ONLY.</p> <p>No fallback logic, no backward compatibility. If the field is not in the payload dictionary, raises AttributeError immediately. This enforces strict YAML schema compliance.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>Field name to access.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>Field value from payload.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If field is not in payload.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>def __getattr__(self, item: str):\n    \"\"\"Dynamic attribute access for YAML-defined payload fields ONLY.\n\n    No fallback logic, no backward compatibility. If the field is not\n    in the payload dictionary, raises AttributeError immediately.\n    This enforces strict YAML schema compliance.\n\n    Args:\n        item: Field name to access.\n\n    Returns:\n        Any: Field value from payload.\n\n    Raises:\n        AttributeError: If field is not in payload.\n    \"\"\"\n    payload = self.__dict__.get(\"payload\")\n    if isinstance(payload, dict) and item in payload:\n        return payload[item]\n    raise AttributeError(f\"'{type(self).__name__}' object has no attribute '{item}'\")\n</code></pre>"},{"location":"reference/api/#memg_core.core.models.Memory.memory_type_not_empty","title":"<code>memory_type_not_empty(v)</code>  <code>classmethod</code>","text":"<p>Validate that memory_type is not empty.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>Memory type value.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Stripped memory type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If memory_type is empty or whitespace.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>@field_validator(\"memory_type\")\n@classmethod\ndef memory_type_not_empty(cls, v: str) -&gt; str:\n    \"\"\"Validate that memory_type is not empty.\n\n    Args:\n        v: Memory type value.\n\n    Returns:\n        str: Stripped memory type.\n\n    Raises:\n        ValueError: If memory_type is empty or whitespace.\n    \"\"\"\n    if not v or not v.strip():\n        raise ValueError(\"memory_type cannot be empty\")\n    return v.strip()\n</code></pre>"},{"location":"reference/api/#memg_core.core.models.Memory.to_entity_model","title":"<code>to_entity_model()</code>","text":"<p>Project this Memory into a dynamic Pydantic entity model.</p> <p>Returns an instance of the auto-generated model class that matches the entity type defined in the YAML schema. Only non-system fields are included.</p> <p>Returns:</p> Name Type Description <code>BaseModel</code> <p>Dynamic Pydantic model instance.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>def to_entity_model(self):\n    \"\"\"Project this Memory into a dynamic Pydantic entity model.\n\n    Returns an instance of the auto-generated model class that matches\n    the entity type defined in the YAML schema. Only non-system fields\n    are included.\n\n    Returns:\n        BaseModel: Dynamic Pydantic model instance.\n    \"\"\"\n    model_cls = get_entity_model(self.memory_type)\n    # Pass only fields that the model expects\n    model_fields = {\n        k: v for k, v in (self.payload or {}).items() if k in model_cls.model_fields\n    }\n    return model_cls(**model_fields)\n</code></pre>"},{"location":"reference/api/#memg_core.core.models.MemoryNeighbor","title":"<code>MemoryNeighbor</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Memory neighbor with anchor-only payload.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>str</code> <p>Owner of the memory.</p> <code>hrid</code> <code>str</code> <p>Human-readable identifier.</p> <code>memory_type</code> <code>str</code> <p>Entity type from YAML schema.</p> <code>created_at</code> <code>datetime</code> <p>Creation timestamp.</p> <code>updated_at</code> <code>datetime | None</code> <p>Last update timestamp.</p> <code>payload</code> <code>dict[str, Any]</code> <p>Anchor-only payload (statement field only).</p> <code>score</code> <code>float</code> <p>Recursive relevance score (seed_score \u00d7 neighbor_similarity).</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>class MemoryNeighbor(BaseModel):\n    \"\"\"Memory neighbor with anchor-only payload.\n\n    Attributes:\n        user_id: Owner of the memory.\n        hrid: Human-readable identifier.\n        memory_type: Entity type from YAML schema.\n        created_at: Creation timestamp.\n        updated_at: Last update timestamp.\n        payload: Anchor-only payload (statement field only).\n        score: Recursive relevance score (seed_score \u00d7 neighbor_similarity).\n    \"\"\"\n\n    user_id: str = Field(..., description=\"Owner of the memory\")\n    hrid: str = Field(..., description=\"Human-readable identifier\")\n    memory_type: str = Field(..., description=\"Entity type from YAML schema\")\n    created_at: datetime = Field(..., description=\"Creation timestamp\")\n    updated_at: datetime | None = Field(None, description=\"Last update timestamp\")\n    payload: dict[str, Any] = Field(..., description=\"Anchor-only payload\")\n    score: float = Field(..., ge=0.0, le=1.0, description=\"Recursive relevance score\")\n</code></pre>"},{"location":"reference/api/#memg_core.core.models.MemoryPoint","title":"<code>MemoryPoint</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Memory with embedding vector for Qdrant.</p> <p>Attributes:</p> Name Type Description <code>memory</code> <code>Memory</code> <p>Memory instance.</p> <code>vector</code> <code>list[float]</code> <p>Embedding vector.</p> <code>point_id</code> <code>str | None</code> <p>Qdrant point ID.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>class MemoryPoint(BaseModel):\n    \"\"\"Memory with embedding vector for Qdrant.\n\n    Attributes:\n        memory: Memory instance.\n        vector: Embedding vector.\n        point_id: Qdrant point ID.\n    \"\"\"\n\n    memory: Memory\n    vector: list[float] = Field(..., description=\"Embedding vector\")\n    point_id: str | None = Field(None, description=\"Qdrant point ID\")\n\n    @field_validator(\"vector\")\n    @classmethod\n    def vector_not_empty(cls, v):\n        \"\"\"Validate that vector is not empty.\n\n        Args:\n            v: Vector to validate.\n\n        Returns:\n            list[float]: Validated vector.\n\n        Raises:\n            ValueError: If vector is empty.\n        \"\"\"\n        if not v:\n            raise ValueError(\"Vector cannot be empty\")\n        return v\n</code></pre>"},{"location":"reference/api/#memg_core.core.models.MemoryPoint.vector_not_empty","title":"<code>vector_not_empty(v)</code>  <code>classmethod</code>","text":"<p>Validate that vector is not empty.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <p>Vector to validate.</p> required <p>Returns:</p> Type Description <p>list[float]: Validated vector.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If vector is empty.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>@field_validator(\"vector\")\n@classmethod\ndef vector_not_empty(cls, v):\n    \"\"\"Validate that vector is not empty.\n\n    Args:\n        v: Vector to validate.\n\n    Returns:\n        list[float]: Validated vector.\n\n    Raises:\n        ValueError: If vector is empty.\n    \"\"\"\n    if not v:\n        raise ValueError(\"Vector cannot be empty\")\n    return v\n</code></pre>"},{"location":"reference/api/#memg_core.core.models.MemorySeed","title":"<code>MemorySeed</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Memory seed with full payload and explicit relationships.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <code>str</code> <p>Owner of the memory.</p> <code>hrid</code> <code>str</code> <p>Human-readable identifier.</p> <code>memory_type</code> <code>str</code> <p>Entity type from YAML schema.</p> <code>created_at</code> <code>datetime</code> <p>Creation timestamp.</p> <code>updated_at</code> <code>datetime | None</code> <p>Last update timestamp.</p> <code>payload</code> <code>dict[str, Any]</code> <p>Full entity payload.</p> <code>score</code> <code>float</code> <p>Vector similarity score to query.</p> <code>relationships</code> <code>list[RelationshipInfo]</code> <p>List of relationships to other memories.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>class MemorySeed(BaseModel):\n    \"\"\"Memory seed with full payload and explicit relationships.\n\n    Attributes:\n        user_id: Owner of the memory.\n        hrid: Human-readable identifier.\n        memory_type: Entity type from YAML schema.\n        created_at: Creation timestamp.\n        updated_at: Last update timestamp.\n        payload: Full entity payload.\n        score: Vector similarity score to query.\n        relationships: List of relationships to other memories.\n    \"\"\"\n\n    user_id: str = Field(..., description=\"Owner of the memory\")\n    hrid: str = Field(..., description=\"Human-readable identifier\")\n    memory_type: str = Field(..., description=\"Entity type from YAML schema\")\n    created_at: datetime = Field(..., description=\"Creation timestamp\")\n    updated_at: datetime | None = Field(None, description=\"Last update timestamp\")\n    payload: dict[str, Any] = Field(..., description=\"Full entity payload\")\n    score: float = Field(\n        ..., ge=0.0, le=1.0 + _MAX_SCORE_TOLERANCE, description=\"Vector similarity score\"\n    )\n    relationships: list[RelationshipInfo] = Field(\n        default_factory=list, description=\"Relationships to other memories\"\n    )\n\n    @field_validator(\"score\")\n    @classmethod\n    def normalize_score(cls, v: float) -&gt; float:\n        \"\"\"Normalize similarity scores to handle floating-point precision errors.\"\"\"\n        if v &lt; 0.0:\n            raise ValueError(f\"Similarity score cannot be negative: {v}\")\n        if v &gt; 1.001:\n            raise ValueError(f\"Similarity score too high (indicates calculation error): {v}\")\n        return min(v, 1.0)\n</code></pre>"},{"location":"reference/api/#memg_core.core.models.MemorySeed.normalize_score","title":"<code>normalize_score(v)</code>  <code>classmethod</code>","text":"<p>Normalize similarity scores to handle floating-point precision errors.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>@field_validator(\"score\")\n@classmethod\ndef normalize_score(cls, v: float) -&gt; float:\n    \"\"\"Normalize similarity scores to handle floating-point precision errors.\"\"\"\n    if v &lt; 0.0:\n        raise ValueError(f\"Similarity score cannot be negative: {v}\")\n    if v &gt; 1.001:\n        raise ValueError(f\"Similarity score too high (indicates calculation error): {v}\")\n    return min(v, 1.0)\n</code></pre>"},{"location":"reference/api/#memg_core.core.models.ProcessingResult","title":"<code>ProcessingResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Result from memory processing pipelines - type-agnostic.</p> <p>Attributes:</p> Name Type Description <code>success</code> <code>bool</code> <p>Whether processing succeeded.</p> <code>memories_created</code> <code>list[Memory]</code> <p>List of created memories.</p> <code>errors</code> <code>list[str]</code> <p>List of error messages.</p> <code>processing_time_ms</code> <code>float | None</code> <p>Processing time in milliseconds.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>class ProcessingResult(BaseModel):\n    \"\"\"Result from memory processing pipelines - type-agnostic.\n\n    Attributes:\n        success: Whether processing succeeded.\n        memories_created: List of created memories.\n        errors: List of error messages.\n        processing_time_ms: Processing time in milliseconds.\n    \"\"\"\n\n    success: bool\n    memories_created: list[Memory] = Field(default_factory=list)\n    errors: list[str] = Field(default_factory=list)\n    processing_time_ms: float | None = Field(None)\n\n    @property\n    def total_created(self) -&gt; int:\n        \"\"\"Total memories created (all types).\n\n        Returns:\n            int: Number of memories created.\n        \"\"\"\n        return len(self.memories_created)\n</code></pre>"},{"location":"reference/api/#memg_core.core.models.ProcessingResult.total_created","title":"<code>total_created</code>  <code>property</code>","text":"<p>Total memories created (all types).</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of memories created.</p>"},{"location":"reference/api/#memg_core.core.models.RelationshipInfo","title":"<code>RelationshipInfo</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Relationship information between memories.</p> <p>Attributes:</p> Name Type Description <code>relation_type</code> <code>str</code> <p>Type of relationship (e.g., FIXES, ADDRESSES).</p> <code>target_hrid</code> <code>str</code> <p>HRID of the target memory.</p> <code>score</code> <code>float</code> <p>Relationship relevance score with natural decay.</p> <code>relationships</code> <code>list[RelationshipInfo]</code> <p>Nested relationships for multi-hop expansion.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>class RelationshipInfo(BaseModel):\n    \"\"\"Relationship information between memories.\n\n    Attributes:\n        relation_type: Type of relationship (e.g., FIXES, ADDRESSES).\n        target_hrid: HRID of the target memory.\n        score: Relationship relevance score with natural decay.\n        relationships: Nested relationships for multi-hop expansion.\n    \"\"\"\n\n    relation_type: str = Field(..., description=\"Relationship type from YAML schema\")\n    target_hrid: str = Field(..., description=\"HRID of target memory\")\n    score: float = Field(..., ge=0.0, le=1.0, description=\"Relationship relevance score\")\n    relationships: list[RelationshipInfo] = Field(\n        default_factory=list, description=\"Nested relationships\"\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.core.models.SearchResult","title":"<code>SearchResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Search result with explicit seed/neighbor separation.</p> <p>Attributes:</p> Name Type Description <code>memories</code> <code>list[MemorySeed]</code> <p>List of memory seeds with full payloads and relationships.</p> <code>neighbors</code> <code>list[MemoryNeighbor]</code> <p>List of memory neighbors with anchor-only payloads.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>class SearchResult(BaseModel):\n    \"\"\"Search result with explicit seed/neighbor separation.\n\n    Attributes:\n        memories: List of memory seeds with full payloads and relationships.\n        neighbors: List of memory neighbors with anchor-only payloads.\n    \"\"\"\n\n    memories: list[MemorySeed] = Field(\n        default_factory=list, description=\"Memory seeds with full payloads\"\n    )\n    neighbors: list[MemoryNeighbor] = Field(\n        default_factory=list, description=\"Memory neighbors with anchor payloads\"\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.core.models.get_entity_model","title":"<code>get_entity_model(entity_name)</code>","text":"<p>Get Pydantic model for entity from global registry.</p> <p>Parameters:</p> Name Type Description Default <code>entity_name</code> <code>str</code> <p>Name of the entity.</p> required <p>Returns:</p> Type Description <code>type[BaseModel]</code> <p>type[BaseModel]: Pydantic model class.</p> Source code in <code>src/memg_core/core/types.py</code> <pre><code>def get_entity_model(entity_name: str) -&gt; type[BaseModel]:\n    \"\"\"Get Pydantic model for entity from global registry.\n\n    Args:\n        entity_name: Name of the entity.\n\n    Returns:\n        type[BaseModel]: Pydantic model class.\n    \"\"\"\n    return TypeRegistry.get_instance().get_entity_model(entity_name)\n</code></pre>"},{"location":"reference/api/#configuration","title":"Configuration","text":"<p>Configuration management:</p> <p>Memory System Configuration - minimal and essential settings</p>"},{"location":"reference/api/#memg_core.core.config.DEFAULT_MEMG_CONFIG","title":"<code>DEFAULT_MEMG_CONFIG = MemGConfig()</code>  <code>module-attribute</code>","text":""},{"location":"reference/api/#memg_core.core.config.DEFAULT_SYSTEM_CONFIG","title":"<code>DEFAULT_SYSTEM_CONFIG = MemorySystemConfig()</code>  <code>module-attribute</code>","text":""},{"location":"reference/api/#memg_core.core.config.MemGConfig","title":"<code>MemGConfig</code>  <code>dataclass</code>","text":"<p>Core memory system configuration.</p> <p>Attributes:</p> Name Type Description <code>similarity_threshold</code> <code>float</code> <p>Threshold for conflict detection (0.0-1.0).</p> <code>score_threshold</code> <code>float</code> <p>Minimum score for search results (0.0-1.0).</p> <code>high_similarity_threshold</code> <code>float</code> <p>Threshold for duplicate detection (0.0-1.0).</p> <code>decay_rate</code> <code>float</code> <p>Graph traversal decay rate per hop (0.0-1.0).</p> <code>decay_threshold</code> <code>float</code> <p>Minimum neighbor relevance threshold (0.0-1.0).</p> <code>enable_ai_type_verification</code> <code>bool</code> <p>Enable AI-based type detection.</p> <code>enable_temporal_reasoning</code> <code>bool</code> <p>Enable temporal reasoning.</p> <code>vector_dimension</code> <code>int</code> <p>Embedding dimension size.</p> <code>batch_processing_size</code> <code>int</code> <p>Batch size for bulk operations.</p> <code>embedder_model</code> <code>str</code> <p>FastEmbed model name.</p> <code>template_name</code> <code>str</code> <p>Active template name.</p> <code>qdrant_collection_name</code> <code>str</code> <p>Qdrant collection name.</p> <code>kuzu_database_path</code> <code>str</code> <p>Kuzu database path.</p> Source code in <code>src/memg_core/core/config.py</code> <pre><code>@dataclass\nclass MemGConfig:\n    \"\"\"Core memory system configuration.\n\n    Attributes:\n        similarity_threshold: Threshold for conflict detection (0.0-1.0).\n        score_threshold: Minimum score for search results (0.0-1.0).\n        high_similarity_threshold: Threshold for duplicate detection (0.0-1.0).\n        decay_rate: Graph traversal decay rate per hop (0.0-1.0).\n        decay_threshold: Minimum neighbor relevance threshold (0.0-1.0).\n        enable_ai_type_verification: Enable AI-based type detection.\n        enable_temporal_reasoning: Enable temporal reasoning.\n        vector_dimension: Embedding dimension size.\n        batch_processing_size: Batch size for bulk operations.\n        embedder_model: FastEmbed model name.\n        template_name: Active template name.\n        qdrant_collection_name: Qdrant collection name.\n        kuzu_database_path: Kuzu database path.\n    \"\"\"\n\n    # Core similarity and scoring thresholds\n    similarity_threshold: float = 0.7  # For conflict detection\n    score_threshold: float = 0.3  # Minimum score for search results\n    high_similarity_threshold: float = 0.9  # For duplicate detection\n    decay_rate: float = 0.9  # Graph traversal decay rate per hop\n    decay_threshold: float = 0.1  # Minimum neighbor relevance threshold\n\n    # Processing settings\n    enable_ai_type_verification: bool = True  # AI-based type detection\n    enable_temporal_reasoning: bool = False  # Enable temporal reasoning\n\n    # Performance settings\n    vector_dimension: int = 384  # Embedding dimension\n    batch_processing_size: int = 50  # Batch size for bulk operations\n    embedder_model: str = \"Snowflake/snowflake-arctic-embed-xs\"  # FastEmbed model\n\n    # Template settings\n    template_name: str = \"default\"  # Active template name\n\n    # Database settings\n    qdrant_collection_name: str = \"memories\"\n    kuzu_database_path: str = \"kuzu_db\"\n\n    def __post_init__(self):\n        \"\"\"Validate configuration parameters.\n\n        Raises:\n            ValueError: If any threshold values are outside valid range [0.0, 1.0].\n        \"\"\"\n        if not 0.0 &lt;= self.similarity_threshold &lt;= 1.0:\n            raise ValueError(\"similarity_threshold must be between 0.0 and 1.0\")\n        if not 0.0 &lt;= self.score_threshold &lt;= 1.0:\n            raise ValueError(\"score_threshold must be between 0.0 and 1.0\")\n        if not 0.0 &lt;= self.high_similarity_threshold &lt;= 1.0:\n            raise ValueError(\"high_similarity_threshold must be between 0.0 and 1.0\")\n        if not 0.0 &lt;= self.decay_rate &lt;= 1.0:\n            raise ValueError(\"decay_rate must be between 0.0 and 1.0\")\n        if not 0.0 &lt;= self.decay_threshold &lt;= 1.0:\n            raise ValueError(\"decay_threshold must be between 0.0 and 1.0\")\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Convert configuration to dictionary.\n\n        Returns:\n            dict[str, Any]: Dictionary representation of configuration.\n        \"\"\"\n        return {\n            \"similarity_threshold\": self.similarity_threshold,\n            \"score_threshold\": self.score_threshold,\n            \"high_similarity_threshold\": self.high_similarity_threshold,\n            \"decay_rate\": self.decay_rate,\n            \"decay_threshold\": self.decay_threshold,\n            \"enable_ai_type_verification\": self.enable_ai_type_verification,\n            \"vector_dimension\": self.vector_dimension,\n            \"batch_processing_size\": self.batch_processing_size,\n            \"embedder_model\": self.embedder_model,\n            \"template_name\": self.template_name,\n            \"qdrant_collection_name\": self.qdrant_collection_name,\n            \"kuzu_database_path\": self.kuzu_database_path,\n        }\n\n    @classmethod\n    def from_dict(cls, config_dict: dict[str, Any]) -&gt; \"MemGConfig\":\n        \"\"\"Create configuration from dictionary.\n\n        Args:\n            config_dict: Dictionary containing configuration values.\n\n        Returns:\n            MemGConfig: Configuration instance.\n        \"\"\"\n        return cls(**config_dict)\n\n    @classmethod\n    def from_env(cls) -&gt; \"MemGConfig\":\n        \"\"\"Create configuration from environment variables.\n\n        Each instance should use explicit environment variables for isolation.\n        The core memory system doesn't know or care about server ports.\n\n        Returns:\n            MemGConfig: Configuration instance with environment-derived values.\n        \"\"\"\n        return cls(\n            similarity_threshold=float(os.getenv(\"MEMG_SIMILARITY_THRESHOLD\", \"0.7\")),\n            score_threshold=float(os.getenv(\"MEMG_SCORE_THRESHOLD\", \"0.3\")),\n            high_similarity_threshold=float(os.getenv(\"MEMG_HIGH_SIMILARITY_THRESHOLD\", \"0.9\")),\n            decay_rate=float(os.getenv(\"MEMG_DECAY_RATE\", \"0.9\")),\n            decay_threshold=float(os.getenv(\"MEMG_DECAY_THRESHOLD\", \"0.1\")),\n            enable_ai_type_verification=os.getenv(\n                \"MEMG_ENABLE_AI_TYPE_VERIFICATION\", \"true\"\n            ).lower()\n            == \"true\",\n            vector_dimension=int(os.getenv(\"EMBEDDING_DIMENSION_LEN\", \"384\")),\n            batch_processing_size=int(os.getenv(\"MEMG_BATCH_SIZE\", \"50\")),\n            embedder_model=os.getenv(\"EMBEDDER_MODEL\", \"Snowflake/snowflake-arctic-embed-xs\"),\n            template_name=os.getenv(\"MEMG_TEMPLATE\", \"default\"),\n            qdrant_collection_name=os.getenv(\"MEMG_QDRANT_COLLECTION\", \"memories\"),\n            kuzu_database_path=os.getenv(\"MEMG_KUZU_DB_PATH\", \"kuzu_db\"),\n        )\n</code></pre>"},{"location":"reference/api/#memg_core.core.config.MemGConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate configuration parameters.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any threshold values are outside valid range [0.0, 1.0].</p> Source code in <code>src/memg_core/core/config.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validate configuration parameters.\n\n    Raises:\n        ValueError: If any threshold values are outside valid range [0.0, 1.0].\n    \"\"\"\n    if not 0.0 &lt;= self.similarity_threshold &lt;= 1.0:\n        raise ValueError(\"similarity_threshold must be between 0.0 and 1.0\")\n    if not 0.0 &lt;= self.score_threshold &lt;= 1.0:\n        raise ValueError(\"score_threshold must be between 0.0 and 1.0\")\n    if not 0.0 &lt;= self.high_similarity_threshold &lt;= 1.0:\n        raise ValueError(\"high_similarity_threshold must be between 0.0 and 1.0\")\n    if not 0.0 &lt;= self.decay_rate &lt;= 1.0:\n        raise ValueError(\"decay_rate must be between 0.0 and 1.0\")\n    if not 0.0 &lt;= self.decay_threshold &lt;= 1.0:\n        raise ValueError(\"decay_threshold must be between 0.0 and 1.0\")\n</code></pre>"},{"location":"reference/api/#memg_core.core.config.MemGConfig.from_dict","title":"<code>from_dict(config_dict)</code>  <code>classmethod</code>","text":"<p>Create configuration from dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config_dict</code> <code>dict[str, Any]</code> <p>Dictionary containing configuration values.</p> required <p>Returns:</p> Name Type Description <code>MemGConfig</code> <code>MemGConfig</code> <p>Configuration instance.</p> Source code in <code>src/memg_core/core/config.py</code> <pre><code>@classmethod\ndef from_dict(cls, config_dict: dict[str, Any]) -&gt; \"MemGConfig\":\n    \"\"\"Create configuration from dictionary.\n\n    Args:\n        config_dict: Dictionary containing configuration values.\n\n    Returns:\n        MemGConfig: Configuration instance.\n    \"\"\"\n    return cls(**config_dict)\n</code></pre>"},{"location":"reference/api/#memg_core.core.config.MemGConfig.from_env","title":"<code>from_env()</code>  <code>classmethod</code>","text":"<p>Create configuration from environment variables.</p> <p>Each instance should use explicit environment variables for isolation. The core memory system doesn't know or care about server ports.</p> <p>Returns:</p> Name Type Description <code>MemGConfig</code> <code>MemGConfig</code> <p>Configuration instance with environment-derived values.</p> Source code in <code>src/memg_core/core/config.py</code> <pre><code>@classmethod\ndef from_env(cls) -&gt; \"MemGConfig\":\n    \"\"\"Create configuration from environment variables.\n\n    Each instance should use explicit environment variables for isolation.\n    The core memory system doesn't know or care about server ports.\n\n    Returns:\n        MemGConfig: Configuration instance with environment-derived values.\n    \"\"\"\n    return cls(\n        similarity_threshold=float(os.getenv(\"MEMG_SIMILARITY_THRESHOLD\", \"0.7\")),\n        score_threshold=float(os.getenv(\"MEMG_SCORE_THRESHOLD\", \"0.3\")),\n        high_similarity_threshold=float(os.getenv(\"MEMG_HIGH_SIMILARITY_THRESHOLD\", \"0.9\")),\n        decay_rate=float(os.getenv(\"MEMG_DECAY_RATE\", \"0.9\")),\n        decay_threshold=float(os.getenv(\"MEMG_DECAY_THRESHOLD\", \"0.1\")),\n        enable_ai_type_verification=os.getenv(\n            \"MEMG_ENABLE_AI_TYPE_VERIFICATION\", \"true\"\n        ).lower()\n        == \"true\",\n        vector_dimension=int(os.getenv(\"EMBEDDING_DIMENSION_LEN\", \"384\")),\n        batch_processing_size=int(os.getenv(\"MEMG_BATCH_SIZE\", \"50\")),\n        embedder_model=os.getenv(\"EMBEDDER_MODEL\", \"Snowflake/snowflake-arctic-embed-xs\"),\n        template_name=os.getenv(\"MEMG_TEMPLATE\", \"default\"),\n        qdrant_collection_name=os.getenv(\"MEMG_QDRANT_COLLECTION\", \"memories\"),\n        kuzu_database_path=os.getenv(\"MEMG_KUZU_DB_PATH\", \"kuzu_db\"),\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.core.config.MemGConfig.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert configuration to dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Dictionary representation of configuration.</p> Source code in <code>src/memg_core/core/config.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Convert configuration to dictionary.\n\n    Returns:\n        dict[str, Any]: Dictionary representation of configuration.\n    \"\"\"\n    return {\n        \"similarity_threshold\": self.similarity_threshold,\n        \"score_threshold\": self.score_threshold,\n        \"high_similarity_threshold\": self.high_similarity_threshold,\n        \"decay_rate\": self.decay_rate,\n        \"decay_threshold\": self.decay_threshold,\n        \"enable_ai_type_verification\": self.enable_ai_type_verification,\n        \"vector_dimension\": self.vector_dimension,\n        \"batch_processing_size\": self.batch_processing_size,\n        \"embedder_model\": self.embedder_model,\n        \"template_name\": self.template_name,\n        \"qdrant_collection_name\": self.qdrant_collection_name,\n        \"kuzu_database_path\": self.kuzu_database_path,\n    }\n</code></pre>"},{"location":"reference/api/#memg_core.core.config.MemorySystemConfig","title":"<code>MemorySystemConfig</code>  <code>dataclass</code>","text":"<p>Core memory system configuration - NO SERVER CONCERNS.</p> <p>Attributes:</p> Name Type Description <code>memg</code> <code>MemGConfig</code> <p>Core memory configuration instance.</p> <code>debug_mode</code> <code>bool</code> <p>Enable debug mode.</p> <code>log_level</code> <code>str</code> <p>Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).</p> Source code in <code>src/memg_core/core/config.py</code> <pre><code>@dataclass\nclass MemorySystemConfig:\n    \"\"\"Core memory system configuration - NO SERVER CONCERNS.\n\n    Attributes:\n        memg: Core memory configuration instance.\n        debug_mode: Enable debug mode.\n        log_level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).\n    \"\"\"\n\n    memg: MemGConfig = field(default_factory=MemGConfig)\n\n    # Core system settings only\n    debug_mode: bool = False\n    log_level: str = \"INFO\"\n\n    def __post_init__(self):\n        \"\"\"Validate core system configuration.\n\n        Raises:\n            ValueError: If log_level is not a valid logging level.\n        \"\"\"\n        if self.log_level not in [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]:\n            raise ValueError(\"log_level must be a valid logging level\")\n\n    @classmethod\n    def from_env(cls) -&gt; \"MemorySystemConfig\":\n        \"\"\"Create core memory system configuration from environment variables.\n\n        Returns:\n            MemorySystemConfig: Configuration instance with environment-derived values.\n        \"\"\"\n        return cls(\n            memg=MemGConfig.from_env(),\n            debug_mode=os.getenv(\"MEMORY_SYSTEM_DEBUG\", \"false\").lower() == \"true\",\n            log_level=os.getenv(\"MEMORY_SYSTEM_LOG_LEVEL\", \"INFO\").upper(),\n        )\n</code></pre>"},{"location":"reference/api/#memg_core.core.config.MemorySystemConfig.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Validate core system configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If log_level is not a valid logging level.</p> Source code in <code>src/memg_core/core/config.py</code> <pre><code>def __post_init__(self):\n    \"\"\"Validate core system configuration.\n\n    Raises:\n        ValueError: If log_level is not a valid logging level.\n    \"\"\"\n    if self.log_level not in [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"]:\n        raise ValueError(\"log_level must be a valid logging level\")\n</code></pre>"},{"location":"reference/api/#memg_core.core.config.MemorySystemConfig.from_env","title":"<code>from_env()</code>  <code>classmethod</code>","text":"<p>Create core memory system configuration from environment variables.</p> <p>Returns:</p> Name Type Description <code>MemorySystemConfig</code> <code>MemorySystemConfig</code> <p>Configuration instance with environment-derived values.</p> Source code in <code>src/memg_core/core/config.py</code> <pre><code>@classmethod\ndef from_env(cls) -&gt; \"MemorySystemConfig\":\n    \"\"\"Create core memory system configuration from environment variables.\n\n    Returns:\n        MemorySystemConfig: Configuration instance with environment-derived values.\n    \"\"\"\n    return cls(\n        memg=MemGConfig.from_env(),\n        debug_mode=os.getenv(\"MEMORY_SYSTEM_DEBUG\", \"false\").lower() == \"true\",\n        log_level=os.getenv(\"MEMORY_SYSTEM_LOG_LEVEL\", \"INFO\").upper(),\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.core.config.get_config","title":"<code>get_config()</code>","text":"<p>Get system configuration, preferring environment variables.</p> <p>Returns:</p> Name Type Description <code>MemorySystemConfig</code> <code>MemorySystemConfig</code> <p>System configuration instance.</p> Source code in <code>src/memg_core/core/config.py</code> <pre><code>def get_config() -&gt; MemorySystemConfig:\n    \"\"\"Get system configuration, preferring environment variables.\n\n    Returns:\n        MemorySystemConfig: System configuration instance.\n    \"\"\"\n    return MemorySystemConfig.from_env()\n</code></pre>"},{"location":"reference/api/#exceptions","title":"Exceptions","text":"<p>Exception classes:</p> <p>Custom exception hierarchy for the memory system - minimal set.</p>"},{"location":"reference/api/#memg_core.core.exceptions.ConfigurationError","title":"<code>ConfigurationError</code>","text":"<p>               Bases: <code>MemorySystemError</code></p> <p>Configuration-related errors (env vars, validation).</p> Source code in <code>src/memg_core/core/exceptions.py</code> <pre><code>class ConfigurationError(MemorySystemError):\n    \"\"\"Configuration-related errors (env vars, validation).\"\"\"\n</code></pre>"},{"location":"reference/api/#memg_core.core.exceptions.DatabaseError","title":"<code>DatabaseError</code>","text":"<p>               Bases: <code>MemorySystemError</code></p> <p>Database operation failures (Qdrant, Kuzu).</p> Source code in <code>src/memg_core/core/exceptions.py</code> <pre><code>class DatabaseError(MemorySystemError):\n    \"\"\"Database operation failures (Qdrant, Kuzu).\"\"\"\n</code></pre>"},{"location":"reference/api/#memg_core.core.exceptions.MemorySystemError","title":"<code>MemorySystemError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all memory system errors.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>Error message.</p> <code>operation</code> <p>Operation that caused the error.</p> <code>context</code> <p>Additional context information.</p> <code>original_error</code> <p>Original exception that was wrapped.</p> Source code in <code>src/memg_core/core/exceptions.py</code> <pre><code>class MemorySystemError(Exception):\n    \"\"\"Base exception for all memory system errors.\n\n    Attributes:\n        message: Error message.\n        operation: Operation that caused the error.\n        context: Additional context information.\n        original_error: Original exception that was wrapped.\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        operation: str | None = None,\n        context: dict[str, Any] | None = None,\n        original_error: Exception | None = None,\n    ):\n        self.message = message\n        self.operation = operation\n        self.context = context or {}\n        self.original_error = original_error\n\n        # Build detailed error message\n        full_message = message\n        if operation:\n            full_message = f\"[{operation}] {message}\"\n        if original_error:\n            full_message += f\" (caused by: {original_error})\"\n\n        super().__init__(full_message)\n</code></pre>"},{"location":"reference/api/#memg_core.core.exceptions.ProcessingError","title":"<code>ProcessingError</code>","text":"<p>               Bases: <code>MemorySystemError</code></p> <p>Memory processing operation failures (catch-all for processing).</p> Source code in <code>src/memg_core/core/exceptions.py</code> <pre><code>class ProcessingError(MemorySystemError):\n    \"\"\"Memory processing operation failures (catch-all for processing).\"\"\"\n</code></pre>"},{"location":"reference/api/#memg_core.core.exceptions.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>MemorySystemError</code></p> <p>Data validation failures (schema, input format).</p> Source code in <code>src/memg_core/core/exceptions.py</code> <pre><code>class ValidationError(MemorySystemError):\n    \"\"\"Data validation failures (schema, input format).\"\"\"\n</code></pre>"},{"location":"reference/api/#memg_core.core.exceptions.handle_with_context","title":"<code>handle_with_context(operation)</code>","text":"<p>Decorator for consistent error handling with context.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>str</code> <p>Operation name for error context.</p> required <p>Returns:</p> Name Type Description <code>callable</code> <p>Decorated function with error handling.</p> Source code in <code>src/memg_core/core/exceptions.py</code> <pre><code>def handle_with_context(operation: str):\n    \"\"\"Decorator for consistent error handling with context.\n\n    Args:\n        operation: Operation name for error context.\n\n    Returns:\n        callable: Decorated function with error handling.\n    \"\"\"\n\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except MemorySystemError:\n                # Re-raise our own exceptions as-is\n                raise\n            except Exception as e:\n                # Wrap unknown exceptions\n                raise wrap_exception(e, operation, {\"args\": args, \"kwargs\": kwargs}) from e\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/api/#memg_core.core.exceptions.wrap_exception","title":"<code>wrap_exception(original_error, operation, context=None)</code>","text":"<p>Wrap a generic exception in an appropriate MemorySystemError subclass.</p> <p>Parameters:</p> Name Type Description Default <code>original_error</code> <code>Exception</code> <p>Original exception to wrap.</p> required <code>operation</code> <code>str</code> <p>Operation that caused the error.</p> required <code>context</code> <code>dict[str, Any] | None</code> <p>Additional context information.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>MemorySystemError</code> <code>MemorySystemError</code> <p>Wrapped exception with appropriate subclass.</p> Source code in <code>src/memg_core/core/exceptions.py</code> <pre><code>def wrap_exception(\n    original_error: Exception, operation: str, context: dict[str, Any] | None = None\n) -&gt; MemorySystemError:\n    \"\"\"Wrap a generic exception in an appropriate MemorySystemError subclass.\n\n    Args:\n        original_error: Original exception to wrap.\n        operation: Operation that caused the error.\n        context: Additional context information.\n\n    Returns:\n        MemorySystemError: Wrapped exception with appropriate subclass.\n    \"\"\"\n    error_message = str(original_error)\n\n    # Map common exceptions to our hierarchy\n\n    if isinstance(original_error, (FileNotFoundError, PermissionError)):\n        return DatabaseError(\n            f\"Storage error: {error_message}\",\n            operation=operation,\n            context=context,\n            original_error=original_error,\n        )\n\n    if isinstance(original_error, ValueError):\n        return ValidationError(\n            f\"Invalid value: {error_message}\",\n            operation=operation,\n            context=context,\n            original_error=original_error,\n        )\n\n    # Default to generic ProcessingError for unknown exceptions\n    return ProcessingError(\n        f\"Unexpected error: {error_message}\",\n        operation=operation,\n        context=context,\n        original_error=original_error,\n    )\n</code></pre>"},{"location":"reference/api/#yaml-schema","title":"YAML Schema","text":"<p>YAML schema handling:</p> <p>YAML Translator: validates payloads using TypeRegistry and resolves anchor text.</p> <p>STRICT YAML-FIRST: This module enforces the single-YAML-orchestrates-everything principle. NO flexibility, NO migration support, NO fallbacks.</p> <p>Uses TypeRegistry as SINGLE SOURCE OF TRUTH for all entity definitions. All type building and validation delegated to TypeRegistry - zero redundancy.</p>"},{"location":"reference/api/#memg_core.core.yaml_translator.Memory","title":"<code>Memory</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Core memory model with YAML-driven payload validation.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier (UUID or HRID).</p> <code>user_id</code> <code>str</code> <p>Owner of the memory.</p> <code>memory_type</code> <code>str</code> <p>Entity type from YAML schema.</p> <code>payload</code> <code>dict[str, Any]</code> <p>Entity-specific fields.</p> <code>vector</code> <code>list[float] | None</code> <p>Embedding vector.</p> <code>created_at</code> <code>datetime</code> <p>Creation timestamp.</p> <code>updated_at</code> <code>datetime | None</code> <p>Last update timestamp.</p> <code>hrid</code> <code>str | None</code> <p>Human-readable identifier.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>class Memory(BaseModel):\n    \"\"\"Core memory model with YAML-driven payload validation.\n\n    Attributes:\n        id: Unique identifier (UUID or HRID).\n        user_id: Owner of the memory.\n        memory_type: Entity type from YAML schema.\n        payload: Entity-specific fields.\n        vector: Embedding vector.\n        created_at: Creation timestamp.\n        updated_at: Last update timestamp.\n        hrid: Human-readable identifier.\n    \"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    # Core fields only - NO hardcoded entity-specific fields\n    # NO DEFAULTS - crash early if required fields missing\n    id: str = Field(default_factory=lambda: str(uuid4()))  # System-generated ID only\n    user_id: str  # REQUIRED - no default\n    memory_type: str  # REQUIRED - no default, must come from YAML\n    payload: dict[str, Any] = Field(default_factory=dict)  # Entity fields container\n    vector: list[float] | None = None  # System-generated vector\n    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))  # System timestamp\n    updated_at: datetime | None = None\n\n    # Human-readable id (e.g., MEMO_AAA001)\n    hrid: str | None = None\n\n    @field_validator(\"memory_type\")\n    @classmethod\n    def memory_type_not_empty(cls, v: str) -&gt; str:\n        \"\"\"Validate that memory_type is not empty.\n\n        Args:\n            v: Memory type value.\n\n        Returns:\n            str: Stripped memory type.\n\n        Raises:\n            ValueError: If memory_type is empty or whitespace.\n        \"\"\"\n        if not v or not v.strip():\n            raise ValueError(\"memory_type cannot be empty\")\n        return v.strip()\n\n    # (properties removed \u2013 dynamic __getattr__ handles field access)\n\n    def __getattr__(self, item: str):\n        \"\"\"Dynamic attribute access for YAML-defined payload fields ONLY.\n\n        No fallback logic, no backward compatibility. If the field is not\n        in the payload dictionary, raises AttributeError immediately.\n        This enforces strict YAML schema compliance.\n\n        Args:\n            item: Field name to access.\n\n        Returns:\n            Any: Field value from payload.\n\n        Raises:\n            AttributeError: If field is not in payload.\n        \"\"\"\n        payload = self.__dict__.get(\"payload\")\n        if isinstance(payload, dict) and item in payload:\n            return payload[item]\n        raise AttributeError(f\"'{type(self).__name__}' object has no attribute '{item}'\")\n\n    # ---------------------------------------------------------------------\n    # YAML \u2192 Dynamic entity model projection helpers\n    # ---------------------------------------------------------------------\n    def to_entity_model(self):\n        \"\"\"Project this Memory into a dynamic Pydantic entity model.\n\n        Returns an instance of the auto-generated model class that matches\n        the entity type defined in the YAML schema. Only non-system fields\n        are included.\n\n        Returns:\n            BaseModel: Dynamic Pydantic model instance.\n        \"\"\"\n        model_cls = get_entity_model(self.memory_type)\n        # Pass only fields that the model expects\n        model_fields = {\n            k: v for k, v in (self.payload or {}).items() if k in model_cls.model_fields\n        }\n        return model_cls(**model_fields)\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.Memory.__getattr__","title":"<code>__getattr__(item)</code>","text":"<p>Dynamic attribute access for YAML-defined payload fields ONLY.</p> <p>No fallback logic, no backward compatibility. If the field is not in the payload dictionary, raises AttributeError immediately. This enforces strict YAML schema compliance.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>Field name to access.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>Field value from payload.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If field is not in payload.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>def __getattr__(self, item: str):\n    \"\"\"Dynamic attribute access for YAML-defined payload fields ONLY.\n\n    No fallback logic, no backward compatibility. If the field is not\n    in the payload dictionary, raises AttributeError immediately.\n    This enforces strict YAML schema compliance.\n\n    Args:\n        item: Field name to access.\n\n    Returns:\n        Any: Field value from payload.\n\n    Raises:\n        AttributeError: If field is not in payload.\n    \"\"\"\n    payload = self.__dict__.get(\"payload\")\n    if isinstance(payload, dict) and item in payload:\n        return payload[item]\n    raise AttributeError(f\"'{type(self).__name__}' object has no attribute '{item}'\")\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.Memory.memory_type_not_empty","title":"<code>memory_type_not_empty(v)</code>  <code>classmethod</code>","text":"<p>Validate that memory_type is not empty.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>Memory type value.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Stripped memory type.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If memory_type is empty or whitespace.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>@field_validator(\"memory_type\")\n@classmethod\ndef memory_type_not_empty(cls, v: str) -&gt; str:\n    \"\"\"Validate that memory_type is not empty.\n\n    Args:\n        v: Memory type value.\n\n    Returns:\n        str: Stripped memory type.\n\n    Raises:\n        ValueError: If memory_type is empty or whitespace.\n    \"\"\"\n    if not v or not v.strip():\n        raise ValueError(\"memory_type cannot be empty\")\n    return v.strip()\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.Memory.to_entity_model","title":"<code>to_entity_model()</code>","text":"<p>Project this Memory into a dynamic Pydantic entity model.</p> <p>Returns an instance of the auto-generated model class that matches the entity type defined in the YAML schema. Only non-system fields are included.</p> <p>Returns:</p> Name Type Description <code>BaseModel</code> <p>Dynamic Pydantic model instance.</p> Source code in <code>src/memg_core/core/models.py</code> <pre><code>def to_entity_model(self):\n    \"\"\"Project this Memory into a dynamic Pydantic entity model.\n\n    Returns an instance of the auto-generated model class that matches\n    the entity type defined in the YAML schema. Only non-system fields\n    are included.\n\n    Returns:\n        BaseModel: Dynamic Pydantic model instance.\n    \"\"\"\n    model_cls = get_entity_model(self.memory_type)\n    # Pass only fields that the model expects\n    model_fields = {\n        k: v for k, v in (self.payload or {}).items() if k in model_cls.model_fields\n    }\n    return model_cls(**model_fields)\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.MemorySystemError","title":"<code>MemorySystemError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all memory system errors.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>Error message.</p> <code>operation</code> <p>Operation that caused the error.</p> <code>context</code> <p>Additional context information.</p> <code>original_error</code> <p>Original exception that was wrapped.</p> Source code in <code>src/memg_core/core/exceptions.py</code> <pre><code>class MemorySystemError(Exception):\n    \"\"\"Base exception for all memory system errors.\n\n    Attributes:\n        message: Error message.\n        operation: Operation that caused the error.\n        context: Additional context information.\n        original_error: Original exception that was wrapped.\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        operation: str | None = None,\n        context: dict[str, Any] | None = None,\n        original_error: Exception | None = None,\n    ):\n        self.message = message\n        self.operation = operation\n        self.context = context or {}\n        self.original_error = original_error\n\n        # Build detailed error message\n        full_message = message\n        if operation:\n            full_message = f\"[{operation}] {message}\"\n        if original_error:\n            full_message += f\" (caused by: {original_error})\"\n\n        super().__init__(full_message)\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator","title":"<code>YamlTranslator</code>","text":"<p>Translates YAML schema definitions to Pydantic models for strict validation.</p> <p>Attributes:</p> Name Type Description <code>yaml_path</code> <p>Path to YAML schema file.</p> <code>_schema</code> <code>dict[str, Any] | None</code> <p>Cached schema dictionary.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>class YamlTranslator:\n    \"\"\"Translates YAML schema definitions to Pydantic models for strict validation.\n\n    Attributes:\n        yaml_path: Path to YAML schema file.\n        _schema: Cached schema dictionary.\n    \"\"\"\n\n    def __init__(self, yaml_path: str | None = None) -&gt; None:\n        \"\"\"Initialize YamlTranslator with YAML schema path.\n\n        Args:\n            yaml_path: Path to YAML schema file. If None, uses MEMG_YAML_SCHEMA env var.\n\n        Raises:\n            YamlTranslatorError: If YAML path not provided or TypeRegistry initialization fails.\n        \"\"\"\n        # Require explicit YAML path - no silent defaults\n        if yaml_path:\n            self.yaml_path = yaml_path\n        else:\n            env_path = os.getenv(\"MEMG_YAML_SCHEMA\")\n            if not env_path:\n                raise YamlTranslatorError(\n                    \"YAML schema path required. Set MEMG_YAML_SCHEMA environment variable \"\n                    \"or provide yaml_path parameter. No defaults allowed.\"\n                )\n            self.yaml_path = env_path\n\n        self._schema: dict[str, Any] | None = None\n        # NO model cache - TypeRegistry handles all caching\n\n        # Initialize TypeRegistry from YAML - crash early if invalid\n        try:\n            initialize_types_from_yaml(self.yaml_path)\n        except Exception as e:\n            raise YamlTranslatorError(f\"Failed to initialize TypeRegistry from YAML: {e}\") from e\n\n    @property\n    def schema(self) -&gt; dict[str, Any]:\n        \"\"\"Get the loaded YAML schema, loading it if necessary.\"\"\"\n        if self._schema is not None:\n            return self._schema\n\n        # Load schema from the required path - no fallbacks\n        if not self.yaml_path:\n            raise YamlTranslatorError(\n                \"YAML schema path not set. This should not happen after __init__.\"\n            )\n\n        self._schema = self._load_schema()\n        return self._schema\n\n    def _load_schema(self) -&gt; dict[str, Any]:\n        \"\"\"Load schema from the current yaml_path.\"\"\"\n        if not self.yaml_path:\n            raise YamlTranslatorError(\"YAML path is None\")\n        path = Path(self.yaml_path)\n        if not path.exists():\n            raise YamlTranslatorError(f\"YAML schema not found at {path}\")\n        try:\n            with path.open(encoding=\"utf-8\") as f:\n                data = yaml.safe_load(f)\n            if not data:\n                raise YamlTranslatorError(\"Empty YAML schema\")\n            if not isinstance(data, dict):\n                raise YamlTranslatorError(\"YAML schema root must be a mapping\")\n            return data\n        except yaml.YAMLError as e:\n            raise YamlTranslatorError(f\"Invalid YAML syntax: {e}\") from e\n\n    def _entities_map(self) -&gt; dict[str, dict[str, Any]]:\n        sch = self.schema\n        ents = sch.get(\"entities\")\n        if not ents:\n            return {}\n        if isinstance(ents, dict):\n            # Normalize keys to lower\n            return {str(k).lower(): v for k, v in ents.items()}\n        # list form\n        out: dict[str, dict[str, Any]] = {}\n        for item in ents:\n            if not isinstance(item, dict):\n                continue\n            key = (item.get(\"name\") or item.get(\"type\") or \"\").lower()\n            if key:\n                out[key] = item\n        return out\n\n    def get_entity_types(self) -&gt; list[str]:\n        \"\"\"Get list of available entity types from YAML schema.\"\"\"\n        return list(self._entities_map().keys())\n\n    # ================== RELATIONSHIP PARSING (TARGET-FIRST FORMAT) ==================\n\n    def _get_relations_mapping_for_entity(\n        self, entity_name: str\n    ) -&gt; dict[str, list[dict[str, Any]]]:\n        \"\"\"Return raw relations mapping for an entity in target-first schema format.\n\n        The expected YAML shape under an entity is:\n            relations:\n              target_entity_name:\n                - name: ...\n                  description: ...\n                  predicate: PREDICATE_NAME\n                  directed: true|false\n\n        Returns an empty dict when no relations are defined.\n        \"\"\"\n        entity_spec = self._resolve_entity_with_inheritance(entity_name)\n        relations_section = entity_spec.get(\"relations\")\n        if not relations_section or not isinstance(relations_section, dict):\n            return {}\n\n        # Normalize keys to lower for targets; keep items as-is\n        normalized: dict[str, list[dict[str, Any]]] = {}\n        for target_name, items in relations_section.items():\n            if not isinstance(items, list):\n                # Skip invalid shapes silently at this layer; validation is higher-level\n                continue\n            normalized[str(target_name).lower()] = [i for i in items if isinstance(i, dict)]\n        return normalized\n\n    def get_relations_for_source(self, entity_name: str) -&gt; list[dict[str, Any]]:\n        \"\"\"Get normalized relation specs for a source entity in target-first schema.\n\n        Returns list of dicts with keys:\n            - source (str)\n            - target (str)\n            - name (str | None)\n            - description (str | None)\n            - predicate (str)\n            - directed (bool)\n        \"\"\"\n        if not entity_name:\n            raise YamlTranslatorError(\"Empty entity name\")\n\n        source_l = entity_name.lower()\n        relations_map = self._get_relations_mapping_for_entity(source_l)\n        if not relations_map:\n            return []\n\n        out: list[dict[str, Any]] = []\n        for target_l, items in relations_map.items():\n            for item in items:\n                predicate = item.get(\"predicate\")\n                if not predicate or not isinstance(predicate, str):\n                    # Skip invalid entries - strict behavior can be added later\n                    continue\n                directed = bool(item.get(\"directed\", True))\n                out.append(\n                    {\n                        \"source\": source_l,\n                        \"target\": target_l,\n                        \"name\": item.get(\"name\"),\n                        \"description\": item.get(\"description\"),\n                        \"predicate\": predicate.upper(),\n                        \"directed\": directed,\n                    }\n                )\n        return out\n\n    @staticmethod\n    def relationship_table_name(\n        source: str,\n        predicate: str,\n        target: str,\n        *,\n        directed: bool = True,  # noqa: unused-argument\n    ) -&gt; str:\n        \"\"\"Generate relationship table name.\n\n        For now, table name does not encode direction; direction affects creation/query semantics.\n        Canonicalization for undirected pairs can be added here later if decided.\n        \"\"\"\n        return f\"{str(source).upper()}_{str(predicate).upper()}_{str(target).upper()}\"\n\n    def get_labels_for_predicates(\n        self,\n        source_type: str,\n        predicates: list[str] | None,\n        neighbor_label: str | None = None,\n    ) -&gt; list[str]:\n        \"\"\"Expand predicate names to concrete relationship labels for a given source.\n\n        Args:\n            source_type: Source entity type name\n            predicates: List of predicate names to include (case-insensitive). If None, include all.\n            neighbor_label: Optional target entity type filter (case-insensitive)\n\n        Returns:\n            List of concrete relationship labels (table names) matching the filter.\n        \"\"\"\n        if not source_type:\n            raise YamlTranslatorError(\"Empty source_type\")\n\n        preds_u = set(p.upper() for p in predicates) if predicates else None\n        neighbor_l = neighbor_label.lower() if neighbor_label else None\n\n        labels: list[str] = []\n        for spec in self.get_relations_for_source(source_type):\n            if preds_u is not None and spec[\"predicate\"].upper() not in preds_u:\n                continue\n            if neighbor_l is not None and spec[\"target\"].lower() != neighbor_l:\n                continue\n            labels.append(\n                self.relationship_table_name(\n                    source=spec[\"source\"],\n                    predicate=spec[\"predicate\"],\n                    target=spec[\"target\"],\n                    directed=spec[\"directed\"],\n                )\n            )\n        return labels\n\n    def debug_relation_map(self) -&gt; dict[str, dict[str, list[dict[str, Any]]]]:\n        \"\"\"Return a nested relation map for debugging/printing.\n\n        Structure:\n        {\n          source: {\n            target: [ {name, predicate, directed, description} ... ]\n          }\n        }\n        \"\"\"\n        out: dict[str, dict[str, list[dict[str, Any]]]] = {}\n        for source in self.get_entity_types():\n            specs = self.get_relations_for_source(source)\n            if not specs:\n                continue\n            if source not in out:\n                out[source] = {}\n            for spec in specs:\n                target = spec[\"target\"]\n                out[source].setdefault(target, [])\n                out[source][target].append(\n                    {\n                        \"name\": spec.get(\"name\"),\n                        \"predicate\": spec.get(\"predicate\"),\n                        \"directed\": spec.get(\"directed\", True),\n                        \"description\": spec.get(\"description\"),\n                    }\n                )\n        return out\n\n    def get_anchor_field(self, entity_name: str) -&gt; str:\n        \"\"\"Get the anchor field name for the given entity type from YAML schema.\n\n        Now reads from vector.anchored_to instead of separate anchor field.\n\n        Args:\n            entity_name: Name of the entity type.\n\n        Returns:\n            str: Anchor field name.\n\n        Raises:\n            YamlTranslatorError: If anchor field not found.\n        \"\"\"\n        if not entity_name:\n            raise YamlTranslatorError(\"Empty entity name\")\n\n        # Get entity spec with inheritance resolution\n        entity_spec = self._resolve_entity_with_inheritance(entity_name)\n\n        # Look for vector field with anchored_to\n        fields = entity_spec.get(\"fields\", {})\n        for _field_name, field_def in fields.items():\n            if isinstance(field_def, dict) and field_def.get(\"type\") == \"vector\":\n                anchored_to = field_def.get(\"anchored_to\")\n                if anchored_to:\n                    return str(anchored_to)\n\n        raise YamlTranslatorError(\n            f\"Entity '{entity_name}' has no vector field with 'anchored_to' property\"\n        )\n\n    def _resolve_entity_with_inheritance(self, entity_name: str) -&gt; dict[str, Any]:\n        \"\"\"Resolve entity specification with full inheritance chain.\"\"\"\n        name_l = entity_name.lower()\n        emap = self._entities_map()\n        spec_raw = emap.get(name_l)\n        if not spec_raw:\n            raise YamlTranslatorError(f\"Entity '{entity_name}' not found in YAML schema\")\n\n        # If no parent, return as-is\n        parent_name = spec_raw.get(\"parent\")\n        if not parent_name:\n            return spec_raw\n\n        # Recursively resolve parent and merge fields\n        parent_spec = self._resolve_entity_with_inheritance(parent_name)\n\n        # Merge parent fields with child fields (child overrides parent)\n        merged_fields = parent_spec.get(\"fields\", {}).copy()\n        merged_fields.update(spec_raw.get(\"fields\", {}))\n\n        # Create merged spec\n        merged_spec = spec_raw.copy()\n        merged_spec[\"fields\"] = merged_fields\n\n        return merged_spec\n\n    def get_see_also_config(self, entity_name: str) -&gt; dict[str, Any] | None:\n        \"\"\"Get the see_also configuration for the given entity type from YAML schema.\n\n        Returns:\n            Dict with keys: enabled, threshold, limit, target_types\n            None if see_also is not configured for this entity\n        \"\"\"\n        if not entity_name:\n            raise YamlTranslatorError(\"Empty entity name\")\n        name_l = entity_name.lower()\n        emap = self._entities_map()\n        spec_raw = emap.get(name_l)\n        if not spec_raw:\n            raise YamlTranslatorError(f\"Entity '{entity_name}' not found in YAML schema\")\n\n        see_also = spec_raw.get(\"see_also\")\n        if not see_also or not isinstance(see_also, dict):\n            return None\n\n        # Validate required fields\n        if not see_also.get(\"enabled\", False):\n            return None\n\n        return {\n            \"enabled\": see_also.get(\"enabled\", False),\n            \"threshold\": float(see_also.get(\"threshold\", 0.7)),\n            \"limit\": int(see_also.get(\"limit\", 3)),\n            \"target_types\": list(see_also.get(\"target_types\", [])),\n        }\n\n    def build_anchor_text(self, memory) -&gt; str:\n        \"\"\"Build anchor text for embedding from YAML-defined anchor field.\n\n        NO hardcoded field names - reads anchor field from YAML schema.\n\n        Args:\n            memory: Memory object containing payload data.\n\n        Returns:\n            str: Anchor text for embedding.\n\n        Raises:\n            YamlTranslatorError: If anchor field is missing or invalid.\n        \"\"\"\n        mem_type = getattr(memory, \"memory_type\", None)\n        if not mem_type:\n            raise YamlTranslatorError(\n                \"Memory object missing 'memory_type' field\",\n                operation=\"build_anchor_text\",\n            )\n\n        # Get anchor field from YAML schema\n        anchor_field = self.get_anchor_field(mem_type)\n\n        # Try to get anchor text from the specified field\n        anchor_text = None\n\n        # First check if it's a core field on the Memory object\n        if hasattr(memory, anchor_field):\n            anchor_text = getattr(memory, anchor_field, None)\n        # Otherwise check in the payload\n        elif hasattr(memory, \"payload\") and isinstance(memory.payload, dict):\n            anchor_text = memory.payload.get(anchor_field)\n\n        if isinstance(anchor_text, str):\n            stripped_text = anchor_text.strip()\n            if stripped_text:\n                return stripped_text\n\n        # Anchor field missing, empty, or invalid\n        raise YamlTranslatorError(\n            f\"Anchor field '{anchor_field}' is missing, empty, or invalid \"\n            f\"for memory type '{mem_type}'\",\n            operation=\"build_anchor_text\",\n            context={\n                \"memory_type\": mem_type,\n                \"anchor_field\": anchor_field,\n                \"anchor_value\": anchor_text,\n            },\n        )\n\n    def _fields_contract(self, spec: dict[str, Any]) -&gt; tuple[list[str], list[str]]:\n        \"\"\"Extract required and optional fields from entity specification.\n\n        Supports either:\n        - fields: {required:[...], optional:[...]} format\n        - Individual field definitions with required flags\n\n        Args:\n            spec: Entity specification dictionary.\n\n        Returns:\n            tuple[list[str], list[str]]: (required_fields, optional_fields)\n        \"\"\"\n        # supports either fields: {required:[...], optional:[...]} OR flat dict\n        fields = spec.get(\"fields\") or {}\n        if \"required\" in fields or \"optional\" in fields:\n            req = [str(x) for x in fields.get(\"required\", [])]\n            opt = [str(x) for x in fields.get(\"optional\", [])]\n            return req, opt\n\n        # Resolve all fields including inherited ones\n        all_fields = self._resolve_inherited_fields(spec)\n\n        # Parse individual field definitions for required flag\n        required_fields = []\n        optional_fields = []\n\n        for field_name, field_def in all_fields.items():\n            if isinstance(field_def, dict) and field_def.get(\"required\", False):\n                # Skip system fields - they're handled by the system\n                if not field_def.get(\"system\", False):\n                    required_fields.append(field_name)\n                else:\n                    optional_fields.append(field_name)\n            else:\n                optional_fields.append(field_name)\n\n        return required_fields, optional_fields\n\n    def _resolve_inherited_fields(self, spec: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Resolve all fields including inherited ones from parent entities.\n\n        Args:\n            spec: Entity specification dictionary.\n\n        Returns:\n            dict[str, Any]: Dictionary containing all fields (inherited + current).\n        \"\"\"\n        all_fields = {}\n        entities_map = self._entities_map()\n\n        # If entity has a parent, resolve parent fields first\n        parent_name = spec.get(\"parent\")\n        if parent_name:\n            parent_spec = entities_map.get(parent_name.lower())\n            if parent_spec:\n                # Recursively resolve parent fields\n                parent_fields = self._resolve_inherited_fields(parent_spec)\n                all_fields.update(parent_fields)\n\n        # Add/override with current entity's fields\n        current_fields = spec.get(\"fields\") or {}\n        all_fields.update(current_fields)\n\n        return all_fields\n\n    def _get_system_fields(self, spec: dict[str, Any]) -&gt; set[str]:\n        \"\"\"Extract system fields from YAML schema (fields marked with system: true).\n\n        Args:\n            spec: Entity specification dictionary.\n\n        Returns:\n            set[str]: Set of field names that are marked as system fields.\n        \"\"\"\n        system_fields = set()\n        all_fields = self._resolve_inherited_fields(spec)\n\n        for field_name, field_def in all_fields.items():\n            if isinstance(field_def, dict) and field_def.get(\"system\", False):\n                system_fields.add(field_name)\n\n        return system_fields\n\n    def _validate_enum_fields(self, memory_type: str, payload: dict[str, Any]) -&gt; None:\n        \"\"\"Validate enum fields against YAML schema choices.\n\n        Args:\n            memory_type: Entity type from YAML schema.\n            payload: Memory data to validate.\n\n        Raises:\n            YamlTranslatorError: If enum field has invalid value.\n        \"\"\"\n        emap = self._entities_map()\n        spec = emap.get(memory_type.lower())\n        if not spec:\n            return  # Entity validation happens elsewhere\n\n        # Get field definitions for this entity type\n        fields = spec.get(\"fields\", {})\n\n        # Check each field in the payload\n        for field_name, field_value in payload.items():\n            if field_name in fields:\n                field_def = fields[field_name]\n\n                # Check if this is an enum field\n                if field_def.get(\"type\") == \"enum\":\n                    choices = field_def.get(\"choices\", [])\n\n                    # Validate the value against choices\n                    if field_value is not None and field_value not in choices:\n                        raise YamlTranslatorError(\n                            f\"Invalid {field_name} value '{field_value}'. Valid choices: {choices}\",\n                            context={\n                                \"memory_type\": memory_type,\n                                \"field_name\": field_name,\n                                \"invalid_value\": field_value,\n                                \"valid_choices\": choices,\n                            },\n                        )\n\n    def validate_memory_against_yaml(\n        self, memory_type: str, payload: dict[str, Any]\n    ) -&gt; dict[str, Any]:\n        \"\"\"Validate memory payload against YAML schema and return cleaned payload.\"\"\"\n        if not memory_type:\n            raise YamlTranslatorError(\"memory_type is required\")\n        if payload is None:\n            raise YamlTranslatorError(\"payload is required\")\n\n        # Strict validation - entity type MUST exist in YAML\n        emap = self._entities_map()\n        spec = emap.get(memory_type.lower())\n        if not spec:\n            raise YamlTranslatorError(\n                f\"Unknown entity type '{memory_type}'. All types must be defined in YAML schema.\",\n                context={\n                    \"memory_type\": memory_type,\n                    \"available_types\": list(emap.keys()),\n                },\n            )\n\n        req, _opt = self._fields_contract(spec)\n        missing = [k for k in req if not payload.get(k)]\n        if missing:\n            raise YamlTranslatorError(\n                f\"Missing required fields: {missing}\",\n                context={\"memory_type\": memory_type},\n            )\n\n        # Validate enum fields against YAML schema choices\n        self._validate_enum_fields(memory_type, payload)\n\n        # Validate that all fields are defined in YAML schema\n        req, opt = self._fields_contract(spec)\n        valid_fields = set(req + opt)\n        system_fields = self._get_system_fields(spec)\n        invalid_fields = set(payload.keys()) - valid_fields - system_fields\n        if invalid_fields:\n            raise YamlTranslatorError(\n                f\"Invalid fields not defined in schema: {sorted(invalid_fields)}\",\n                context={\n                    \"memory_type\": memory_type,\n                    \"valid_fields\": sorted(valid_fields),\n                    \"invalid_fields\": sorted(invalid_fields),\n                },\n            )\n\n        # Strip system-reserved fields if present\n        cleaned = dict(payload)\n        for syskey in system_fields:\n            cleaned.pop(syskey, None)\n        return cleaned\n\n    def create_memory_from_yaml(self, memory_type: str, payload: dict[str, Any], user_id: str):\n        \"\"\"Create a Memory object from YAML-validated payload.\"\"\"\n\n        # Get anchor field from YAML schema\n        anchor_field = self.get_anchor_field(memory_type)\n\n        # Extract anchor text from payload\n        anchor_text = payload.get(anchor_field)\n        if not anchor_text or not isinstance(anchor_text, str):\n            raise YamlTranslatorError(\n                f\"Missing or invalid anchor field '{anchor_field}' in payload \"\n                f\"for memory type '{memory_type}'\"\n            )\n\n        # Validate full payload against YAML schema\n        validated_payload = self.validate_memory_against_yaml(memory_type, payload)\n\n        # Construct Memory with YAML-defined payload only\n        return Memory(\n            memory_type=memory_type,\n            payload=validated_payload,\n            user_id=user_id,\n        )\n\n    def get_entity_model(self, entity_name: str):\n        \"\"\"Get Pydantic model from TypeRegistry - NO REDUNDANCY.\"\"\"\n        return get_entity_model(entity_name)\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.schema","title":"<code>schema</code>  <code>property</code>","text":"<p>Get the loaded YAML schema, loading it if necessary.</p>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.__init__","title":"<code>__init__(yaml_path=None)</code>","text":"<p>Initialize YamlTranslator with YAML schema path.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_path</code> <code>str | None</code> <p>Path to YAML schema file. If None, uses MEMG_YAML_SCHEMA env var.</p> <code>None</code> <p>Raises:</p> Type Description <code>YamlTranslatorError</code> <p>If YAML path not provided or TypeRegistry initialization fails.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def __init__(self, yaml_path: str | None = None) -&gt; None:\n    \"\"\"Initialize YamlTranslator with YAML schema path.\n\n    Args:\n        yaml_path: Path to YAML schema file. If None, uses MEMG_YAML_SCHEMA env var.\n\n    Raises:\n        YamlTranslatorError: If YAML path not provided or TypeRegistry initialization fails.\n    \"\"\"\n    # Require explicit YAML path - no silent defaults\n    if yaml_path:\n        self.yaml_path = yaml_path\n    else:\n        env_path = os.getenv(\"MEMG_YAML_SCHEMA\")\n        if not env_path:\n            raise YamlTranslatorError(\n                \"YAML schema path required. Set MEMG_YAML_SCHEMA environment variable \"\n                \"or provide yaml_path parameter. No defaults allowed.\"\n            )\n        self.yaml_path = env_path\n\n    self._schema: dict[str, Any] | None = None\n    # NO model cache - TypeRegistry handles all caching\n\n    # Initialize TypeRegistry from YAML - crash early if invalid\n    try:\n        initialize_types_from_yaml(self.yaml_path)\n    except Exception as e:\n        raise YamlTranslatorError(f\"Failed to initialize TypeRegistry from YAML: {e}\") from e\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.build_anchor_text","title":"<code>build_anchor_text(memory)</code>","text":"<p>Build anchor text for embedding from YAML-defined anchor field.</p> <p>NO hardcoded field names - reads anchor field from YAML schema.</p> <p>Parameters:</p> Name Type Description Default <code>memory</code> <p>Memory object containing payload data.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Anchor text for embedding.</p> <p>Raises:</p> Type Description <code>YamlTranslatorError</code> <p>If anchor field is missing or invalid.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def build_anchor_text(self, memory) -&gt; str:\n    \"\"\"Build anchor text for embedding from YAML-defined anchor field.\n\n    NO hardcoded field names - reads anchor field from YAML schema.\n\n    Args:\n        memory: Memory object containing payload data.\n\n    Returns:\n        str: Anchor text for embedding.\n\n    Raises:\n        YamlTranslatorError: If anchor field is missing or invalid.\n    \"\"\"\n    mem_type = getattr(memory, \"memory_type\", None)\n    if not mem_type:\n        raise YamlTranslatorError(\n            \"Memory object missing 'memory_type' field\",\n            operation=\"build_anchor_text\",\n        )\n\n    # Get anchor field from YAML schema\n    anchor_field = self.get_anchor_field(mem_type)\n\n    # Try to get anchor text from the specified field\n    anchor_text = None\n\n    # First check if it's a core field on the Memory object\n    if hasattr(memory, anchor_field):\n        anchor_text = getattr(memory, anchor_field, None)\n    # Otherwise check in the payload\n    elif hasattr(memory, \"payload\") and isinstance(memory.payload, dict):\n        anchor_text = memory.payload.get(anchor_field)\n\n    if isinstance(anchor_text, str):\n        stripped_text = anchor_text.strip()\n        if stripped_text:\n            return stripped_text\n\n    # Anchor field missing, empty, or invalid\n    raise YamlTranslatorError(\n        f\"Anchor field '{anchor_field}' is missing, empty, or invalid \"\n        f\"for memory type '{mem_type}'\",\n        operation=\"build_anchor_text\",\n        context={\n            \"memory_type\": mem_type,\n            \"anchor_field\": anchor_field,\n            \"anchor_value\": anchor_text,\n        },\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.create_memory_from_yaml","title":"<code>create_memory_from_yaml(memory_type, payload, user_id)</code>","text":"<p>Create a Memory object from YAML-validated payload.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def create_memory_from_yaml(self, memory_type: str, payload: dict[str, Any], user_id: str):\n    \"\"\"Create a Memory object from YAML-validated payload.\"\"\"\n\n    # Get anchor field from YAML schema\n    anchor_field = self.get_anchor_field(memory_type)\n\n    # Extract anchor text from payload\n    anchor_text = payload.get(anchor_field)\n    if not anchor_text or not isinstance(anchor_text, str):\n        raise YamlTranslatorError(\n            f\"Missing or invalid anchor field '{anchor_field}' in payload \"\n            f\"for memory type '{memory_type}'\"\n        )\n\n    # Validate full payload against YAML schema\n    validated_payload = self.validate_memory_against_yaml(memory_type, payload)\n\n    # Construct Memory with YAML-defined payload only\n    return Memory(\n        memory_type=memory_type,\n        payload=validated_payload,\n        user_id=user_id,\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.debug_relation_map","title":"<code>debug_relation_map()</code>","text":"<p>Return a nested relation map for debugging/printing.</p> <p>Structure: {   source: {     target: [ {name, predicate, directed, description} ... ]   } }</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def debug_relation_map(self) -&gt; dict[str, dict[str, list[dict[str, Any]]]]:\n    \"\"\"Return a nested relation map for debugging/printing.\n\n    Structure:\n    {\n      source: {\n        target: [ {name, predicate, directed, description} ... ]\n      }\n    }\n    \"\"\"\n    out: dict[str, dict[str, list[dict[str, Any]]]] = {}\n    for source in self.get_entity_types():\n        specs = self.get_relations_for_source(source)\n        if not specs:\n            continue\n        if source not in out:\n            out[source] = {}\n        for spec in specs:\n            target = spec[\"target\"]\n            out[source].setdefault(target, [])\n            out[source][target].append(\n                {\n                    \"name\": spec.get(\"name\"),\n                    \"predicate\": spec.get(\"predicate\"),\n                    \"directed\": spec.get(\"directed\", True),\n                    \"description\": spec.get(\"description\"),\n                }\n            )\n    return out\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.get_anchor_field","title":"<code>get_anchor_field(entity_name)</code>","text":"<p>Get the anchor field name for the given entity type from YAML schema.</p> <p>Now reads from vector.anchored_to instead of separate anchor field.</p> <p>Parameters:</p> Name Type Description Default <code>entity_name</code> <code>str</code> <p>Name of the entity type.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Anchor field name.</p> <p>Raises:</p> Type Description <code>YamlTranslatorError</code> <p>If anchor field not found.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_anchor_field(self, entity_name: str) -&gt; str:\n    \"\"\"Get the anchor field name for the given entity type from YAML schema.\n\n    Now reads from vector.anchored_to instead of separate anchor field.\n\n    Args:\n        entity_name: Name of the entity type.\n\n    Returns:\n        str: Anchor field name.\n\n    Raises:\n        YamlTranslatorError: If anchor field not found.\n    \"\"\"\n    if not entity_name:\n        raise YamlTranslatorError(\"Empty entity name\")\n\n    # Get entity spec with inheritance resolution\n    entity_spec = self._resolve_entity_with_inheritance(entity_name)\n\n    # Look for vector field with anchored_to\n    fields = entity_spec.get(\"fields\", {})\n    for _field_name, field_def in fields.items():\n        if isinstance(field_def, dict) and field_def.get(\"type\") == \"vector\":\n            anchored_to = field_def.get(\"anchored_to\")\n            if anchored_to:\n                return str(anchored_to)\n\n    raise YamlTranslatorError(\n        f\"Entity '{entity_name}' has no vector field with 'anchored_to' property\"\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.get_entity_model","title":"<code>get_entity_model(entity_name)</code>","text":"<p>Get Pydantic model from TypeRegistry - NO REDUNDANCY.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_entity_model(self, entity_name: str):\n    \"\"\"Get Pydantic model from TypeRegistry - NO REDUNDANCY.\"\"\"\n    return get_entity_model(entity_name)\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.get_entity_types","title":"<code>get_entity_types()</code>","text":"<p>Get list of available entity types from YAML schema.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_entity_types(self) -&gt; list[str]:\n    \"\"\"Get list of available entity types from YAML schema.\"\"\"\n    return list(self._entities_map().keys())\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.get_labels_for_predicates","title":"<code>get_labels_for_predicates(source_type, predicates, neighbor_label=None)</code>","text":"<p>Expand predicate names to concrete relationship labels for a given source.</p> <p>Parameters:</p> Name Type Description Default <code>source_type</code> <code>str</code> <p>Source entity type name</p> required <code>predicates</code> <code>list[str] | None</code> <p>List of predicate names to include (case-insensitive). If None, include all.</p> required <code>neighbor_label</code> <code>str | None</code> <p>Optional target entity type filter (case-insensitive)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of concrete relationship labels (table names) matching the filter.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_labels_for_predicates(\n    self,\n    source_type: str,\n    predicates: list[str] | None,\n    neighbor_label: str | None = None,\n) -&gt; list[str]:\n    \"\"\"Expand predicate names to concrete relationship labels for a given source.\n\n    Args:\n        source_type: Source entity type name\n        predicates: List of predicate names to include (case-insensitive). If None, include all.\n        neighbor_label: Optional target entity type filter (case-insensitive)\n\n    Returns:\n        List of concrete relationship labels (table names) matching the filter.\n    \"\"\"\n    if not source_type:\n        raise YamlTranslatorError(\"Empty source_type\")\n\n    preds_u = set(p.upper() for p in predicates) if predicates else None\n    neighbor_l = neighbor_label.lower() if neighbor_label else None\n\n    labels: list[str] = []\n    for spec in self.get_relations_for_source(source_type):\n        if preds_u is not None and spec[\"predicate\"].upper() not in preds_u:\n            continue\n        if neighbor_l is not None and spec[\"target\"].lower() != neighbor_l:\n            continue\n        labels.append(\n            self.relationship_table_name(\n                source=spec[\"source\"],\n                predicate=spec[\"predicate\"],\n                target=spec[\"target\"],\n                directed=spec[\"directed\"],\n            )\n        )\n    return labels\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.get_relations_for_source","title":"<code>get_relations_for_source(entity_name)</code>","text":"<p>Get normalized relation specs for a source entity in target-first schema.</p> Returns list of dicts with keys <ul> <li>source (str)</li> <li>target (str)</li> <li>name (str | None)</li> <li>description (str | None)</li> <li>predicate (str)</li> <li>directed (bool)</li> </ul> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_relations_for_source(self, entity_name: str) -&gt; list[dict[str, Any]]:\n    \"\"\"Get normalized relation specs for a source entity in target-first schema.\n\n    Returns list of dicts with keys:\n        - source (str)\n        - target (str)\n        - name (str | None)\n        - description (str | None)\n        - predicate (str)\n        - directed (bool)\n    \"\"\"\n    if not entity_name:\n        raise YamlTranslatorError(\"Empty entity name\")\n\n    source_l = entity_name.lower()\n    relations_map = self._get_relations_mapping_for_entity(source_l)\n    if not relations_map:\n        return []\n\n    out: list[dict[str, Any]] = []\n    for target_l, items in relations_map.items():\n        for item in items:\n            predicate = item.get(\"predicate\")\n            if not predicate or not isinstance(predicate, str):\n                # Skip invalid entries - strict behavior can be added later\n                continue\n            directed = bool(item.get(\"directed\", True))\n            out.append(\n                {\n                    \"source\": source_l,\n                    \"target\": target_l,\n                    \"name\": item.get(\"name\"),\n                    \"description\": item.get(\"description\"),\n                    \"predicate\": predicate.upper(),\n                    \"directed\": directed,\n                }\n            )\n    return out\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.get_see_also_config","title":"<code>get_see_also_config(entity_name)</code>","text":"<p>Get the see_also configuration for the given entity type from YAML schema.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dict with keys: enabled, threshold, limit, target_types</p> <code>dict[str, Any] | None</code> <p>None if see_also is not configured for this entity</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_see_also_config(self, entity_name: str) -&gt; dict[str, Any] | None:\n    \"\"\"Get the see_also configuration for the given entity type from YAML schema.\n\n    Returns:\n        Dict with keys: enabled, threshold, limit, target_types\n        None if see_also is not configured for this entity\n    \"\"\"\n    if not entity_name:\n        raise YamlTranslatorError(\"Empty entity name\")\n    name_l = entity_name.lower()\n    emap = self._entities_map()\n    spec_raw = emap.get(name_l)\n    if not spec_raw:\n        raise YamlTranslatorError(f\"Entity '{entity_name}' not found in YAML schema\")\n\n    see_also = spec_raw.get(\"see_also\")\n    if not see_also or not isinstance(see_also, dict):\n        return None\n\n    # Validate required fields\n    if not see_also.get(\"enabled\", False):\n        return None\n\n    return {\n        \"enabled\": see_also.get(\"enabled\", False),\n        \"threshold\": float(see_also.get(\"threshold\", 0.7)),\n        \"limit\": int(see_also.get(\"limit\", 3)),\n        \"target_types\": list(see_also.get(\"target_types\", [])),\n    }\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.relationship_table_name","title":"<code>relationship_table_name(source, predicate, target, *, directed=True)</code>  <code>staticmethod</code>","text":"<p>Generate relationship table name.</p> <p>For now, table name does not encode direction; direction affects creation/query semantics. Canonicalization for undirected pairs can be added here later if decided.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>@staticmethod\ndef relationship_table_name(\n    source: str,\n    predicate: str,\n    target: str,\n    *,\n    directed: bool = True,  # noqa: unused-argument\n) -&gt; str:\n    \"\"\"Generate relationship table name.\n\n    For now, table name does not encode direction; direction affects creation/query semantics.\n    Canonicalization for undirected pairs can be added here later if decided.\n    \"\"\"\n    return f\"{str(source).upper()}_{str(predicate).upper()}_{str(target).upper()}\"\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslator.validate_memory_against_yaml","title":"<code>validate_memory_against_yaml(memory_type, payload)</code>","text":"<p>Validate memory payload against YAML schema and return cleaned payload.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def validate_memory_against_yaml(\n    self, memory_type: str, payload: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Validate memory payload against YAML schema and return cleaned payload.\"\"\"\n    if not memory_type:\n        raise YamlTranslatorError(\"memory_type is required\")\n    if payload is None:\n        raise YamlTranslatorError(\"payload is required\")\n\n    # Strict validation - entity type MUST exist in YAML\n    emap = self._entities_map()\n    spec = emap.get(memory_type.lower())\n    if not spec:\n        raise YamlTranslatorError(\n            f\"Unknown entity type '{memory_type}'. All types must be defined in YAML schema.\",\n            context={\n                \"memory_type\": memory_type,\n                \"available_types\": list(emap.keys()),\n            },\n        )\n\n    req, _opt = self._fields_contract(spec)\n    missing = [k for k in req if not payload.get(k)]\n    if missing:\n        raise YamlTranslatorError(\n            f\"Missing required fields: {missing}\",\n            context={\"memory_type\": memory_type},\n        )\n\n    # Validate enum fields against YAML schema choices\n    self._validate_enum_fields(memory_type, payload)\n\n    # Validate that all fields are defined in YAML schema\n    req, opt = self._fields_contract(spec)\n    valid_fields = set(req + opt)\n    system_fields = self._get_system_fields(spec)\n    invalid_fields = set(payload.keys()) - valid_fields - system_fields\n    if invalid_fields:\n        raise YamlTranslatorError(\n            f\"Invalid fields not defined in schema: {sorted(invalid_fields)}\",\n            context={\n                \"memory_type\": memory_type,\n                \"valid_fields\": sorted(valid_fields),\n                \"invalid_fields\": sorted(invalid_fields),\n            },\n        )\n\n    # Strip system-reserved fields if present\n    cleaned = dict(payload)\n    for syskey in system_fields:\n        cleaned.pop(syskey, None)\n    return cleaned\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.YamlTranslatorError","title":"<code>YamlTranslatorError</code>","text":"<p>               Bases: <code>MemorySystemError</code></p> <p>Error in YAML schema translation or validation.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>Error message.</p> <code>operation</code> <p>Operation that caused the error.</p> <code>context</code> <p>Additional context information.</p> <code>original_error</code> <p>Original exception that was wrapped.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>class YamlTranslatorError(MemorySystemError):\n    \"\"\"Error in YAML schema translation or validation.\n\n    Attributes:\n        message: Error message.\n        operation: Operation that caused the error.\n        context: Additional context information.\n        original_error: Original exception that was wrapped.\n    \"\"\"\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.get_entity_model","title":"<code>get_entity_model(entity_name)</code>","text":"<p>Get Pydantic model for entity from global registry.</p> <p>Parameters:</p> Name Type Description Default <code>entity_name</code> <code>str</code> <p>Name of the entity.</p> required <p>Returns:</p> Type Description <code>type[BaseModel]</code> <p>type[BaseModel]: Pydantic model class.</p> Source code in <code>src/memg_core/core/types.py</code> <pre><code>def get_entity_model(entity_name: str) -&gt; type[BaseModel]:\n    \"\"\"Get Pydantic model for entity from global registry.\n\n    Args:\n        entity_name: Name of the entity.\n\n    Returns:\n        type[BaseModel]: Pydantic model class.\n    \"\"\"\n    return TypeRegistry.get_instance().get_entity_model(entity_name)\n</code></pre>"},{"location":"reference/api/#memg_core.core.yaml_translator.initialize_types_from_yaml","title":"<code>initialize_types_from_yaml(yaml_path)</code>","text":"<p>Initialize global type registry from YAML - call once at startup.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_path</code> <code>str</code> <p>Path to YAML schema file.</p> required Source code in <code>src/memg_core/core/types.py</code> <pre><code>def initialize_types_from_yaml(yaml_path: str) -&gt; None:\n    \"\"\"Initialize global type registry from YAML - call once at startup.\n\n    Args:\n        yaml_path: Path to YAML schema file.\n    \"\"\"\n    TypeRegistry.initialize_from_yaml(yaml_path)\n</code></pre>"},{"location":"reference/api/#utilities","title":"Utilities","text":""},{"location":"reference/api/#hrid-management","title":"HRID Management","text":"<p>Human-readable ID utilities:</p> <p>HRID generator and parser for MEMG Core.</p> <p>Format: {TYPE_UPPER}_{AAA000} - TYPE: uppercase alphanumeric type name (no spaces) - AAA: base26 letters A\u2013Z (wraps after ZZZ) - 000\u2013999: numeric suffix</p> <p>HRID Tracker: UUID \u2194 HRID translation and lifecycle management.</p> <p>Handles all HRID mapping operations using the existing KuzuInterface. Provides transparent translation between user-facing HRIDs and internal UUIDs.</p>"},{"location":"reference/api/#memg_core.utils.hrid._COUNTERS","title":"<code>_COUNTERS = {}</code>  <code>module-attribute</code>","text":""},{"location":"reference/api/#memg_core.utils.hrid._HRID_RE","title":"<code>_HRID_RE = re.compile('^(?P&lt;type&gt;[A-Z0-9_]+)_(?P&lt;alpha&gt;[A-Z]{3})(?P&lt;num&gt;\\\\d{3})$')</code>  <code>module-attribute</code>","text":""},{"location":"reference/api/#memg_core.utils.hrid.DatabaseError","title":"<code>DatabaseError</code>","text":"<p>               Bases: <code>MemorySystemError</code></p> <p>Database operation failures (Qdrant, Kuzu).</p> Source code in <code>src/memg_core/core/exceptions.py</code> <pre><code>class DatabaseError(MemorySystemError):\n    \"\"\"Database operation failures (Qdrant, Kuzu).\"\"\"\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid._alpha_to_idx","title":"<code>_alpha_to_idx(alpha)</code>","text":"<p>Convert alpha string to index: AAA -&gt; 0, AAB -&gt; 1, ..., ZZZ -&gt; 17575.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>str</code> <p>Three-letter alpha string (AAA-ZZZ).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Numeric index.</p> Source code in <code>src/memg_core/utils/hrid.py</code> <pre><code>def _alpha_to_idx(alpha: str) -&gt; int:\n    \"\"\"Convert alpha string to index: AAA -&gt; 0, AAB -&gt; 1, ..., ZZZ -&gt; 17575.\n\n    Args:\n        alpha: Three-letter alpha string (AAA-ZZZ).\n\n    Returns:\n        int: Numeric index.\n    \"\"\"\n    idx = 0\n    for char in alpha:\n        idx = idx * 26 + (ord(char) - ord(\"A\"))\n    return idx\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid._idx_to_alpha","title":"<code>_idx_to_alpha(idx)</code>","text":"<p>Convert index to alpha string: 0 -&gt; AAA, 1 -&gt; AAB, ..., 17575 -&gt; ZZZ.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Numeric index (0-17575).</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Three-letter alpha string.</p> Source code in <code>src/memg_core/utils/hrid.py</code> <pre><code>def _idx_to_alpha(idx: int) -&gt; str:\n    \"\"\"Convert index to alpha string: 0 -&gt; AAA, 1 -&gt; AAB, ..., 17575 -&gt; ZZZ.\n\n    Args:\n        idx: Numeric index (0-17575).\n\n    Returns:\n        str: Three-letter alpha string.\n    \"\"\"\n    chars = []\n    for _ in range(3):\n        chars.append(chr(ord(\"A\") + idx % 26))\n        idx //= 26\n    return \"\".join(reversed(chars))\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid._initialize_counter_from_tracker","title":"<code>_initialize_counter_from_tracker(type_name, user_id, hrid_tracker)</code>","text":"<p>Initialize counter by querying HridTracker for highest existing HRID.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>The memory type to check (e.g., 'note', 'task')</p> required <code>user_id</code> <code>str</code> <p>User ID for scoped HRID lookup</p> required <code>hrid_tracker</code> <p>HridTracker instance to query</p> required <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: (alpha_idx, num) representing the next available counter position</p> Source code in <code>src/memg_core/utils/hrid.py</code> <pre><code>def _initialize_counter_from_tracker(type_name: str, user_id: str, hrid_tracker) -&gt; tuple[int, int]:\n    \"\"\"Initialize counter by querying HridTracker for highest existing HRID.\n\n    Args:\n        type_name: The memory type to check (e.g., 'note', 'task')\n        user_id: User ID for scoped HRID lookup\n        hrid_tracker: HridTracker instance to query\n\n    Returns:\n        tuple[int, int]: (alpha_idx, num) representing the next available counter position\n    \"\"\"\n    try:\n        highest = hrid_tracker.get_highest_hrid(type_name, user_id)\n\n        if highest is None:\n            return (0, -1)  # No existing HRIDs for this type\n\n        _highest_hrid, highest_alpha_idx, highest_num = highest\n\n        # Return the next position after the highest found\n        next_num = highest_num + 1\n        if next_num &gt; 999:\n            next_num = 0\n            highest_alpha_idx += 1\n\n        return (\n            highest_alpha_idx,\n            next_num - 1,\n        )  # -1 because generate_hrid will increment\n\n    except Exception as e:\n        # DO NOT FALL BACK SILENTLY - this causes duplicate HRID bugs!\n        # If we can't initialize from existing data, the system should fail fast\n        raise DatabaseError(\n            f\"Failed to initialize HRID counter for type '{type_name}' from existing data. \"\n            f\"This is critical - cannot generate HRIDs without knowing existing ones.\",\n            operation=\"initialize_counter_from_tracker\",\n            context={\"type_name\": type_name},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid.generate_hrid","title":"<code>generate_hrid(type_name, user_id, hrid_tracker=None)</code>","text":"<p>Generate the next HRID for the given type.</p> <p>Parameters:</p> Name Type Description Default <code>type_name</code> <code>str</code> <p>The memory type (e.g., 'note', 'task').</p> required <code>user_id</code> <code>str</code> <p>User ID for scoped HRID generation.</p> required <code>hrid_tracker</code> <p>Optional HridTracker instance for querying existing HRIDs.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The next HRID in format TYPE_AAA000.</p> Notes <ul> <li>Uses HridTracker to query HridMapping table for existing HRIDs.</li> <li>Falls back to in-memory counter if no tracker provided.</li> <li>Ensures no duplicates by checking complete HRID history.</li> </ul> Source code in <code>src/memg_core/utils/hrid.py</code> <pre><code>def generate_hrid(type_name: str, user_id: str, hrid_tracker=None) -&gt; str:\n    \"\"\"Generate the next HRID for the given type.\n\n    Args:\n        type_name: The memory type (e.g., 'note', 'task').\n        user_id: User ID for scoped HRID generation.\n        hrid_tracker: Optional HridTracker instance for querying existing HRIDs.\n\n    Returns:\n        str: The next HRID in format TYPE_AAA000.\n\n    Notes:\n        - Uses HridTracker to query HridMapping table for existing HRIDs.\n        - Falls back to in-memory counter if no tracker provided.\n        - Ensures no duplicates by checking complete HRID history.\n    \"\"\"\n    t = type_name.strip().upper()\n\n    # Initialize counter from HridTracker on first use of this type+user combination\n    counter_key = (t, user_id)\n    if counter_key not in _COUNTERS and hrid_tracker is not None:\n        _COUNTERS[counter_key] = _initialize_counter_from_tracker(t, user_id, hrid_tracker)\n\n    # Get current counter or default to fresh start\n    alpha_idx, num = _COUNTERS.get(counter_key, (0, -1))\n    num += 1\n    if num &gt; 999:\n        num = 0\n        alpha_idx += 1\n        if alpha_idx &gt; 26**3 - 1:\n            raise ValueError(f\"HRID space exhausted for type {t}\")\n    _COUNTERS[counter_key] = (alpha_idx, num)\n    return f\"{t}_{_idx_to_alpha(alpha_idx)}{num:03d}\"\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid.parse_hrid","title":"<code>parse_hrid(hrid)</code>","text":"<p>Parse HRID into (type, alpha, num).</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>HRID string to parse.</p> required <p>Returns:</p> Type Description <code>tuple[str, str, int]</code> <p>tuple[str, str, int]: (type, alpha, num) components.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If HRID format is invalid.</p> Source code in <code>src/memg_core/utils/hrid.py</code> <pre><code>def parse_hrid(hrid: str) -&gt; tuple[str, str, int]:\n    \"\"\"Parse HRID into (type, alpha, num).\n\n    Args:\n        hrid: HRID string to parse.\n\n    Returns:\n        tuple[str, str, int]: (type, alpha, num) components.\n\n    Raises:\n        ValueError: If HRID format is invalid.\n    \"\"\"\n    m = _HRID_RE.match(hrid.strip().upper())\n    if not m:\n        raise ValueError(f\"Invalid HRID format: {hrid}\")\n    return m.group(\"type\"), m.group(\"alpha\"), int(m.group(\"num\"))\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.DatabaseError","title":"<code>DatabaseError</code>","text":"<p>               Bases: <code>MemorySystemError</code></p> <p>Database operation failures (Qdrant, Kuzu).</p> Source code in <code>src/memg_core/core/exceptions.py</code> <pre><code>class DatabaseError(MemorySystemError):\n    \"\"\"Database operation failures (Qdrant, Kuzu).\"\"\"\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.HridTracker","title":"<code>HridTracker</code>","text":"<p>Manages HRID \u2194 UUID mappings using KuzuInterface.</p> <p>Attributes:</p> Name Type Description <code>kuzu</code> <p>Pre-configured Kuzu interface for database operations.</p> Source code in <code>src/memg_core/utils/hrid_tracker.py</code> <pre><code>class HridTracker:\n    \"\"\"Manages HRID \u2194 UUID mappings using KuzuInterface.\n\n    Attributes:\n        kuzu: Pre-configured Kuzu interface for database operations.\n    \"\"\"\n\n    def __init__(self, kuzu_interface: KuzuInterface):\n        \"\"\"Initialize with existing KuzuInterface.\n\n        Args:\n            kuzu_interface: Pre-configured Kuzu interface for database operations.\n        \"\"\"\n        self.kuzu = kuzu_interface\n\n    def get_uuid(self, hrid: str, user_id: str) -&gt; str:\n        \"\"\"Translate HRID to UUID.\n\n        Args:\n            hrid: Human-readable ID (e.g., 'TASK_AAA001').\n            user_id: User ID for scoped lookup.\n\n        Returns:\n            str: UUID string for internal operations.\n\n        Raises:\n            DatabaseError: If HRID not found or is deleted.\n        \"\"\"\n        try:\n            query = \"\"\"\n            MATCH (m:HridMapping {hrid: $hrid, user_id: $user_id})\n            WHERE m.deleted_at IS NULL\n            RETURN m.uuid as uuid\n            \"\"\"\n            results = self.kuzu.query(query, {\"hrid\": hrid, \"user_id\": user_id})\n\n            if not results:\n                raise DatabaseError(\n                    f\"HRID '{hrid}' not found or has been deleted\",\n                    operation=\"get_uuid\",\n                    context={\"hrid\": hrid},\n                )\n\n            return results[0][\"uuid\"]\n\n        except Exception as e:\n            if isinstance(e, DatabaseError):\n                raise\n            raise DatabaseError(\n                f\"Failed to lookup UUID for HRID '{hrid}'\",\n                operation=\"get_uuid\",\n                context={\"hrid\": hrid},\n                original_error=e,\n            ) from e\n\n    def get_hrid(self, uuid: str, user_id: str) -&gt; str:\n        \"\"\"Translate UUID to HRID with user verification.\n\n        Args:\n            uuid: Internal UUID.\n            user_id: User ID for ownership verification.\n\n        Returns:\n            str: Human-readable ID string.\n\n        Raises:\n            DatabaseError: If UUID not found, deleted, or doesn't belong to user.\n        \"\"\"\n        try:\n            query = \"\"\"\n            MATCH (m:HridMapping {uuid: $uuid, user_id: $user_id})\n            WHERE m.deleted_at IS NULL\n            RETURN m.hrid as hrid\n            \"\"\"\n            results = self.kuzu.query(query, {\"uuid\": uuid, \"user_id\": user_id})\n\n            if not results:\n                raise DatabaseError(\n                    f\"UUID '{uuid}' not found or has been deleted\",\n                    operation=\"get_hrid\",\n                    context={\"uuid\": uuid},\n                )\n\n            return results[0][\"hrid\"]\n\n        except Exception as e:\n            if isinstance(e, DatabaseError):\n                raise\n            raise DatabaseError(\n                f\"Failed to lookup HRID for UUID '{uuid}'\",\n                operation=\"get_hrid\",\n                context={\"uuid\": uuid},\n                original_error=e,\n            ) from e\n\n    def create_mapping(self, hrid: str, uuid: str, memory_type: str, user_id: str) -&gt; None:\n        \"\"\"Create new HRID \u2194 UUID mapping.\n\n        Args:\n            hrid: Human-readable ID.\n            uuid: Internal UUID.\n            memory_type: Entity type (e.g., 'task', 'note').\n            user_id: User ID for scoped mapping.\n\n        Raises:\n            DatabaseError: If mapping creation fails.\n        \"\"\"\n        try:\n            now = datetime.now(UTC).isoformat()\n\n            mapping_data = {\n                \"hrid_user_key\": f\"{hrid}#{user_id}\",  # Composite key\n                \"hrid\": hrid,\n                \"uuid\": uuid,\n                \"memory_type\": memory_type,\n                \"user_id\": user_id,\n                \"created_at\": now,\n                \"deleted_at\": None,  # NULL for active mappings\n            }\n\n            self.kuzu.add_node(\"HridMapping\", mapping_data)\n\n        except Exception as e:\n            raise DatabaseError(\n                f\"Failed to create HRID mapping: {hrid} \u2192 {uuid}\",\n                operation=\"create_mapping\",\n                context={\"hrid\": hrid, \"uuid\": uuid, \"memory_type\": memory_type},\n                original_error=e,\n            ) from e\n\n    def mark_deleted(self, hrid: str) -&gt; None:\n        \"\"\"Mark HRID mapping as deleted (soft delete)\n\n        Args:\n            hrid: Human-readable ID to mark as deleted\n\n        Raises:\n            DatabaseError: If marking as deleted fails\n        \"\"\"\n        try:\n            now = datetime.now(UTC).isoformat()\n\n            query = \"\"\"\n            MATCH (m:HridMapping {hrid: $hrid})\n            SET m.deleted_at = $deleted_at\n            RETURN m.hrid as hrid\n            \"\"\"\n\n            results = self.kuzu.query(query, {\"hrid\": hrid, \"deleted_at\": now})\n\n            if not results:\n                raise DatabaseError(\n                    f\"HRID '{hrid}' not found for deletion\",\n                    operation=\"mark_deleted\",\n                    context={\"hrid\": hrid},\n                )\n\n        except Exception as e:\n            if isinstance(e, DatabaseError):\n                raise\n            raise DatabaseError(\n                f\"Failed to mark HRID '{hrid}' as deleted\",\n                operation=\"mark_deleted\",\n                context={\"hrid\": hrid},\n                original_error=e,\n            ) from e\n\n    def get_highest_hrid(self, memory_type: str, user_id: str) -&gt; tuple[str, int, int] | None:\n        \"\"\"Get highest HRID for a memory type (for generation).\n\n        Args:\n            memory_type: Entity type to check (case insensitive).\n            user_id: User ID for scoped HRID lookup.\n\n        Returns:\n            tuple[str, int, int] | None: (hrid, alpha_idx, num) or None if no HRIDs exist.\n        \"\"\"\n        try:\n            # Normalize to lowercase for database query (YAML types are lowercase)\n            normalized_type = memory_type.lower()\n\n            query = \"\"\"\n            MATCH (m:HridMapping {memory_type: $memory_type, user_id: $user_id})\n            RETURN m.hrid as hrid\n            ORDER BY m.created_at DESC\n            LIMIT 1000\n            \"\"\"\n\n            results = self.kuzu.query(query, {\"memory_type\": normalized_type, \"user_id\": user_id})\n\n            if not results:\n                return None\n\n            # Find the highest HRID by parsing all results\n            highest_hrid = None\n            highest_alpha_idx = -1\n            highest_num = -1\n\n            for result in results:\n                hrid = result[\"hrid\"]\n                try:\n                    # TODO: parsed_type available for future use (e.g., type validation)\n                    _, alpha, num = parse_hrid(hrid)\n                    alpha_idx = _alpha_to_idx(alpha)\n\n                    if alpha_idx &gt; highest_alpha_idx or (\n                        alpha_idx == highest_alpha_idx and num &gt; highest_num\n                    ):\n                        highest_alpha_idx = alpha_idx\n                        highest_num = num\n                        highest_hrid = hrid\n\n                except ValueError:\n                    continue  # Skip invalid HRIDs\n\n            if highest_hrid is None:\n                return None\n\n            return (highest_hrid, highest_alpha_idx, highest_num)\n\n        except Exception as e:\n            raise DatabaseError(\n                f\"Failed to get highest HRID for type '{memory_type}' and user '{user_id}'\",\n                operation=\"get_highest_hrid\",\n                context={\"memory_type\": memory_type, \"user_id\": user_id},\n                original_error=e,\n            ) from e\n\n    def exists(self, hrid: str) -&gt; bool:\n        \"\"\"Check if HRID exists (active, not deleted).\n\n        Args:\n            hrid: Human-readable ID to check.\n\n        Returns:\n            bool: True if HRID exists and is active.\n        \"\"\"\n        try:\n            query = \"\"\"\n            MATCH (m:HridMapping {hrid: $hrid})\n            WHERE m.deleted_at IS NULL\n            RETURN COUNT(m) as count\n            \"\"\"\n            results = self.kuzu.query(query, {\"hrid\": hrid})\n            return results[0][\"count\"] &gt; 0 if results else False\n\n        except (DatabaseError, ValueError, KeyError):\n            return False  # Assume doesn't exist on any error\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.HridTracker.__init__","title":"<code>__init__(kuzu_interface)</code>","text":"<p>Initialize with existing KuzuInterface.</p> <p>Parameters:</p> Name Type Description Default <code>kuzu_interface</code> <code>KuzuInterface</code> <p>Pre-configured Kuzu interface for database operations.</p> required Source code in <code>src/memg_core/utils/hrid_tracker.py</code> <pre><code>def __init__(self, kuzu_interface: KuzuInterface):\n    \"\"\"Initialize with existing KuzuInterface.\n\n    Args:\n        kuzu_interface: Pre-configured Kuzu interface for database operations.\n    \"\"\"\n    self.kuzu = kuzu_interface\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.HridTracker.create_mapping","title":"<code>create_mapping(hrid, uuid, memory_type, user_id)</code>","text":"<p>Create new HRID \u2194 UUID mapping.</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>Human-readable ID.</p> required <code>uuid</code> <code>str</code> <p>Internal UUID.</p> required <code>memory_type</code> <code>str</code> <p>Entity type (e.g., 'task', 'note').</p> required <code>user_id</code> <code>str</code> <p>User ID for scoped mapping.</p> required <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If mapping creation fails.</p> Source code in <code>src/memg_core/utils/hrid_tracker.py</code> <pre><code>def create_mapping(self, hrid: str, uuid: str, memory_type: str, user_id: str) -&gt; None:\n    \"\"\"Create new HRID \u2194 UUID mapping.\n\n    Args:\n        hrid: Human-readable ID.\n        uuid: Internal UUID.\n        memory_type: Entity type (e.g., 'task', 'note').\n        user_id: User ID for scoped mapping.\n\n    Raises:\n        DatabaseError: If mapping creation fails.\n    \"\"\"\n    try:\n        now = datetime.now(UTC).isoformat()\n\n        mapping_data = {\n            \"hrid_user_key\": f\"{hrid}#{user_id}\",  # Composite key\n            \"hrid\": hrid,\n            \"uuid\": uuid,\n            \"memory_type\": memory_type,\n            \"user_id\": user_id,\n            \"created_at\": now,\n            \"deleted_at\": None,  # NULL for active mappings\n        }\n\n        self.kuzu.add_node(\"HridMapping\", mapping_data)\n\n    except Exception as e:\n        raise DatabaseError(\n            f\"Failed to create HRID mapping: {hrid} \u2192 {uuid}\",\n            operation=\"create_mapping\",\n            context={\"hrid\": hrid, \"uuid\": uuid, \"memory_type\": memory_type},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.HridTracker.exists","title":"<code>exists(hrid)</code>","text":"<p>Check if HRID exists (active, not deleted).</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>Human-readable ID to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if HRID exists and is active.</p> Source code in <code>src/memg_core/utils/hrid_tracker.py</code> <pre><code>def exists(self, hrid: str) -&gt; bool:\n    \"\"\"Check if HRID exists (active, not deleted).\n\n    Args:\n        hrid: Human-readable ID to check.\n\n    Returns:\n        bool: True if HRID exists and is active.\n    \"\"\"\n    try:\n        query = \"\"\"\n        MATCH (m:HridMapping {hrid: $hrid})\n        WHERE m.deleted_at IS NULL\n        RETURN COUNT(m) as count\n        \"\"\"\n        results = self.kuzu.query(query, {\"hrid\": hrid})\n        return results[0][\"count\"] &gt; 0 if results else False\n\n    except (DatabaseError, ValueError, KeyError):\n        return False  # Assume doesn't exist on any error\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.HridTracker.get_highest_hrid","title":"<code>get_highest_hrid(memory_type, user_id)</code>","text":"<p>Get highest HRID for a memory type (for generation).</p> <p>Parameters:</p> Name Type Description Default <code>memory_type</code> <code>str</code> <p>Entity type to check (case insensitive).</p> required <code>user_id</code> <code>str</code> <p>User ID for scoped HRID lookup.</p> required <p>Returns:</p> Type Description <code>tuple[str, int, int] | None</code> <p>tuple[str, int, int] | None: (hrid, alpha_idx, num) or None if no HRIDs exist.</p> Source code in <code>src/memg_core/utils/hrid_tracker.py</code> <pre><code>def get_highest_hrid(self, memory_type: str, user_id: str) -&gt; tuple[str, int, int] | None:\n    \"\"\"Get highest HRID for a memory type (for generation).\n\n    Args:\n        memory_type: Entity type to check (case insensitive).\n        user_id: User ID for scoped HRID lookup.\n\n    Returns:\n        tuple[str, int, int] | None: (hrid, alpha_idx, num) or None if no HRIDs exist.\n    \"\"\"\n    try:\n        # Normalize to lowercase for database query (YAML types are lowercase)\n        normalized_type = memory_type.lower()\n\n        query = \"\"\"\n        MATCH (m:HridMapping {memory_type: $memory_type, user_id: $user_id})\n        RETURN m.hrid as hrid\n        ORDER BY m.created_at DESC\n        LIMIT 1000\n        \"\"\"\n\n        results = self.kuzu.query(query, {\"memory_type\": normalized_type, \"user_id\": user_id})\n\n        if not results:\n            return None\n\n        # Find the highest HRID by parsing all results\n        highest_hrid = None\n        highest_alpha_idx = -1\n        highest_num = -1\n\n        for result in results:\n            hrid = result[\"hrid\"]\n            try:\n                # TODO: parsed_type available for future use (e.g., type validation)\n                _, alpha, num = parse_hrid(hrid)\n                alpha_idx = _alpha_to_idx(alpha)\n\n                if alpha_idx &gt; highest_alpha_idx or (\n                    alpha_idx == highest_alpha_idx and num &gt; highest_num\n                ):\n                    highest_alpha_idx = alpha_idx\n                    highest_num = num\n                    highest_hrid = hrid\n\n            except ValueError:\n                continue  # Skip invalid HRIDs\n\n        if highest_hrid is None:\n            return None\n\n        return (highest_hrid, highest_alpha_idx, highest_num)\n\n    except Exception as e:\n        raise DatabaseError(\n            f\"Failed to get highest HRID for type '{memory_type}' and user '{user_id}'\",\n            operation=\"get_highest_hrid\",\n            context={\"memory_type\": memory_type, \"user_id\": user_id},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.HridTracker.get_hrid","title":"<code>get_hrid(uuid, user_id)</code>","text":"<p>Translate UUID to HRID with user verification.</p> <p>Parameters:</p> Name Type Description Default <code>uuid</code> <code>str</code> <p>Internal UUID.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Human-readable ID string.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If UUID not found, deleted, or doesn't belong to user.</p> Source code in <code>src/memg_core/utils/hrid_tracker.py</code> <pre><code>def get_hrid(self, uuid: str, user_id: str) -&gt; str:\n    \"\"\"Translate UUID to HRID with user verification.\n\n    Args:\n        uuid: Internal UUID.\n        user_id: User ID for ownership verification.\n\n    Returns:\n        str: Human-readable ID string.\n\n    Raises:\n        DatabaseError: If UUID not found, deleted, or doesn't belong to user.\n    \"\"\"\n    try:\n        query = \"\"\"\n        MATCH (m:HridMapping {uuid: $uuid, user_id: $user_id})\n        WHERE m.deleted_at IS NULL\n        RETURN m.hrid as hrid\n        \"\"\"\n        results = self.kuzu.query(query, {\"uuid\": uuid, \"user_id\": user_id})\n\n        if not results:\n            raise DatabaseError(\n                f\"UUID '{uuid}' not found or has been deleted\",\n                operation=\"get_hrid\",\n                context={\"uuid\": uuid},\n            )\n\n        return results[0][\"hrid\"]\n\n    except Exception as e:\n        if isinstance(e, DatabaseError):\n            raise\n        raise DatabaseError(\n            f\"Failed to lookup HRID for UUID '{uuid}'\",\n            operation=\"get_hrid\",\n            context={\"uuid\": uuid},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.HridTracker.get_uuid","title":"<code>get_uuid(hrid, user_id)</code>","text":"<p>Translate HRID to UUID.</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>Human-readable ID (e.g., 'TASK_AAA001').</p> required <code>user_id</code> <code>str</code> <p>User ID for scoped lookup.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>UUID string for internal operations.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If HRID not found or is deleted.</p> Source code in <code>src/memg_core/utils/hrid_tracker.py</code> <pre><code>def get_uuid(self, hrid: str, user_id: str) -&gt; str:\n    \"\"\"Translate HRID to UUID.\n\n    Args:\n        hrid: Human-readable ID (e.g., 'TASK_AAA001').\n        user_id: User ID for scoped lookup.\n\n    Returns:\n        str: UUID string for internal operations.\n\n    Raises:\n        DatabaseError: If HRID not found or is deleted.\n    \"\"\"\n    try:\n        query = \"\"\"\n        MATCH (m:HridMapping {hrid: $hrid, user_id: $user_id})\n        WHERE m.deleted_at IS NULL\n        RETURN m.uuid as uuid\n        \"\"\"\n        results = self.kuzu.query(query, {\"hrid\": hrid, \"user_id\": user_id})\n\n        if not results:\n            raise DatabaseError(\n                f\"HRID '{hrid}' not found or has been deleted\",\n                operation=\"get_uuid\",\n                context={\"hrid\": hrid},\n            )\n\n        return results[0][\"uuid\"]\n\n    except Exception as e:\n        if isinstance(e, DatabaseError):\n            raise\n        raise DatabaseError(\n            f\"Failed to lookup UUID for HRID '{hrid}'\",\n            operation=\"get_uuid\",\n            context={\"hrid\": hrid},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.HridTracker.mark_deleted","title":"<code>mark_deleted(hrid)</code>","text":"<p>Mark HRID mapping as deleted (soft delete)</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>Human-readable ID to mark as deleted</p> required <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If marking as deleted fails</p> Source code in <code>src/memg_core/utils/hrid_tracker.py</code> <pre><code>def mark_deleted(self, hrid: str) -&gt; None:\n    \"\"\"Mark HRID mapping as deleted (soft delete)\n\n    Args:\n        hrid: Human-readable ID to mark as deleted\n\n    Raises:\n        DatabaseError: If marking as deleted fails\n    \"\"\"\n    try:\n        now = datetime.now(UTC).isoformat()\n\n        query = \"\"\"\n        MATCH (m:HridMapping {hrid: $hrid})\n        SET m.deleted_at = $deleted_at\n        RETURN m.hrid as hrid\n        \"\"\"\n\n        results = self.kuzu.query(query, {\"hrid\": hrid, \"deleted_at\": now})\n\n        if not results:\n            raise DatabaseError(\n                f\"HRID '{hrid}' not found for deletion\",\n                operation=\"mark_deleted\",\n                context={\"hrid\": hrid},\n            )\n\n    except Exception as e:\n        if isinstance(e, DatabaseError):\n            raise\n        raise DatabaseError(\n            f\"Failed to mark HRID '{hrid}' as deleted\",\n            operation=\"mark_deleted\",\n            context={\"hrid\": hrid},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.KuzuInterface","title":"<code>KuzuInterface</code>","text":"<p>Pure CRUD wrapper around Kuzu database - NO DDL operations.</p> <p>Attributes:</p> Name Type Description <code>conn</code> <p>Pre-initialized Kuzu connection.</p> <code>yaml_translator</code> <p>Optional YAML translator for relationship operations.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>class KuzuInterface:\n    \"\"\"Pure CRUD wrapper around Kuzu database - NO DDL operations.\n\n    Attributes:\n        conn: Pre-initialized Kuzu connection.\n        yaml_translator: Optional YAML translator for relationship operations.\n    \"\"\"\n\n    def __init__(self, connection: kuzu.Connection, yaml_translator=None):\n        \"\"\"Initialize with pre-created connection.\n\n        Args:\n            connection: Pre-initialized Kuzu connection from DatabaseClients.\n            yaml_translator: Optional YamlTranslator for relationship operations.\n        \"\"\"\n        self.conn = connection\n        self.yaml_translator = yaml_translator\n\n    def add_node(self, table: str, properties: dict[str, Any]) -&gt; None:\n        \"\"\"Add a node to the graph - pure CRUD operation.\n\n        Args:\n            table: Node table name.\n            properties: Node properties.\n\n        Raises:\n            DatabaseError: If node creation fails.\n        \"\"\"\n        try:\n            props = \", \".join([f\"{k}: ${k}\" for k in properties])\n            query = f\"CREATE (:{table} {{{props}}})\"\n            self.conn.execute(query, parameters=properties)\n        except Exception as e:\n            raise DatabaseError(\n                f\"Failed to add node to {table}\",\n                operation=\"add_node\",\n                context={\"table\": table, \"properties\": properties},\n                original_error=e,\n            ) from e\n\n    def update_node(\n        self, table: str, node_uuid: str, properties: dict[str, Any], user_id: str\n    ) -&gt; bool:\n        \"\"\"Update a node in the graph - pure CRUD operation.\n\n        Args:\n            table: Node table name.\n            node_uuid: UUID of the node to update.\n            properties: Node properties to update.\n            user_id: User ID for ownership verification.\n\n        Returns:\n            bool: True if update succeeded, False if node not found.\n\n        Raises:\n            DatabaseError: If node update fails due to system error.\n        \"\"\"\n        try:\n            # CRITICAL: Check if node exists AND belongs to user\n            check_query = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) RETURN n.id as id\"\n            check_result = self.query(check_query, {\"uuid\": node_uuid, \"user_id\": user_id})\n\n            if not check_result:\n                # Node doesn't exist for this user\n                return False\n\n            # Build SET clause for properties\n            set_clauses = []\n            params = {\"uuid\": node_uuid, \"user_id\": user_id}\n\n            for key, value in properties.items():\n                # Skip system fields that shouldn't be updated via this method\n                if key in (\"id\", \"user_id\"):\n                    continue\n\n                param_name = f\"prop_{key}\"\n                set_clauses.append(f\"n.{key} = ${param_name}\")\n                params[param_name] = value\n\n            if not set_clauses:\n                # No properties to update (all were system fields)\n                return True\n\n            # Execute update query\n            set_clause = \", \".join(set_clauses)\n            update_query = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) SET {set_clause}\"\n            self.conn.execute(update_query, parameters=params)\n\n            return True\n\n        except Exception as e:\n            raise DatabaseError(\n                f\"Failed to update node in {table}\",\n                operation=\"update_node\",\n                context={\n                    \"table\": table,\n                    \"node_uuid\": node_uuid,\n                    \"properties\": properties,\n                    \"user_id\": user_id,\n                },\n                original_error=e,\n            ) from e\n\n    def add_relationship(\n        self,\n        from_table: str,\n        to_table: str,\n        rel_type: str,\n        from_id: str,\n        to_id: str,\n        user_id: str,\n        props: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Add relationship between nodes.\n\n        Args:\n            from_table: Source node table name.\n            to_table: Target node table name.\n            rel_type: Relationship type.\n            from_id: Source node ID.\n            to_id: Target node ID.\n            user_id: User ID for ownership verification.\n            props: Optional relationship properties.\n\n        Raises:\n            DatabaseError: If relationship creation fails.\n        \"\"\"\n        try:\n            props = props or {}\n\n            # VALIDATE RELATIONSHIP AGAINST YAML SCHEMA - crash if invalid\n            if not validate_relation_predicate(rel_type):\n                raise ValueError(\n                    f\"Invalid relationship predicate: {rel_type}. Must be defined in YAML schema.\"\n                )\n\n            # Use relationship type as-is (predicates from YAML) - no sanitization\n            # rel_type should already be a valid predicate (e.g., \"REFERENCED_BY\", \"ANNOTATES\")\n\n            # CRITICAL: Verify both nodes belong to the user before creating relationship\n            # First check if both nodes exist and belong to the user\n            check_query = (\n                f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}}), \"\n                f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n                f\"RETURN a.id, b.id\"\n            )\n            check_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n            check_result = self.query(check_query, check_params)\n\n            if not check_result:\n                raise ValueError(\n                    f\"Cannot create relationship: one or both memories not found \"\n                    f\"or don't belong to user {user_id}\"\n                )\n\n            # Generate relationship table name using YamlTranslator\n            if not self.yaml_translator:\n                raise DatabaseError(\n                    \"YamlTranslator required for relationship operations\",\n                    operation=\"add_relationship\",\n                    context={\n                        \"from_table\": from_table,\n                        \"to_table\": to_table,\n                        \"rel_type\": rel_type,\n                    },\n                )\n\n            relationship_table_name = self.yaml_translator.relationship_table_name(\n                source=from_table,\n                predicate=rel_type,\n                target=to_table,\n                directed=True,  # Direction affects semantics but not table naming for now\n            )\n\n            # Now create the relationship using the unique table name\n            prop_str = \", \".join([f\"{k}: ${k}\" for k in props.keys()]) if props else \"\"\n            rel_props = f\" {{{prop_str}}}\" if prop_str else \"\"\n            create_query = (\n                f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}}), \"\n                f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n                f\"CREATE (a)-[:{relationship_table_name}{rel_props}]-&gt;(b)\"\n            )\n            create_params = {\n                \"from_id\": from_id,\n                \"to_id\": to_id,\n                \"user_id\": user_id,\n                **props,\n            }\n            self.conn.execute(create_query, parameters=create_params)\n        except Exception as e:\n            raise DatabaseError(\n                f\"Failed to add relationship {rel_type}\",\n                operation=\"add_relationship\",\n                context={\n                    \"from_table\": from_table,\n                    \"to_table\": to_table,\n                    \"rel_type\": rel_type,\n                    \"from_id\": from_id,\n                    \"to_id\": to_id,\n                },\n                original_error=e,\n            ) from e\n\n    def delete_relationship(\n        self,\n        from_table: str,\n        to_table: str,\n        rel_type: str,\n        from_id: str,\n        to_id: str,\n        user_id: str,\n    ) -&gt; bool:\n        \"\"\"Delete relationship between nodes.\n\n        Args:\n            from_table: Source node table name.\n            to_table: Target node table name.\n            rel_type: Relationship type.\n            from_id: Source node ID.\n            to_id: Target node ID.\n            user_id: User ID for ownership verification.\n\n        Returns:\n            bool: True if deletion succeeded, False if relationship not found.\n\n        Raises:\n            DatabaseError: If relationship deletion fails due to system error.\n        \"\"\"\n        try:\n            # VALIDATE RELATIONSHIP AGAINST YAML SCHEMA - crash if invalid\n            if not validate_relation_predicate(rel_type):\n                raise ValueError(\n                    f\"Invalid relationship predicate: {rel_type}. Must be defined in YAML schema.\"\n                )\n\n            # CRITICAL: Verify both nodes belong to the user before deleting relationship\n            # First check if both nodes exist and belong to the user\n            check_query = (\n                f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}}), \"\n                f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n                f\"RETURN a.id, b.id\"\n            )\n            check_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n            check_result = self.query(check_query, check_params)\n\n            if not check_result:\n                # Nodes don't exist or don't belong to user - return False (not found)\n                return False\n\n            # Generate relationship table name using YamlTranslator\n            if not self.yaml_translator:\n                raise DatabaseError(\n                    \"YamlTranslator required for relationship operations\",\n                    operation=\"delete_relationship\",\n                    context={\n                        \"from_table\": from_table,\n                        \"to_table\": to_table,\n                        \"rel_type\": rel_type,\n                    },\n                )\n\n            relationship_table_name = self.yaml_translator.relationship_table_name(\n                source=from_table,\n                predicate=rel_type,\n                target=to_table,\n                directed=True,  # Direction affects semantics but not table naming for now\n            )\n\n            # First check if the relationship exists\n            check_rel_query = (\n                f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}})\"\n                f\"-[r:{relationship_table_name}]-&gt;\"\n                f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n                f\"RETURN r\"\n            )\n            check_rel_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n\n            # Check if relationship exists\n            relationship_exists = self.query(check_rel_query, check_rel_params)\n            if not relationship_exists:\n                # Relationship doesn't exist - return False\n                return False\n\n            # Delete the specific relationship (we know it exists)\n            delete_query = (\n                f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}})\"\n                f\"-[r:{relationship_table_name}]-&gt;\"\n                f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n                f\"DELETE r\"\n            )\n            delete_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n\n            # Execute deletion\n            self.conn.execute(delete_query, parameters=delete_params)\n\n            # If we get here, deletion succeeded\n            return True\n\n        except Exception as e:\n            if isinstance(e, ValueError):\n                # Re-raise validation errors as-is\n                raise\n            raise DatabaseError(\n                f\"Failed to delete relationship {rel_type}\",\n                operation=\"delete_relationship\",\n                context={\n                    \"from_table\": from_table,\n                    \"to_table\": to_table,\n                    \"rel_type\": rel_type,\n                    \"from_id\": from_id,\n                    \"to_id\": to_id,\n                },\n                original_error=e,\n            ) from e\n\n    def _extract_query_results(self, query_result) -&gt; list[dict[str, Any]]:\n        \"\"\"Extract results from Kuzu QueryResult using raw iteration.\n\n        Args:\n            query_result: Kuzu QueryResult object.\n\n        Returns:\n            list[dict[str, Any]]: List of dictionaries containing query results.\n        \"\"\"\n        # Type annotations disabled for QueryResult - dynamic interface from kuzu package\n        qr = query_result  # type: ignore\n\n        results = []\n        column_names = qr.get_column_names()\n        while qr.has_next():\n            row = qr.get_next()\n            result = {}\n            for i, col_name in enumerate(column_names):\n                result[col_name] = row[i] if i &lt; len(row) else None\n            results.append(result)\n        return results\n\n    def query(self, cypher: str, params: dict[str, Any] | None = None) -&gt; list[dict[str, Any]]:\n        \"\"\"Execute Cypher query and return results.\n\n        Args:\n            cypher: Cypher query string.\n            params: Query parameters.\n\n        Returns:\n            list[dict[str, Any]]: Query results.\n\n        Raises:\n            DatabaseError: If query execution fails.\n        \"\"\"\n        try:\n            qr = self.conn.execute(cypher, parameters=params or {})\n            return self._extract_query_results(qr)\n        except Exception as e:\n            raise DatabaseError(\n                \"Failed to execute Kuzu query\",\n                operation=\"query\",\n                context={\"cypher\": cypher, \"params\": params},\n                original_error=e,\n            ) from e\n\n    def neighbors(\n        self,\n        node_label: str,\n        node_uuid: str,\n        user_id: str,\n        rel_types: list[str] | None = None,\n        direction: str = \"any\",\n        limit: int = 10,\n        neighbor_label: str | None = None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Fetch neighbors of a node by UUID only.\n\n        Args:\n            node_label: Node type/table name (e.g., \"Memory\", \"bug\") - NOT a UUID.\n            node_uuid: UUID of the specific node to find neighbors for.\n            user_id: User ID for isolation - only return neighbors belonging to this user.\n            rel_types: List of relationship types to filter by.\n            direction: \"in\", \"out\", or \"any\" for relationship direction.\n            limit: Maximum number of neighbors to return.\n            neighbor_label: Type of neighbor nodes to return.\n\n        Returns:\n            list[dict[str, Any]]: List of neighbor nodes with relationship info.\n\n        Raises:\n            ValueError: If node_label is a UUID or node_uuid is not a UUID.\n            DatabaseError: If neighbor query fails.\n        \"\"\"\n        # Validate parameters to prevent common bugs\n        if self._is_uuid(node_label):\n            raise ValueError(\n                f\"node_label must be a node type (e.g., 'Memory', 'bug'), not UUID: {node_label}. \"\n                f\"UUIDs should be passed as node_uuid parameter.\"\n            )\n\n        if not self._is_uuid(node_uuid):\n            raise ValueError(f\"node_uuid must be a valid UUID format, got: {node_uuid}\")\n\n        try:\n            # Use YamlTranslator to expand predicates to concrete relationship labels\n            if not self.yaml_translator:\n                raise DatabaseError(\n                    \"YamlTranslator required for neighbor operations\",\n                    operation=\"neighbors\",\n                    context={\"node_label\": node_label, \"rel_types\": rel_types},\n                )\n\n            # Get concrete relationship labels for this source and predicates\n            if rel_types:\n                relationship_labels = self.yaml_translator.get_labels_for_predicates(\n                    source_type=node_label,\n                    predicates=rel_types,\n                    neighbor_label=neighbor_label,\n                )\n                if not relationship_labels:\n                    # No matching relationships found - return empty\n                    return []\n\n                # Create relationship pattern with specific labels\n                rel_filter = \"|\".join(relationship_labels)\n                rel_part = f\":{rel_filter}\"\n            else:\n                # No filtering - match all relationships\n                rel_part = \"\"\n\n            # CRITICAL: User isolation - both source node and neighbors must belong to user\n            node_condition = f\"a:{node_label} {{id: $node_uuid, user_id: $user_id}}\"\n            neighbor = f\":{neighbor_label}\" if neighbor_label else \"\"\n            neighbor_condition = f\"n{neighbor} {{user_id: $user_id}}\"\n\n            # Build direction-aware pattern\n            if direction == \"out\":\n                pattern = f\"({node_condition})-[r{rel_part}]-&gt;({neighbor_condition})\"\n            elif direction == \"in\":\n                pattern = f\"({node_condition})&lt;-[r{rel_part}]-({neighbor_condition})\"\n            else:\n                pattern = f\"({node_condition})-[r{rel_part}]-({neighbor_condition})\"\n\n            # Return neighbors only if they belong to the same user\n            cypher = f\"\"\"\n            MATCH {pattern}\n            RETURN DISTINCT n.id as id,\n                            n.user_id as user_id,\n                            n.memory_type as memory_type,\n                            n.created_at as created_at,\n                            label(r) as rel_type,\n                            n as node\n            LIMIT $limit\n            \"\"\"\n            params = {\"node_uuid\": node_uuid, \"user_id\": user_id, \"limit\": limit}\n            return self.query(cypher, params)\n        except Exception as e:\n            raise DatabaseError(\n                \"Failed to fetch neighbors\",\n                operation=\"neighbors\",\n                context={\n                    \"node_label\": node_label,\n                    \"node_uuid\": node_uuid,\n                    \"user_id\": user_id,\n                    \"rel_types\": rel_types,\n                    \"direction\": direction,\n                },\n                original_error=e,\n            ) from e\n\n    def delete_node(self, table: str, node_uuid: str, user_id: str) -&gt; bool:\n        \"\"\"Delete a single node by UUID\"\"\"\n        try:\n            # CRITICAL: Check if node exists AND belongs to user\n            cypher_check = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) RETURN n.id as id\"\n            check_result = self.query(cypher_check, {\"uuid\": node_uuid, \"user_id\": user_id})\n\n            if not check_result:\n                # Node doesn't exist for this user, consider it successfully \"deleted\"\n                return True\n\n            # Delete the node - only if it belongs to the user\n            cypher_delete_node = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) DELETE n\"\n            self.conn.execute(\n                cypher_delete_node, parameters={\"uuid\": node_uuid, \"user_id\": user_id}\n            )\n            return True\n\n        except Exception as e:\n            error_msg = str(e).lower()\n            if \"delete undirected rel\" in error_msg or \"relationship\" in error_msg:\n                # Relationship constraint prevents deletion - this is a REAL FAILURE\n                # Don't lie by returning True - raise explicit error\n                raise DatabaseError(\n                    f\"Cannot delete node {node_uuid} from {table}: has existing relationships. \"\n                    f\"Delete relationships first or use CASCADE delete if supported.\",\n                    operation=\"delete_node\",\n                    context={\n                        \"table\": table,\n                        \"node_uuid\": node_uuid,\n                        \"constraint_error\": str(e),\n                    },\n                    original_error=e,\n                ) from e\n            # Other database error\n            raise DatabaseError(\n                f\"Failed to delete node from {table}\",\n                operation=\"delete_node\",\n                context={\"table\": table, \"node_uuid\": node_uuid, \"user_id\": user_id},\n                original_error=e,\n            ) from e\n\n    def get_nodes(\n        self,\n        user_id: str,\n        node_type: str | None = None,\n        filters: dict[str, Any] | None = None,\n        limit: int = 50,\n        offset: int = 0,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Get multiple nodes with filtering and pagination.\n\n        Args:\n            user_id: User ID for ownership verification.\n            node_type: Optional node type filter (e.g., \"task\", \"note\").\n            filters: Optional field filters (e.g., {\"status\": \"open\"}).\n            limit: Maximum number of nodes to return.\n            offset: Number of nodes to skip for pagination.\n\n        Returns:\n            list[dict[str, Any]]: List of node data from Kuzu.\n\n        Raises:\n            DatabaseError: If node retrieval fails.\n        \"\"\"\n        try:\n            filters = filters or {}\n\n            # Build MATCH clause\n            if node_type:\n                match_clause = f\"MATCH (n:{node_type} {{user_id: $user_id\"\n            else:\n                match_clause = \"MATCH (n {user_id: $user_id\"\n\n            # Add field filters\n            params = {\"user_id\": user_id, \"limit\": limit, \"offset\": offset}\n            for field_name, field_value in filters.items():\n                param_name = f\"filter_{field_name}\"\n                match_clause += f\", {field_name}: ${param_name}\"\n                params[param_name] = field_value\n\n            match_clause += \"})\"\n\n            # Build complete query\n            cypher_query = f\"\"\"\n            {match_clause}\n            RETURN n.id as id,\n                   n.user_id as user_id,\n                   n.memory_type as memory_type,\n                   n.created_at as created_at,\n                   n.updated_at as updated_at,\n                   n as node\n            ORDER BY n.created_at DESC\n            SKIP $offset\n            LIMIT $limit\n            \"\"\"\n\n            return self.query(cypher_query, params)\n\n        except Exception as e:\n            raise DatabaseError(\n                \"Failed to get nodes from Kuzu\",\n                operation=\"get_nodes\",\n                context={\n                    \"user_id\": user_id,\n                    \"node_type\": node_type,\n                    \"filters\": filters,\n                    \"limit\": limit,\n                    \"offset\": offset,\n                },\n                original_error=e,\n            ) from e\n\n    def _get_kuzu_type(self, key: str, value: Any) -&gt; str:\n        \"\"\"Map Python types to Kuzu types with proper validation.\n\n        Args:\n            key: Property key name.\n            value: Property value to type-check.\n\n        Returns:\n            str: Kuzu type name.\n\n        Raises:\n            DatabaseError: If the Python type is not supported by Kuzu.\n        \"\"\"\n        if isinstance(value, bool):\n            # Check bool first (bool is subclass of int in Python!)\n            return \"BOOLEAN\"\n        if isinstance(value, int):\n            return \"INT64\"\n        if isinstance(value, float):\n            return \"DOUBLE\"\n        if isinstance(value, str):\n            return \"STRING\"\n        if value is None:\n            # None values need special handling - default to STRING for now\n            return \"STRING\"\n        # Unsupported type - fail explicitly instead of silent STRING conversion\n        raise DatabaseError(\n            f\"Unsupported property type for key '{key}': {type(value).__name__}. \"\n            f\"Supported types: str, int, float, bool. \"\n            f\"Complex types must be serialized before storage.\",\n            operation=\"_get_kuzu_type\",\n            context={\"key\": key, \"value\": value, \"type\": type(value).__name__},\n        )\n\n    def _is_uuid(self, value: str) -&gt; bool:\n        \"\"\"Check if string looks like a UUID (36 chars with hyphens in right positions).\n\n        Args:\n            value: String to check.\n\n        Returns:\n            bool: True if value matches UUID format (8-4-4-4-12 hex pattern), False otherwise.\n        \"\"\"\n        if not isinstance(value, str) or len(value) != 36:\n            return False\n\n        # UUID format: 8-4-4-4-12 (e.g., 550e8400-e29b-41d4-a716-446655440000)\n        uuid_pattern = r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\"\n        return bool(re.match(uuid_pattern, value, re.IGNORECASE))\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.KuzuInterface.__init__","title":"<code>__init__(connection, yaml_translator=None)</code>","text":"<p>Initialize with pre-created connection.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>Pre-initialized Kuzu connection from DatabaseClients.</p> required <code>yaml_translator</code> <p>Optional YamlTranslator for relationship operations.</p> <code>None</code> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def __init__(self, connection: kuzu.Connection, yaml_translator=None):\n    \"\"\"Initialize with pre-created connection.\n\n    Args:\n        connection: Pre-initialized Kuzu connection from DatabaseClients.\n        yaml_translator: Optional YamlTranslator for relationship operations.\n    \"\"\"\n    self.conn = connection\n    self.yaml_translator = yaml_translator\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.KuzuInterface.add_node","title":"<code>add_node(table, properties)</code>","text":"<p>Add a node to the graph - pure CRUD operation.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>Node table name.</p> required <code>properties</code> <code>dict[str, Any]</code> <p>Node properties.</p> required <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If node creation fails.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def add_node(self, table: str, properties: dict[str, Any]) -&gt; None:\n    \"\"\"Add a node to the graph - pure CRUD operation.\n\n    Args:\n        table: Node table name.\n        properties: Node properties.\n\n    Raises:\n        DatabaseError: If node creation fails.\n    \"\"\"\n    try:\n        props = \", \".join([f\"{k}: ${k}\" for k in properties])\n        query = f\"CREATE (:{table} {{{props}}})\"\n        self.conn.execute(query, parameters=properties)\n    except Exception as e:\n        raise DatabaseError(\n            f\"Failed to add node to {table}\",\n            operation=\"add_node\",\n            context={\"table\": table, \"properties\": properties},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.KuzuInterface.add_relationship","title":"<code>add_relationship(from_table, to_table, rel_type, from_id, to_id, user_id, props=None)</code>","text":"<p>Add relationship between nodes.</p> <p>Parameters:</p> Name Type Description Default <code>from_table</code> <code>str</code> <p>Source node table name.</p> required <code>to_table</code> <code>str</code> <p>Target node table name.</p> required <code>rel_type</code> <code>str</code> <p>Relationship type.</p> required <code>from_id</code> <code>str</code> <p>Source node ID.</p> required <code>to_id</code> <code>str</code> <p>Target node ID.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>props</code> <code>dict[str, Any] | None</code> <p>Optional relationship properties.</p> <code>None</code> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If relationship creation fails.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def add_relationship(\n    self,\n    from_table: str,\n    to_table: str,\n    rel_type: str,\n    from_id: str,\n    to_id: str,\n    user_id: str,\n    props: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Add relationship between nodes.\n\n    Args:\n        from_table: Source node table name.\n        to_table: Target node table name.\n        rel_type: Relationship type.\n        from_id: Source node ID.\n        to_id: Target node ID.\n        user_id: User ID for ownership verification.\n        props: Optional relationship properties.\n\n    Raises:\n        DatabaseError: If relationship creation fails.\n    \"\"\"\n    try:\n        props = props or {}\n\n        # VALIDATE RELATIONSHIP AGAINST YAML SCHEMA - crash if invalid\n        if not validate_relation_predicate(rel_type):\n            raise ValueError(\n                f\"Invalid relationship predicate: {rel_type}. Must be defined in YAML schema.\"\n            )\n\n        # Use relationship type as-is (predicates from YAML) - no sanitization\n        # rel_type should already be a valid predicate (e.g., \"REFERENCED_BY\", \"ANNOTATES\")\n\n        # CRITICAL: Verify both nodes belong to the user before creating relationship\n        # First check if both nodes exist and belong to the user\n        check_query = (\n            f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}}), \"\n            f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n            f\"RETURN a.id, b.id\"\n        )\n        check_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n        check_result = self.query(check_query, check_params)\n\n        if not check_result:\n            raise ValueError(\n                f\"Cannot create relationship: one or both memories not found \"\n                f\"or don't belong to user {user_id}\"\n            )\n\n        # Generate relationship table name using YamlTranslator\n        if not self.yaml_translator:\n            raise DatabaseError(\n                \"YamlTranslator required for relationship operations\",\n                operation=\"add_relationship\",\n                context={\n                    \"from_table\": from_table,\n                    \"to_table\": to_table,\n                    \"rel_type\": rel_type,\n                },\n            )\n\n        relationship_table_name = self.yaml_translator.relationship_table_name(\n            source=from_table,\n            predicate=rel_type,\n            target=to_table,\n            directed=True,  # Direction affects semantics but not table naming for now\n        )\n\n        # Now create the relationship using the unique table name\n        prop_str = \", \".join([f\"{k}: ${k}\" for k in props.keys()]) if props else \"\"\n        rel_props = f\" {{{prop_str}}}\" if prop_str else \"\"\n        create_query = (\n            f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}}), \"\n            f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n            f\"CREATE (a)-[:{relationship_table_name}{rel_props}]-&gt;(b)\"\n        )\n        create_params = {\n            \"from_id\": from_id,\n            \"to_id\": to_id,\n            \"user_id\": user_id,\n            **props,\n        }\n        self.conn.execute(create_query, parameters=create_params)\n    except Exception as e:\n        raise DatabaseError(\n            f\"Failed to add relationship {rel_type}\",\n            operation=\"add_relationship\",\n            context={\n                \"from_table\": from_table,\n                \"to_table\": to_table,\n                \"rel_type\": rel_type,\n                \"from_id\": from_id,\n                \"to_id\": to_id,\n            },\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.KuzuInterface.delete_node","title":"<code>delete_node(table, node_uuid, user_id)</code>","text":"<p>Delete a single node by UUID</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def delete_node(self, table: str, node_uuid: str, user_id: str) -&gt; bool:\n    \"\"\"Delete a single node by UUID\"\"\"\n    try:\n        # CRITICAL: Check if node exists AND belongs to user\n        cypher_check = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) RETURN n.id as id\"\n        check_result = self.query(cypher_check, {\"uuid\": node_uuid, \"user_id\": user_id})\n\n        if not check_result:\n            # Node doesn't exist for this user, consider it successfully \"deleted\"\n            return True\n\n        # Delete the node - only if it belongs to the user\n        cypher_delete_node = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) DELETE n\"\n        self.conn.execute(\n            cypher_delete_node, parameters={\"uuid\": node_uuid, \"user_id\": user_id}\n        )\n        return True\n\n    except Exception as e:\n        error_msg = str(e).lower()\n        if \"delete undirected rel\" in error_msg or \"relationship\" in error_msg:\n            # Relationship constraint prevents deletion - this is a REAL FAILURE\n            # Don't lie by returning True - raise explicit error\n            raise DatabaseError(\n                f\"Cannot delete node {node_uuid} from {table}: has existing relationships. \"\n                f\"Delete relationships first or use CASCADE delete if supported.\",\n                operation=\"delete_node\",\n                context={\n                    \"table\": table,\n                    \"node_uuid\": node_uuid,\n                    \"constraint_error\": str(e),\n                },\n                original_error=e,\n            ) from e\n        # Other database error\n        raise DatabaseError(\n            f\"Failed to delete node from {table}\",\n            operation=\"delete_node\",\n            context={\"table\": table, \"node_uuid\": node_uuid, \"user_id\": user_id},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.KuzuInterface.delete_relationship","title":"<code>delete_relationship(from_table, to_table, rel_type, from_id, to_id, user_id)</code>","text":"<p>Delete relationship between nodes.</p> <p>Parameters:</p> Name Type Description Default <code>from_table</code> <code>str</code> <p>Source node table name.</p> required <code>to_table</code> <code>str</code> <p>Target node table name.</p> required <code>rel_type</code> <code>str</code> <p>Relationship type.</p> required <code>from_id</code> <code>str</code> <p>Source node ID.</p> required <code>to_id</code> <code>str</code> <p>Target node ID.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if deletion succeeded, False if relationship not found.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If relationship deletion fails due to system error.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def delete_relationship(\n    self,\n    from_table: str,\n    to_table: str,\n    rel_type: str,\n    from_id: str,\n    to_id: str,\n    user_id: str,\n) -&gt; bool:\n    \"\"\"Delete relationship between nodes.\n\n    Args:\n        from_table: Source node table name.\n        to_table: Target node table name.\n        rel_type: Relationship type.\n        from_id: Source node ID.\n        to_id: Target node ID.\n        user_id: User ID for ownership verification.\n\n    Returns:\n        bool: True if deletion succeeded, False if relationship not found.\n\n    Raises:\n        DatabaseError: If relationship deletion fails due to system error.\n    \"\"\"\n    try:\n        # VALIDATE RELATIONSHIP AGAINST YAML SCHEMA - crash if invalid\n        if not validate_relation_predicate(rel_type):\n            raise ValueError(\n                f\"Invalid relationship predicate: {rel_type}. Must be defined in YAML schema.\"\n            )\n\n        # CRITICAL: Verify both nodes belong to the user before deleting relationship\n        # First check if both nodes exist and belong to the user\n        check_query = (\n            f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}}), \"\n            f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n            f\"RETURN a.id, b.id\"\n        )\n        check_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n        check_result = self.query(check_query, check_params)\n\n        if not check_result:\n            # Nodes don't exist or don't belong to user - return False (not found)\n            return False\n\n        # Generate relationship table name using YamlTranslator\n        if not self.yaml_translator:\n            raise DatabaseError(\n                \"YamlTranslator required for relationship operations\",\n                operation=\"delete_relationship\",\n                context={\n                    \"from_table\": from_table,\n                    \"to_table\": to_table,\n                    \"rel_type\": rel_type,\n                },\n            )\n\n        relationship_table_name = self.yaml_translator.relationship_table_name(\n            source=from_table,\n            predicate=rel_type,\n            target=to_table,\n            directed=True,  # Direction affects semantics but not table naming for now\n        )\n\n        # First check if the relationship exists\n        check_rel_query = (\n            f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}})\"\n            f\"-[r:{relationship_table_name}]-&gt;\"\n            f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n            f\"RETURN r\"\n        )\n        check_rel_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n\n        # Check if relationship exists\n        relationship_exists = self.query(check_rel_query, check_rel_params)\n        if not relationship_exists:\n            # Relationship doesn't exist - return False\n            return False\n\n        # Delete the specific relationship (we know it exists)\n        delete_query = (\n            f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}})\"\n            f\"-[r:{relationship_table_name}]-&gt;\"\n            f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n            f\"DELETE r\"\n        )\n        delete_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n\n        # Execute deletion\n        self.conn.execute(delete_query, parameters=delete_params)\n\n        # If we get here, deletion succeeded\n        return True\n\n    except Exception as e:\n        if isinstance(e, ValueError):\n            # Re-raise validation errors as-is\n            raise\n        raise DatabaseError(\n            f\"Failed to delete relationship {rel_type}\",\n            operation=\"delete_relationship\",\n            context={\n                \"from_table\": from_table,\n                \"to_table\": to_table,\n                \"rel_type\": rel_type,\n                \"from_id\": from_id,\n                \"to_id\": to_id,\n            },\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.KuzuInterface.get_nodes","title":"<code>get_nodes(user_id, node_type=None, filters=None, limit=50, offset=0)</code>","text":"<p>Get multiple nodes with filtering and pagination.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>node_type</code> <code>str | None</code> <p>Optional node type filter (e.g., \"task\", \"note\").</p> <code>None</code> <code>filters</code> <code>dict[str, Any] | None</code> <p>Optional field filters (e.g., {\"status\": \"open\"}).</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of nodes to return.</p> <code>50</code> <code>offset</code> <code>int</code> <p>Number of nodes to skip for pagination.</p> <code>0</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: List of node data from Kuzu.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If node retrieval fails.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def get_nodes(\n    self,\n    user_id: str,\n    node_type: str | None = None,\n    filters: dict[str, Any] | None = None,\n    limit: int = 50,\n    offset: int = 0,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Get multiple nodes with filtering and pagination.\n\n    Args:\n        user_id: User ID for ownership verification.\n        node_type: Optional node type filter (e.g., \"task\", \"note\").\n        filters: Optional field filters (e.g., {\"status\": \"open\"}).\n        limit: Maximum number of nodes to return.\n        offset: Number of nodes to skip for pagination.\n\n    Returns:\n        list[dict[str, Any]]: List of node data from Kuzu.\n\n    Raises:\n        DatabaseError: If node retrieval fails.\n    \"\"\"\n    try:\n        filters = filters or {}\n\n        # Build MATCH clause\n        if node_type:\n            match_clause = f\"MATCH (n:{node_type} {{user_id: $user_id\"\n        else:\n            match_clause = \"MATCH (n {user_id: $user_id\"\n\n        # Add field filters\n        params = {\"user_id\": user_id, \"limit\": limit, \"offset\": offset}\n        for field_name, field_value in filters.items():\n            param_name = f\"filter_{field_name}\"\n            match_clause += f\", {field_name}: ${param_name}\"\n            params[param_name] = field_value\n\n        match_clause += \"})\"\n\n        # Build complete query\n        cypher_query = f\"\"\"\n        {match_clause}\n        RETURN n.id as id,\n               n.user_id as user_id,\n               n.memory_type as memory_type,\n               n.created_at as created_at,\n               n.updated_at as updated_at,\n               n as node\n        ORDER BY n.created_at DESC\n        SKIP $offset\n        LIMIT $limit\n        \"\"\"\n\n        return self.query(cypher_query, params)\n\n    except Exception as e:\n        raise DatabaseError(\n            \"Failed to get nodes from Kuzu\",\n            operation=\"get_nodes\",\n            context={\n                \"user_id\": user_id,\n                \"node_type\": node_type,\n                \"filters\": filters,\n                \"limit\": limit,\n                \"offset\": offset,\n            },\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.KuzuInterface.neighbors","title":"<code>neighbors(node_label, node_uuid, user_id, rel_types=None, direction='any', limit=10, neighbor_label=None)</code>","text":"<p>Fetch neighbors of a node by UUID only.</p> <p>Parameters:</p> Name Type Description Default <code>node_label</code> <code>str</code> <p>Node type/table name (e.g., \"Memory\", \"bug\") - NOT a UUID.</p> required <code>node_uuid</code> <code>str</code> <p>UUID of the specific node to find neighbors for.</p> required <code>user_id</code> <code>str</code> <p>User ID for isolation - only return neighbors belonging to this user.</p> required <code>rel_types</code> <code>list[str] | None</code> <p>List of relationship types to filter by.</p> <code>None</code> <code>direction</code> <code>str</code> <p>\"in\", \"out\", or \"any\" for relationship direction.</p> <code>'any'</code> <code>limit</code> <code>int</code> <p>Maximum number of neighbors to return.</p> <code>10</code> <code>neighbor_label</code> <code>str | None</code> <p>Type of neighbor nodes to return.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: List of neighbor nodes with relationship info.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If node_label is a UUID or node_uuid is not a UUID.</p> <code>DatabaseError</code> <p>If neighbor query fails.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def neighbors(\n    self,\n    node_label: str,\n    node_uuid: str,\n    user_id: str,\n    rel_types: list[str] | None = None,\n    direction: str = \"any\",\n    limit: int = 10,\n    neighbor_label: str | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Fetch neighbors of a node by UUID only.\n\n    Args:\n        node_label: Node type/table name (e.g., \"Memory\", \"bug\") - NOT a UUID.\n        node_uuid: UUID of the specific node to find neighbors for.\n        user_id: User ID for isolation - only return neighbors belonging to this user.\n        rel_types: List of relationship types to filter by.\n        direction: \"in\", \"out\", or \"any\" for relationship direction.\n        limit: Maximum number of neighbors to return.\n        neighbor_label: Type of neighbor nodes to return.\n\n    Returns:\n        list[dict[str, Any]]: List of neighbor nodes with relationship info.\n\n    Raises:\n        ValueError: If node_label is a UUID or node_uuid is not a UUID.\n        DatabaseError: If neighbor query fails.\n    \"\"\"\n    # Validate parameters to prevent common bugs\n    if self._is_uuid(node_label):\n        raise ValueError(\n            f\"node_label must be a node type (e.g., 'Memory', 'bug'), not UUID: {node_label}. \"\n            f\"UUIDs should be passed as node_uuid parameter.\"\n        )\n\n    if not self._is_uuid(node_uuid):\n        raise ValueError(f\"node_uuid must be a valid UUID format, got: {node_uuid}\")\n\n    try:\n        # Use YamlTranslator to expand predicates to concrete relationship labels\n        if not self.yaml_translator:\n            raise DatabaseError(\n                \"YamlTranslator required for neighbor operations\",\n                operation=\"neighbors\",\n                context={\"node_label\": node_label, \"rel_types\": rel_types},\n            )\n\n        # Get concrete relationship labels for this source and predicates\n        if rel_types:\n            relationship_labels = self.yaml_translator.get_labels_for_predicates(\n                source_type=node_label,\n                predicates=rel_types,\n                neighbor_label=neighbor_label,\n            )\n            if not relationship_labels:\n                # No matching relationships found - return empty\n                return []\n\n            # Create relationship pattern with specific labels\n            rel_filter = \"|\".join(relationship_labels)\n            rel_part = f\":{rel_filter}\"\n        else:\n            # No filtering - match all relationships\n            rel_part = \"\"\n\n        # CRITICAL: User isolation - both source node and neighbors must belong to user\n        node_condition = f\"a:{node_label} {{id: $node_uuid, user_id: $user_id}}\"\n        neighbor = f\":{neighbor_label}\" if neighbor_label else \"\"\n        neighbor_condition = f\"n{neighbor} {{user_id: $user_id}}\"\n\n        # Build direction-aware pattern\n        if direction == \"out\":\n            pattern = f\"({node_condition})-[r{rel_part}]-&gt;({neighbor_condition})\"\n        elif direction == \"in\":\n            pattern = f\"({node_condition})&lt;-[r{rel_part}]-({neighbor_condition})\"\n        else:\n            pattern = f\"({node_condition})-[r{rel_part}]-({neighbor_condition})\"\n\n        # Return neighbors only if they belong to the same user\n        cypher = f\"\"\"\n        MATCH {pattern}\n        RETURN DISTINCT n.id as id,\n                        n.user_id as user_id,\n                        n.memory_type as memory_type,\n                        n.created_at as created_at,\n                        label(r) as rel_type,\n                        n as node\n        LIMIT $limit\n        \"\"\"\n        params = {\"node_uuid\": node_uuid, \"user_id\": user_id, \"limit\": limit}\n        return self.query(cypher, params)\n    except Exception as e:\n        raise DatabaseError(\n            \"Failed to fetch neighbors\",\n            operation=\"neighbors\",\n            context={\n                \"node_label\": node_label,\n                \"node_uuid\": node_uuid,\n                \"user_id\": user_id,\n                \"rel_types\": rel_types,\n                \"direction\": direction,\n            },\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.KuzuInterface.query","title":"<code>query(cypher, params=None)</code>","text":"<p>Execute Cypher query and return results.</p> <p>Parameters:</p> Name Type Description Default <code>cypher</code> <code>str</code> <p>Cypher query string.</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Query parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: Query results.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If query execution fails.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def query(self, cypher: str, params: dict[str, Any] | None = None) -&gt; list[dict[str, Any]]:\n    \"\"\"Execute Cypher query and return results.\n\n    Args:\n        cypher: Cypher query string.\n        params: Query parameters.\n\n    Returns:\n        list[dict[str, Any]]: Query results.\n\n    Raises:\n        DatabaseError: If query execution fails.\n    \"\"\"\n    try:\n        qr = self.conn.execute(cypher, parameters=params or {})\n        return self._extract_query_results(qr)\n    except Exception as e:\n        raise DatabaseError(\n            \"Failed to execute Kuzu query\",\n            operation=\"query\",\n            context={\"cypher\": cypher, \"params\": params},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.KuzuInterface.update_node","title":"<code>update_node(table, node_uuid, properties, user_id)</code>","text":"<p>Update a node in the graph - pure CRUD operation.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>Node table name.</p> required <code>node_uuid</code> <code>str</code> <p>UUID of the node to update.</p> required <code>properties</code> <code>dict[str, Any]</code> <p>Node properties to update.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if update succeeded, False if node not found.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If node update fails due to system error.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def update_node(\n    self, table: str, node_uuid: str, properties: dict[str, Any], user_id: str\n) -&gt; bool:\n    \"\"\"Update a node in the graph - pure CRUD operation.\n\n    Args:\n        table: Node table name.\n        node_uuid: UUID of the node to update.\n        properties: Node properties to update.\n        user_id: User ID for ownership verification.\n\n    Returns:\n        bool: True if update succeeded, False if node not found.\n\n    Raises:\n        DatabaseError: If node update fails due to system error.\n    \"\"\"\n    try:\n        # CRITICAL: Check if node exists AND belongs to user\n        check_query = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) RETURN n.id as id\"\n        check_result = self.query(check_query, {\"uuid\": node_uuid, \"user_id\": user_id})\n\n        if not check_result:\n            # Node doesn't exist for this user\n            return False\n\n        # Build SET clause for properties\n        set_clauses = []\n        params = {\"uuid\": node_uuid, \"user_id\": user_id}\n\n        for key, value in properties.items():\n            # Skip system fields that shouldn't be updated via this method\n            if key in (\"id\", \"user_id\"):\n                continue\n\n            param_name = f\"prop_{key}\"\n            set_clauses.append(f\"n.{key} = ${param_name}\")\n            params[param_name] = value\n\n        if not set_clauses:\n            # No properties to update (all were system fields)\n            return True\n\n        # Execute update query\n        set_clause = \", \".join(set_clauses)\n        update_query = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) SET {set_clause}\"\n        self.conn.execute(update_query, parameters=params)\n\n        return True\n\n    except Exception as e:\n        raise DatabaseError(\n            f\"Failed to update node in {table}\",\n            operation=\"update_node\",\n            context={\n                \"table\": table,\n                \"node_uuid\": node_uuid,\n                \"properties\": properties,\n                \"user_id\": user_id,\n            },\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker._alpha_to_idx","title":"<code>_alpha_to_idx(alpha)</code>","text":"<p>Convert alpha string to index: AAA -&gt; 0, AAB -&gt; 1, ..., ZZZ -&gt; 17575.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>str</code> <p>Three-letter alpha string (AAA-ZZZ).</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Numeric index.</p> Source code in <code>src/memg_core/utils/hrid.py</code> <pre><code>def _alpha_to_idx(alpha: str) -&gt; int:\n    \"\"\"Convert alpha string to index: AAA -&gt; 0, AAB -&gt; 1, ..., ZZZ -&gt; 17575.\n\n    Args:\n        alpha: Three-letter alpha string (AAA-ZZZ).\n\n    Returns:\n        int: Numeric index.\n    \"\"\"\n    idx = 0\n    for char in alpha:\n        idx = idx * 26 + (ord(char) - ord(\"A\"))\n    return idx\n</code></pre>"},{"location":"reference/api/#memg_core.utils.hrid_tracker.parse_hrid","title":"<code>parse_hrid(hrid)</code>","text":"<p>Parse HRID into (type, alpha, num).</p> <p>Parameters:</p> Name Type Description Default <code>hrid</code> <code>str</code> <p>HRID string to parse.</p> required <p>Returns:</p> Type Description <code>tuple[str, str, int]</code> <p>tuple[str, str, int]: (type, alpha, num) components.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If HRID format is invalid.</p> Source code in <code>src/memg_core/utils/hrid.py</code> <pre><code>def parse_hrid(hrid: str) -&gt; tuple[str, str, int]:\n    \"\"\"Parse HRID into (type, alpha, num).\n\n    Args:\n        hrid: HRID string to parse.\n\n    Returns:\n        tuple[str, str, int]: (type, alpha, num) components.\n\n    Raises:\n        ValueError: If HRID format is invalid.\n    \"\"\"\n    m = _HRID_RE.match(hrid.strip().upper())\n    if not m:\n        raise ValueError(f\"Invalid HRID format: {hrid}\")\n    return m.group(\"type\"), m.group(\"alpha\"), int(m.group(\"num\"))\n</code></pre>"},{"location":"reference/api/#database-clients","title":"Database Clients","text":"<p>Database client utilities:</p> <p>Database client management - thin layer for explicit database setup.</p> <p>User controls database paths. No fallbacks. No automation.</p>"},{"location":"reference/api/#memg_core.utils.db_clients.DatabaseClients","title":"<code>DatabaseClients</code>","text":"<p>DDL-only database setup - creates schemas and returns raw clients.</p> <p>NO INTERFACES - pure schema creation only. Consumer must create interfaces separately using returned raw clients.</p> <p>Attributes:</p> Name Type Description <code>qdrant_client</code> <code>QdrantClient | None</code> <p>Pre-initialized QdrantClient.</p> <code>kuzu_connection</code> <code>Connection | None</code> <p>Pre-initialized Kuzu connection.</p> <code>db_name</code> <p>Database name.</p> <code>qdrant_path</code> <p>Path to Qdrant database.</p> <code>kuzu_path</code> <p>Path to Kuzu database.</p> <code>yaml_translator</code> <p>YAML translator instance.</p> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>class DatabaseClients:\n    \"\"\"DDL-only database setup - creates schemas and returns raw clients.\n\n    NO INTERFACES - pure schema creation only.\n    Consumer must create interfaces separately using returned raw clients.\n\n    Attributes:\n        qdrant_client: Pre-initialized QdrantClient.\n        kuzu_connection: Pre-initialized Kuzu connection.\n        db_name: Database name.\n        qdrant_path: Path to Qdrant database.\n        kuzu_path: Path to Kuzu database.\n        yaml_translator: YAML translator instance.\n    \"\"\"\n\n    def __init__(self, yaml_path: str | None = None):\n        \"\"\"Create DDL-only database client wrapper.\n\n        Args:\n            yaml_path: Path to YAML schema file. User must provide - no defaults.\n        \"\"\"\n        self.qdrant_client: QdrantClient | None = None\n        self.kuzu_connection: kuzu.Connection | None = None\n        self.db_name = \"memg\"\n        self.qdrant_path = \"qdrant\"\n        self.kuzu_path = \"kuzu\"\n\n        self.yaml_translator = YamlTranslator(yaml_path) if yaml_path else None\n\n    def init_dbs(self, db_path: str, db_name: str):\n        \"\"\"Initialize databases with structured paths.\n\n        Args:\n            db_path: Base database directory.\n            db_name: Database name (used for collection and file names).\n        \"\"\"\n        # Structure paths\n        qdrant_path = os.path.join(db_path, \"qdrant\")\n        kuzu_path = os.path.join(db_path, \"kuzu\", db_name)\n\n        # Store paths and names\n        self.qdrant_path = qdrant_path\n        self.kuzu_path = kuzu_path\n        self.db_name = db_name\n\n        # Ensure directories exist\n        os.makedirs(qdrant_path, exist_ok=True)\n        os.makedirs(Path(kuzu_path).parent, exist_ok=True)\n\n        # Create raw database clients directly\n        qdrant_client = QdrantClient(path=qdrant_path)\n        kuzu_db = kuzu.Database(kuzu_path)\n        kuzu_conn = kuzu.Connection(kuzu_db)\n\n        # Store raw clients for interface creation\n        self.qdrant_client = qdrant_client\n        self.kuzu_connection = kuzu_conn\n\n        # DDL operations - create collection and tables\n        self._setup_qdrant_collection(qdrant_client, self.db_name)\n        self._setup_kuzu_tables_with_graph_register(kuzu_conn)\n\n    def _setup_qdrant_collection(self, client: QdrantClient, collection_name: str) -&gt; None:\n        \"\"\"Create Qdrant collection if it doesn't exist.\n\n        Args:\n            client: Qdrant client instance.\n            collection_name: Name of the collection to create.\n\n        Raises:\n            DatabaseError: If collection creation fails.\n        \"\"\"\n        try:\n            config = get_config()\n            vector_dimension = config.memg.vector_dimension\n\n            collections = client.get_collections()\n            if not any(col.name == collection_name for col in collections.collections):\n                client.create_collection(\n                    collection_name=collection_name,\n                    vectors_config=VectorParams(size=vector_dimension, distance=Distance.COSINE),\n                )\n        except Exception as e:\n            raise DatabaseError(\n                \"Failed to setup Qdrant collection\",\n                operation=\"_setup_qdrant_collection\",\n                original_error=e,\n            ) from e\n\n    def _setup_kuzu_tables_with_graph_register(self, conn: kuzu.Connection) -&gt; None:\n        \"\"\"Create Kuzu tables using GraphRegister for DDL generation.\n\n        Args:\n            conn: Kuzu database connection.\n\n        Raises:\n            DatabaseError: If YAML translator not initialized or table creation fails.\n        \"\"\"\n        if not self.yaml_translator:\n            raise DatabaseError(\n                \"YAML translator not initialized. Provide yaml_path to constructor.\",\n                operation=\"_setup_kuzu_tables_with_graph_register\",\n            )\n\n        try:\n            # Create GraphRegister with YamlTranslator for complete DDL generation\n            graph_register = GraphRegister(yaml_translator=self.yaml_translator)\n\n            # Generate all DDL statements using GraphRegister\n            ddl_statements = graph_register.generate_all_ddl()\n\n            # Execute all DDL statements\n            for ddl in ddl_statements:\n                conn.execute(ddl)\n\n        except Exception as e:\n            raise DatabaseError(\n                \"Failed to setup Kuzu tables using GraphRegister\",\n                operation=\"_setup_kuzu_tables_with_graph_register\",\n                original_error=e,\n            ) from e\n\n    # ===== INTERFACE ACCESS METHODS =====\n    # After DDL operations, provide access to CRUD interfaces\n\n    def get_qdrant_interface(self) -&gt; QdrantInterface:\n        \"\"\"Get Qdrant interface using the initialized client.\n\n        Returns:\n            QdrantInterface: Configured with the DDL-created client and collection.\n\n        Raises:\n            DatabaseError: If client not initialized (call init_dbs first).\n        \"\"\"\n        if self.qdrant_client is None:\n            raise DatabaseError(\n                \"Qdrant client not initialized. Call init_dbs() first.\",\n                operation=\"get_qdrant_interface\",\n            )\n        return QdrantInterface(self.qdrant_client, self.db_name)\n\n    def get_kuzu_interface(self) -&gt; KuzuInterface:\n        \"\"\"Get Kuzu interface using the initialized connection.\n\n        Returns:\n            KuzuInterface: Configured with the DDL-created connection.\n\n        Raises:\n            DatabaseError: If connection not initialized (call init_dbs first).\n        \"\"\"\n        if self.kuzu_connection is None:\n            raise DatabaseError(\n                \"Kuzu connection not initialized. Call init_dbs() first.\",\n                operation=\"get_kuzu_interface\",\n            )\n        return KuzuInterface(self.kuzu_connection, self.yaml_translator)\n\n    def get_embedder(self) -&gt; Embedder:\n        \"\"\"Get embedder instance.\n\n        Returns:\n            Embedder: Instance for generating vectors.\n        \"\"\"\n        return Embedder()\n\n    def get_yaml_translator(self) -&gt; YamlTranslator:\n        \"\"\"Get the YAML translator used for schema operations.\n\n        Returns:\n            YamlTranslator: Instance used during DDL operations.\n\n        Raises:\n            DatabaseError: If YAML translator not initialized.\n        \"\"\"\n        if self.yaml_translator is None:\n            raise DatabaseError(\n                \"YAML translator not initialized. Provide yaml_path to constructor.\",\n                operation=\"get_yaml_translator\",\n            )\n        return self.yaml_translator\n\n    def close(self):\n        \"\"\"Close all database connections and cleanup resources.\n\n        Should be called when database clients are no longer needed.\n        \"\"\"\n        if self.qdrant_client is not None:\n            with suppress(Exception):\n                # Ignore cleanup errors - best effort\n                self.qdrant_client.close()\n            self.qdrant_client = None\n\n        if self.kuzu_connection is not None:\n            with suppress(Exception):\n                # Ignore cleanup errors - best effort\n                self.kuzu_connection.close()\n            self.kuzu_connection = None\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.DatabaseClients.__init__","title":"<code>__init__(yaml_path=None)</code>","text":"<p>Create DDL-only database client wrapper.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_path</code> <code>str | None</code> <p>Path to YAML schema file. User must provide - no defaults.</p> <code>None</code> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def __init__(self, yaml_path: str | None = None):\n    \"\"\"Create DDL-only database client wrapper.\n\n    Args:\n        yaml_path: Path to YAML schema file. User must provide - no defaults.\n    \"\"\"\n    self.qdrant_client: QdrantClient | None = None\n    self.kuzu_connection: kuzu.Connection | None = None\n    self.db_name = \"memg\"\n    self.qdrant_path = \"qdrant\"\n    self.kuzu_path = \"kuzu\"\n\n    self.yaml_translator = YamlTranslator(yaml_path) if yaml_path else None\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.DatabaseClients.close","title":"<code>close()</code>","text":"<p>Close all database connections and cleanup resources.</p> <p>Should be called when database clients are no longer needed.</p> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def close(self):\n    \"\"\"Close all database connections and cleanup resources.\n\n    Should be called when database clients are no longer needed.\n    \"\"\"\n    if self.qdrant_client is not None:\n        with suppress(Exception):\n            # Ignore cleanup errors - best effort\n            self.qdrant_client.close()\n        self.qdrant_client = None\n\n    if self.kuzu_connection is not None:\n        with suppress(Exception):\n            # Ignore cleanup errors - best effort\n            self.kuzu_connection.close()\n        self.kuzu_connection = None\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.DatabaseClients.get_embedder","title":"<code>get_embedder()</code>","text":"<p>Get embedder instance.</p> <p>Returns:</p> Name Type Description <code>Embedder</code> <code>Embedder</code> <p>Instance for generating vectors.</p> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def get_embedder(self) -&gt; Embedder:\n    \"\"\"Get embedder instance.\n\n    Returns:\n        Embedder: Instance for generating vectors.\n    \"\"\"\n    return Embedder()\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.DatabaseClients.get_kuzu_interface","title":"<code>get_kuzu_interface()</code>","text":"<p>Get Kuzu interface using the initialized connection.</p> <p>Returns:</p> Name Type Description <code>KuzuInterface</code> <code>KuzuInterface</code> <p>Configured with the DDL-created connection.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If connection not initialized (call init_dbs first).</p> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def get_kuzu_interface(self) -&gt; KuzuInterface:\n    \"\"\"Get Kuzu interface using the initialized connection.\n\n    Returns:\n        KuzuInterface: Configured with the DDL-created connection.\n\n    Raises:\n        DatabaseError: If connection not initialized (call init_dbs first).\n    \"\"\"\n    if self.kuzu_connection is None:\n        raise DatabaseError(\n            \"Kuzu connection not initialized. Call init_dbs() first.\",\n            operation=\"get_kuzu_interface\",\n        )\n    return KuzuInterface(self.kuzu_connection, self.yaml_translator)\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.DatabaseClients.get_qdrant_interface","title":"<code>get_qdrant_interface()</code>","text":"<p>Get Qdrant interface using the initialized client.</p> <p>Returns:</p> Name Type Description <code>QdrantInterface</code> <code>QdrantInterface</code> <p>Configured with the DDL-created client and collection.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If client not initialized (call init_dbs first).</p> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def get_qdrant_interface(self) -&gt; QdrantInterface:\n    \"\"\"Get Qdrant interface using the initialized client.\n\n    Returns:\n        QdrantInterface: Configured with the DDL-created client and collection.\n\n    Raises:\n        DatabaseError: If client not initialized (call init_dbs first).\n    \"\"\"\n    if self.qdrant_client is None:\n        raise DatabaseError(\n            \"Qdrant client not initialized. Call init_dbs() first.\",\n            operation=\"get_qdrant_interface\",\n        )\n    return QdrantInterface(self.qdrant_client, self.db_name)\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.DatabaseClients.get_yaml_translator","title":"<code>get_yaml_translator()</code>","text":"<p>Get the YAML translator used for schema operations.</p> <p>Returns:</p> Name Type Description <code>YamlTranslator</code> <code>YamlTranslator</code> <p>Instance used during DDL operations.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If YAML translator not initialized.</p> Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def get_yaml_translator(self) -&gt; YamlTranslator:\n    \"\"\"Get the YAML translator used for schema operations.\n\n    Returns:\n        YamlTranslator: Instance used during DDL operations.\n\n    Raises:\n        DatabaseError: If YAML translator not initialized.\n    \"\"\"\n    if self.yaml_translator is None:\n        raise DatabaseError(\n            \"YAML translator not initialized. Provide yaml_path to constructor.\",\n            operation=\"get_yaml_translator\",\n        )\n    return self.yaml_translator\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.DatabaseClients.init_dbs","title":"<code>init_dbs(db_path, db_name)</code>","text":"<p>Initialize databases with structured paths.</p> <p>Parameters:</p> Name Type Description Default <code>db_path</code> <code>str</code> <p>Base database directory.</p> required <code>db_name</code> <code>str</code> <p>Database name (used for collection and file names).</p> required Source code in <code>src/memg_core/utils/db_clients.py</code> <pre><code>def init_dbs(self, db_path: str, db_name: str):\n    \"\"\"Initialize databases with structured paths.\n\n    Args:\n        db_path: Base database directory.\n        db_name: Database name (used for collection and file names).\n    \"\"\"\n    # Structure paths\n    qdrant_path = os.path.join(db_path, \"qdrant\")\n    kuzu_path = os.path.join(db_path, \"kuzu\", db_name)\n\n    # Store paths and names\n    self.qdrant_path = qdrant_path\n    self.kuzu_path = kuzu_path\n    self.db_name = db_name\n\n    # Ensure directories exist\n    os.makedirs(qdrant_path, exist_ok=True)\n    os.makedirs(Path(kuzu_path).parent, exist_ok=True)\n\n    # Create raw database clients directly\n    qdrant_client = QdrantClient(path=qdrant_path)\n    kuzu_db = kuzu.Database(kuzu_path)\n    kuzu_conn = kuzu.Connection(kuzu_db)\n\n    # Store raw clients for interface creation\n    self.qdrant_client = qdrant_client\n    self.kuzu_connection = kuzu_conn\n\n    # DDL operations - create collection and tables\n    self._setup_qdrant_collection(qdrant_client, self.db_name)\n    self._setup_kuzu_tables_with_graph_register(kuzu_conn)\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.DatabaseError","title":"<code>DatabaseError</code>","text":"<p>               Bases: <code>MemorySystemError</code></p> <p>Database operation failures (Qdrant, Kuzu).</p> Source code in <code>src/memg_core/core/exceptions.py</code> <pre><code>class DatabaseError(MemorySystemError):\n    \"\"\"Database operation failures (Qdrant, Kuzu).\"\"\"\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.Embedder","title":"<code>Embedder</code>","text":"<p>Local embedder using FastEmbed - no API keys required.</p> <p>Attributes:</p> Name Type Description <code>model_name</code> <p>Name of the embedding model being used.</p> <code>model</code> <p>FastEmbed TextEmbedding instance.</p> Source code in <code>src/memg_core/core/interfaces/embedder.py</code> <pre><code>class Embedder:\n    \"\"\"Local embedder using FastEmbed - no API keys required.\n\n    Attributes:\n        model_name: Name of the embedding model being used.\n        model: FastEmbed TextEmbedding instance.\n    \"\"\"\n\n    def __init__(self, model_name: str | None = None):\n        \"\"\"Initialize the FastEmbed embedder.\n\n        Args:\n            model_name: Model to use. Defaults to config or snowflake-arctic-embed-xs.\n        \"\"\"\n\n        # Get model name from config system (which reads env) or use provided override\n        if model_name:\n            self.model_name = model_name\n        else:\n            # Use config system which handles env variable EMBEDDER_MODEL\n            config = get_config()\n            self.model_name = config.memg.embedder_model\n\n        self.model = TextEmbedding(model_name=self.model_name)\n\n    def get_embedding(self, text: str) -&gt; list[float]:\n        \"\"\"Get embedding for a single text.\n\n        Args:\n            text: Text to embed.\n\n        Returns:\n            list[float]: Embedding vector.\n\n        Raises:\n            RuntimeError: If FastEmbed returns empty embedding.\n        \"\"\"\n        # FastEmbed returns a generator, so we need to extract the first result\n        embeddings = list(self.model.embed([text]))\n        if embeddings:\n            return embeddings[0].tolist()\n        raise RuntimeError(\"FastEmbed returned empty embedding\")\n\n    def get_embeddings(self, texts: list[str]) -&gt; list[list[float]]:\n        \"\"\"Get embeddings for multiple texts.\n\n        Args:\n            texts: List of texts to embed.\n\n        Returns:\n            list[list[float]]: List of embedding vectors.\n        \"\"\"\n        embeddings = list(self.model.embed(texts))\n        return [emb.tolist() for emb in embeddings]\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.Embedder.__init__","title":"<code>__init__(model_name=None)</code>","text":"<p>Initialize the FastEmbed embedder.</p> <p>Parameters:</p> Name Type Description Default <code>model_name</code> <code>str | None</code> <p>Model to use. Defaults to config or snowflake-arctic-embed-xs.</p> <code>None</code> Source code in <code>src/memg_core/core/interfaces/embedder.py</code> <pre><code>def __init__(self, model_name: str | None = None):\n    \"\"\"Initialize the FastEmbed embedder.\n\n    Args:\n        model_name: Model to use. Defaults to config or snowflake-arctic-embed-xs.\n    \"\"\"\n\n    # Get model name from config system (which reads env) or use provided override\n    if model_name:\n        self.model_name = model_name\n    else:\n        # Use config system which handles env variable EMBEDDER_MODEL\n        config = get_config()\n        self.model_name = config.memg.embedder_model\n\n    self.model = TextEmbedding(model_name=self.model_name)\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.Embedder.get_embedding","title":"<code>get_embedding(text)</code>","text":"<p>Get embedding for a single text.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to embed.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>list[float]: Embedding vector.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If FastEmbed returns empty embedding.</p> Source code in <code>src/memg_core/core/interfaces/embedder.py</code> <pre><code>def get_embedding(self, text: str) -&gt; list[float]:\n    \"\"\"Get embedding for a single text.\n\n    Args:\n        text: Text to embed.\n\n    Returns:\n        list[float]: Embedding vector.\n\n    Raises:\n        RuntimeError: If FastEmbed returns empty embedding.\n    \"\"\"\n    # FastEmbed returns a generator, so we need to extract the first result\n    embeddings = list(self.model.embed([text]))\n    if embeddings:\n        return embeddings[0].tolist()\n    raise RuntimeError(\"FastEmbed returned empty embedding\")\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.Embedder.get_embeddings","title":"<code>get_embeddings(texts)</code>","text":"<p>Get embeddings for multiple texts.</p> <p>Parameters:</p> Name Type Description Default <code>texts</code> <code>list[str]</code> <p>List of texts to embed.</p> required <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>list[list[float]]: List of embedding vectors.</p> Source code in <code>src/memg_core/core/interfaces/embedder.py</code> <pre><code>def get_embeddings(self, texts: list[str]) -&gt; list[list[float]]:\n    \"\"\"Get embeddings for multiple texts.\n\n    Args:\n        texts: List of texts to embed.\n\n    Returns:\n        list[list[float]]: List of embedding vectors.\n    \"\"\"\n    embeddings = list(self.model.embed(texts))\n    return [emb.tolist() for emb in embeddings]\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.GraphRegister","title":"<code>GraphRegister</code>","text":"<p>Generates DDL statements for graph databases using TypeRegistry.</p> <p>Database-agnostic design - generates DDL that can be adapted for: - Kuzu (current) - Neo4j (future) - ArangoDB (future) - Any graph database with node/relationship tables</p> Source code in <code>src/memg_core/utils/graph_register.py</code> <pre><code>class GraphRegister:\n    \"\"\"Generates DDL statements for graph databases using TypeRegistry.\n\n    Database-agnostic design - generates DDL that can be adapted for:\n    - Kuzu (current)\n    - Neo4j (future)\n    - ArangoDB (future)\n    - Any graph database with node/relationship tables\n    \"\"\"\n\n    def __init__(\n        self,\n        type_registry: TypeRegistry | None = None,\n        yaml_translator: YamlTranslator | None = None,\n    ):\n        \"\"\"Initialize GraphRegister with TypeRegistry and YamlTranslator.\n\n        Args:\n            type_registry: TypeRegistry instance. If None, uses global singleton.\n            yaml_translator: YamlTranslator for accessing full YAML schema. Optional.\n        \"\"\"\n        self.type_registry = type_registry or TypeRegistry.get_instance()\n        self.yaml_translator = yaml_translator\n\n        # Validate TypeRegistry is properly initialized\n        try:\n            self.type_registry.get_valid_entity_names()\n        except RuntimeError as e:\n            raise DatabaseError(\n                \"TypeRegistry not initialized. Call initialize_types_from_yaml() first.\",\n                operation=\"graph_register_init\",\n                original_error=e,\n            ) from e\n\n    def generate_entity_table_ddl(self, entity_name: str) -&gt; str:\n        \"\"\"Generate DDL for a single entity table.\n\n        Args:\n            entity_name: Name of entity type (e.g., 'task', 'bug')\n\n        Returns:\n            DDL string for creating the entity table\n\n        Raises:\n            DatabaseError: If entity not found in TypeRegistry\n        \"\"\"\n        # Validate entity exists in TypeRegistry\n        valid_entities = self.type_registry.get_valid_entity_names()\n        if entity_name not in valid_entities:\n            raise DatabaseError(\n                f\"Entity '{entity_name}' not found in TypeRegistry\",\n                operation=\"generate_entity_table_ddl\",\n                context={\"entity_name\": entity_name, \"valid_entities\": valid_entities},\n            )\n\n        # Get Pydantic model with all fields (inheritance already resolved)\n        model = self.type_registry.get_entity_model(entity_name)\n\n        # Build column definitions from Pydantic model fields\n        columns = []\n        system_field_names = {\n            \"id\",\n            \"user_id\",\n            \"memory_type\",\n            \"created_at\",\n            \"updated_at\",\n        }\n\n        for field_name, _field_info in model.model_fields.items():\n            # Skip system fields - they'll be added separately\n            if field_name in system_field_names:\n                continue\n            # All user fields are STRING for now (Kuzu limitation)\n            # TODO: Add proper type mapping when Kuzu supports more types\n            columns.append(f\"{field_name} STRING\")\n\n        # Add system fields (not in YAML schema)\n        system_columns = [\n            \"id STRING\",\n            \"user_id STRING\",\n            \"memory_type STRING\",\n            \"created_at STRING\",\n            \"updated_at STRING\",\n        ]\n\n        all_columns = system_columns + columns\n        columns_sql = \",\\n                \".join(all_columns)\n\n        # Generate Kuzu-style DDL (adaptable for other graph DBs)\n        ddl = f\"\"\"CREATE NODE TABLE IF NOT EXISTS {entity_name}(\n                {columns_sql},\n                PRIMARY KEY (id)\n        )\"\"\"\n\n        return ddl\n\n    def generate_all_entity_tables_ddl(self) -&gt; list[str]:\n        \"\"\"Generate DDL for all entity tables from TypeRegistry.\n\n        Returns:\n            List of DDL strings, one per entity table\n        \"\"\"\n        ddl_statements = []\n\n        for entity_name in self.type_registry.get_valid_entity_names():\n            ddl = self.generate_entity_table_ddl(entity_name)\n            ddl_statements.append(ddl)\n\n        return ddl_statements\n\n    def generate_relationship_tables_ddl(self) -&gt; list[str]:\n        \"\"\"Generate DDL for relationship tables from YAML schema using YamlTranslator.\n\n        Uses YamlTranslator to discover relations and centralized table naming.\n        Handles directed/undirected semantics for table creation.\n\n        Returns:\n            List of DDL strings for relationship tables\n\n        Raises:\n            DatabaseError: If YamlTranslator not provided or schema access fails\n        \"\"\"\n        if not self.yaml_translator:\n            # Return empty list if no YamlTranslator - maintains compatibility\n            return []\n\n        ddl_statements = []\n        created_tables = set()  # Track unique table names to avoid duplicates\n\n        try:\n            # Use YamlTranslator to discover all relations across all entities\n            for entity_name in self.yaml_translator.get_entity_types():\n                relation_specs = self.yaml_translator.get_relations_for_source(entity_name)\n\n                for spec in relation_specs:\n                    # Validate predicate against TypeRegistry\n                    predicate = spec[\"predicate\"]\n                    if not self.type_registry.validate_relation_predicate(predicate):\n                        raise DatabaseError(\n                            f\"Invalid predicate '{predicate}' not found in TypeRegistry\",\n                            operation=\"generate_relationship_tables_ddl\",\n                            context={\"predicate\": predicate, \"spec\": spec},\n                        )\n\n                    # Generate table name using centralized helper\n                    table_name = self.yaml_translator.relationship_table_name(\n                        source=spec[\"source\"],\n                        predicate=spec[\"predicate\"],\n                        target=spec[\"target\"],\n                        directed=spec[\"directed\"],\n                    )\n\n                    # Skip if we've already created this table\n                    if table_name in created_tables:\n                        continue\n\n                    created_tables.add(table_name)\n\n                    # Create DDL - direction affects semantics but not table structure\n                    ddl = f\"\"\"CREATE REL TABLE IF NOT EXISTS {table_name}(\n                        FROM {spec[\"source\"]} TO {spec[\"target\"]}\n                    )\"\"\"\n                    ddl_statements.append(ddl)\n\n        except Exception as e:\n            if isinstance(e, DatabaseError):\n                raise\n            raise DatabaseError(\n                \"Failed to generate relationship tables DDL\",\n                operation=\"generate_relationship_tables_ddl\",\n                original_error=e,\n            ) from e\n\n        return ddl_statements\n\n    def generate_hrid_mapping_table_ddl(self) -&gt; str:\n        \"\"\"Generate DDL for HRID mapping table (system table).\n\n        Returns:\n            DDL string for HRID mapping table\n        \"\"\"\n        ddl = \"\"\"CREATE NODE TABLE IF NOT EXISTS HridMapping(\n            hrid_user_key STRING,\n            hrid STRING,\n            uuid STRING,\n            memory_type STRING,\n            user_id STRING,\n            created_at STRING,\n            deleted_at STRING,\n            PRIMARY KEY (hrid_user_key)\n        )\"\"\"\n\n        return ddl\n\n    def generate_all_ddl(self) -&gt; list[str]:\n        \"\"\"Generate all DDL statements for complete schema setup.\n\n        Returns:\n            List of all DDL statements needed for schema creation\n        \"\"\"\n        ddl_statements = []\n\n        # Entity tables\n        ddl_statements.extend(self.generate_all_entity_tables_ddl())\n\n        # Relationship tables\n        ddl_statements.extend(self.generate_relationship_tables_ddl())\n\n        # System tables\n        ddl_statements.append(self.generate_hrid_mapping_table_ddl())\n\n        return ddl_statements\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.GraphRegister.__init__","title":"<code>__init__(type_registry=None, yaml_translator=None)</code>","text":"<p>Initialize GraphRegister with TypeRegistry and YamlTranslator.</p> <p>Parameters:</p> Name Type Description Default <code>type_registry</code> <code>TypeRegistry | None</code> <p>TypeRegistry instance. If None, uses global singleton.</p> <code>None</code> <code>yaml_translator</code> <code>YamlTranslator | None</code> <p>YamlTranslator for accessing full YAML schema. Optional.</p> <code>None</code> Source code in <code>src/memg_core/utils/graph_register.py</code> <pre><code>def __init__(\n    self,\n    type_registry: TypeRegistry | None = None,\n    yaml_translator: YamlTranslator | None = None,\n):\n    \"\"\"Initialize GraphRegister with TypeRegistry and YamlTranslator.\n\n    Args:\n        type_registry: TypeRegistry instance. If None, uses global singleton.\n        yaml_translator: YamlTranslator for accessing full YAML schema. Optional.\n    \"\"\"\n    self.type_registry = type_registry or TypeRegistry.get_instance()\n    self.yaml_translator = yaml_translator\n\n    # Validate TypeRegistry is properly initialized\n    try:\n        self.type_registry.get_valid_entity_names()\n    except RuntimeError as e:\n        raise DatabaseError(\n            \"TypeRegistry not initialized. Call initialize_types_from_yaml() first.\",\n            operation=\"graph_register_init\",\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.GraphRegister.generate_all_ddl","title":"<code>generate_all_ddl()</code>","text":"<p>Generate all DDL statements for complete schema setup.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of all DDL statements needed for schema creation</p> Source code in <code>src/memg_core/utils/graph_register.py</code> <pre><code>def generate_all_ddl(self) -&gt; list[str]:\n    \"\"\"Generate all DDL statements for complete schema setup.\n\n    Returns:\n        List of all DDL statements needed for schema creation\n    \"\"\"\n    ddl_statements = []\n\n    # Entity tables\n    ddl_statements.extend(self.generate_all_entity_tables_ddl())\n\n    # Relationship tables\n    ddl_statements.extend(self.generate_relationship_tables_ddl())\n\n    # System tables\n    ddl_statements.append(self.generate_hrid_mapping_table_ddl())\n\n    return ddl_statements\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.GraphRegister.generate_all_entity_tables_ddl","title":"<code>generate_all_entity_tables_ddl()</code>","text":"<p>Generate DDL for all entity tables from TypeRegistry.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of DDL strings, one per entity table</p> Source code in <code>src/memg_core/utils/graph_register.py</code> <pre><code>def generate_all_entity_tables_ddl(self) -&gt; list[str]:\n    \"\"\"Generate DDL for all entity tables from TypeRegistry.\n\n    Returns:\n        List of DDL strings, one per entity table\n    \"\"\"\n    ddl_statements = []\n\n    for entity_name in self.type_registry.get_valid_entity_names():\n        ddl = self.generate_entity_table_ddl(entity_name)\n        ddl_statements.append(ddl)\n\n    return ddl_statements\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.GraphRegister.generate_entity_table_ddl","title":"<code>generate_entity_table_ddl(entity_name)</code>","text":"<p>Generate DDL for a single entity table.</p> <p>Parameters:</p> Name Type Description Default <code>entity_name</code> <code>str</code> <p>Name of entity type (e.g., 'task', 'bug')</p> required <p>Returns:</p> Type Description <code>str</code> <p>DDL string for creating the entity table</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If entity not found in TypeRegistry</p> Source code in <code>src/memg_core/utils/graph_register.py</code> <pre><code>def generate_entity_table_ddl(self, entity_name: str) -&gt; str:\n    \"\"\"Generate DDL for a single entity table.\n\n    Args:\n        entity_name: Name of entity type (e.g., 'task', 'bug')\n\n    Returns:\n        DDL string for creating the entity table\n\n    Raises:\n        DatabaseError: If entity not found in TypeRegistry\n    \"\"\"\n    # Validate entity exists in TypeRegistry\n    valid_entities = self.type_registry.get_valid_entity_names()\n    if entity_name not in valid_entities:\n        raise DatabaseError(\n            f\"Entity '{entity_name}' not found in TypeRegistry\",\n            operation=\"generate_entity_table_ddl\",\n            context={\"entity_name\": entity_name, \"valid_entities\": valid_entities},\n        )\n\n    # Get Pydantic model with all fields (inheritance already resolved)\n    model = self.type_registry.get_entity_model(entity_name)\n\n    # Build column definitions from Pydantic model fields\n    columns = []\n    system_field_names = {\n        \"id\",\n        \"user_id\",\n        \"memory_type\",\n        \"created_at\",\n        \"updated_at\",\n    }\n\n    for field_name, _field_info in model.model_fields.items():\n        # Skip system fields - they'll be added separately\n        if field_name in system_field_names:\n            continue\n        # All user fields are STRING for now (Kuzu limitation)\n        # TODO: Add proper type mapping when Kuzu supports more types\n        columns.append(f\"{field_name} STRING\")\n\n    # Add system fields (not in YAML schema)\n    system_columns = [\n        \"id STRING\",\n        \"user_id STRING\",\n        \"memory_type STRING\",\n        \"created_at STRING\",\n        \"updated_at STRING\",\n    ]\n\n    all_columns = system_columns + columns\n    columns_sql = \",\\n                \".join(all_columns)\n\n    # Generate Kuzu-style DDL (adaptable for other graph DBs)\n    ddl = f\"\"\"CREATE NODE TABLE IF NOT EXISTS {entity_name}(\n            {columns_sql},\n            PRIMARY KEY (id)\n    )\"\"\"\n\n    return ddl\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.GraphRegister.generate_hrid_mapping_table_ddl","title":"<code>generate_hrid_mapping_table_ddl()</code>","text":"<p>Generate DDL for HRID mapping table (system table).</p> <p>Returns:</p> Type Description <code>str</code> <p>DDL string for HRID mapping table</p> Source code in <code>src/memg_core/utils/graph_register.py</code> <pre><code>def generate_hrid_mapping_table_ddl(self) -&gt; str:\n    \"\"\"Generate DDL for HRID mapping table (system table).\n\n    Returns:\n        DDL string for HRID mapping table\n    \"\"\"\n    ddl = \"\"\"CREATE NODE TABLE IF NOT EXISTS HridMapping(\n        hrid_user_key STRING,\n        hrid STRING,\n        uuid STRING,\n        memory_type STRING,\n        user_id STRING,\n        created_at STRING,\n        deleted_at STRING,\n        PRIMARY KEY (hrid_user_key)\n    )\"\"\"\n\n    return ddl\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.GraphRegister.generate_relationship_tables_ddl","title":"<code>generate_relationship_tables_ddl()</code>","text":"<p>Generate DDL for relationship tables from YAML schema using YamlTranslator.</p> <p>Uses YamlTranslator to discover relations and centralized table naming. Handles directed/undirected semantics for table creation.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of DDL strings for relationship tables</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If YamlTranslator not provided or schema access fails</p> Source code in <code>src/memg_core/utils/graph_register.py</code> <pre><code>def generate_relationship_tables_ddl(self) -&gt; list[str]:\n    \"\"\"Generate DDL for relationship tables from YAML schema using YamlTranslator.\n\n    Uses YamlTranslator to discover relations and centralized table naming.\n    Handles directed/undirected semantics for table creation.\n\n    Returns:\n        List of DDL strings for relationship tables\n\n    Raises:\n        DatabaseError: If YamlTranslator not provided or schema access fails\n    \"\"\"\n    if not self.yaml_translator:\n        # Return empty list if no YamlTranslator - maintains compatibility\n        return []\n\n    ddl_statements = []\n    created_tables = set()  # Track unique table names to avoid duplicates\n\n    try:\n        # Use YamlTranslator to discover all relations across all entities\n        for entity_name in self.yaml_translator.get_entity_types():\n            relation_specs = self.yaml_translator.get_relations_for_source(entity_name)\n\n            for spec in relation_specs:\n                # Validate predicate against TypeRegistry\n                predicate = spec[\"predicate\"]\n                if not self.type_registry.validate_relation_predicate(predicate):\n                    raise DatabaseError(\n                        f\"Invalid predicate '{predicate}' not found in TypeRegistry\",\n                        operation=\"generate_relationship_tables_ddl\",\n                        context={\"predicate\": predicate, \"spec\": spec},\n                    )\n\n                # Generate table name using centralized helper\n                table_name = self.yaml_translator.relationship_table_name(\n                    source=spec[\"source\"],\n                    predicate=spec[\"predicate\"],\n                    target=spec[\"target\"],\n                    directed=spec[\"directed\"],\n                )\n\n                # Skip if we've already created this table\n                if table_name in created_tables:\n                    continue\n\n                created_tables.add(table_name)\n\n                # Create DDL - direction affects semantics but not table structure\n                ddl = f\"\"\"CREATE REL TABLE IF NOT EXISTS {table_name}(\n                    FROM {spec[\"source\"]} TO {spec[\"target\"]}\n                )\"\"\"\n                ddl_statements.append(ddl)\n\n    except Exception as e:\n        if isinstance(e, DatabaseError):\n            raise\n        raise DatabaseError(\n            \"Failed to generate relationship tables DDL\",\n            operation=\"generate_relationship_tables_ddl\",\n            original_error=e,\n        ) from e\n\n    return ddl_statements\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.KuzuInterface","title":"<code>KuzuInterface</code>","text":"<p>Pure CRUD wrapper around Kuzu database - NO DDL operations.</p> <p>Attributes:</p> Name Type Description <code>conn</code> <p>Pre-initialized Kuzu connection.</p> <code>yaml_translator</code> <p>Optional YAML translator for relationship operations.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>class KuzuInterface:\n    \"\"\"Pure CRUD wrapper around Kuzu database - NO DDL operations.\n\n    Attributes:\n        conn: Pre-initialized Kuzu connection.\n        yaml_translator: Optional YAML translator for relationship operations.\n    \"\"\"\n\n    def __init__(self, connection: kuzu.Connection, yaml_translator=None):\n        \"\"\"Initialize with pre-created connection.\n\n        Args:\n            connection: Pre-initialized Kuzu connection from DatabaseClients.\n            yaml_translator: Optional YamlTranslator for relationship operations.\n        \"\"\"\n        self.conn = connection\n        self.yaml_translator = yaml_translator\n\n    def add_node(self, table: str, properties: dict[str, Any]) -&gt; None:\n        \"\"\"Add a node to the graph - pure CRUD operation.\n\n        Args:\n            table: Node table name.\n            properties: Node properties.\n\n        Raises:\n            DatabaseError: If node creation fails.\n        \"\"\"\n        try:\n            props = \", \".join([f\"{k}: ${k}\" for k in properties])\n            query = f\"CREATE (:{table} {{{props}}})\"\n            self.conn.execute(query, parameters=properties)\n        except Exception as e:\n            raise DatabaseError(\n                f\"Failed to add node to {table}\",\n                operation=\"add_node\",\n                context={\"table\": table, \"properties\": properties},\n                original_error=e,\n            ) from e\n\n    def update_node(\n        self, table: str, node_uuid: str, properties: dict[str, Any], user_id: str\n    ) -&gt; bool:\n        \"\"\"Update a node in the graph - pure CRUD operation.\n\n        Args:\n            table: Node table name.\n            node_uuid: UUID of the node to update.\n            properties: Node properties to update.\n            user_id: User ID for ownership verification.\n\n        Returns:\n            bool: True if update succeeded, False if node not found.\n\n        Raises:\n            DatabaseError: If node update fails due to system error.\n        \"\"\"\n        try:\n            # CRITICAL: Check if node exists AND belongs to user\n            check_query = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) RETURN n.id as id\"\n            check_result = self.query(check_query, {\"uuid\": node_uuid, \"user_id\": user_id})\n\n            if not check_result:\n                # Node doesn't exist for this user\n                return False\n\n            # Build SET clause for properties\n            set_clauses = []\n            params = {\"uuid\": node_uuid, \"user_id\": user_id}\n\n            for key, value in properties.items():\n                # Skip system fields that shouldn't be updated via this method\n                if key in (\"id\", \"user_id\"):\n                    continue\n\n                param_name = f\"prop_{key}\"\n                set_clauses.append(f\"n.{key} = ${param_name}\")\n                params[param_name] = value\n\n            if not set_clauses:\n                # No properties to update (all were system fields)\n                return True\n\n            # Execute update query\n            set_clause = \", \".join(set_clauses)\n            update_query = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) SET {set_clause}\"\n            self.conn.execute(update_query, parameters=params)\n\n            return True\n\n        except Exception as e:\n            raise DatabaseError(\n                f\"Failed to update node in {table}\",\n                operation=\"update_node\",\n                context={\n                    \"table\": table,\n                    \"node_uuid\": node_uuid,\n                    \"properties\": properties,\n                    \"user_id\": user_id,\n                },\n                original_error=e,\n            ) from e\n\n    def add_relationship(\n        self,\n        from_table: str,\n        to_table: str,\n        rel_type: str,\n        from_id: str,\n        to_id: str,\n        user_id: str,\n        props: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"Add relationship between nodes.\n\n        Args:\n            from_table: Source node table name.\n            to_table: Target node table name.\n            rel_type: Relationship type.\n            from_id: Source node ID.\n            to_id: Target node ID.\n            user_id: User ID for ownership verification.\n            props: Optional relationship properties.\n\n        Raises:\n            DatabaseError: If relationship creation fails.\n        \"\"\"\n        try:\n            props = props or {}\n\n            # VALIDATE RELATIONSHIP AGAINST YAML SCHEMA - crash if invalid\n            if not validate_relation_predicate(rel_type):\n                raise ValueError(\n                    f\"Invalid relationship predicate: {rel_type}. Must be defined in YAML schema.\"\n                )\n\n            # Use relationship type as-is (predicates from YAML) - no sanitization\n            # rel_type should already be a valid predicate (e.g., \"REFERENCED_BY\", \"ANNOTATES\")\n\n            # CRITICAL: Verify both nodes belong to the user before creating relationship\n            # First check if both nodes exist and belong to the user\n            check_query = (\n                f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}}), \"\n                f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n                f\"RETURN a.id, b.id\"\n            )\n            check_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n            check_result = self.query(check_query, check_params)\n\n            if not check_result:\n                raise ValueError(\n                    f\"Cannot create relationship: one or both memories not found \"\n                    f\"or don't belong to user {user_id}\"\n                )\n\n            # Generate relationship table name using YamlTranslator\n            if not self.yaml_translator:\n                raise DatabaseError(\n                    \"YamlTranslator required for relationship operations\",\n                    operation=\"add_relationship\",\n                    context={\n                        \"from_table\": from_table,\n                        \"to_table\": to_table,\n                        \"rel_type\": rel_type,\n                    },\n                )\n\n            relationship_table_name = self.yaml_translator.relationship_table_name(\n                source=from_table,\n                predicate=rel_type,\n                target=to_table,\n                directed=True,  # Direction affects semantics but not table naming for now\n            )\n\n            # Now create the relationship using the unique table name\n            prop_str = \", \".join([f\"{k}: ${k}\" for k in props.keys()]) if props else \"\"\n            rel_props = f\" {{{prop_str}}}\" if prop_str else \"\"\n            create_query = (\n                f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}}), \"\n                f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n                f\"CREATE (a)-[:{relationship_table_name}{rel_props}]-&gt;(b)\"\n            )\n            create_params = {\n                \"from_id\": from_id,\n                \"to_id\": to_id,\n                \"user_id\": user_id,\n                **props,\n            }\n            self.conn.execute(create_query, parameters=create_params)\n        except Exception as e:\n            raise DatabaseError(\n                f\"Failed to add relationship {rel_type}\",\n                operation=\"add_relationship\",\n                context={\n                    \"from_table\": from_table,\n                    \"to_table\": to_table,\n                    \"rel_type\": rel_type,\n                    \"from_id\": from_id,\n                    \"to_id\": to_id,\n                },\n                original_error=e,\n            ) from e\n\n    def delete_relationship(\n        self,\n        from_table: str,\n        to_table: str,\n        rel_type: str,\n        from_id: str,\n        to_id: str,\n        user_id: str,\n    ) -&gt; bool:\n        \"\"\"Delete relationship between nodes.\n\n        Args:\n            from_table: Source node table name.\n            to_table: Target node table name.\n            rel_type: Relationship type.\n            from_id: Source node ID.\n            to_id: Target node ID.\n            user_id: User ID for ownership verification.\n\n        Returns:\n            bool: True if deletion succeeded, False if relationship not found.\n\n        Raises:\n            DatabaseError: If relationship deletion fails due to system error.\n        \"\"\"\n        try:\n            # VALIDATE RELATIONSHIP AGAINST YAML SCHEMA - crash if invalid\n            if not validate_relation_predicate(rel_type):\n                raise ValueError(\n                    f\"Invalid relationship predicate: {rel_type}. Must be defined in YAML schema.\"\n                )\n\n            # CRITICAL: Verify both nodes belong to the user before deleting relationship\n            # First check if both nodes exist and belong to the user\n            check_query = (\n                f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}}), \"\n                f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n                f\"RETURN a.id, b.id\"\n            )\n            check_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n            check_result = self.query(check_query, check_params)\n\n            if not check_result:\n                # Nodes don't exist or don't belong to user - return False (not found)\n                return False\n\n            # Generate relationship table name using YamlTranslator\n            if not self.yaml_translator:\n                raise DatabaseError(\n                    \"YamlTranslator required for relationship operations\",\n                    operation=\"delete_relationship\",\n                    context={\n                        \"from_table\": from_table,\n                        \"to_table\": to_table,\n                        \"rel_type\": rel_type,\n                    },\n                )\n\n            relationship_table_name = self.yaml_translator.relationship_table_name(\n                source=from_table,\n                predicate=rel_type,\n                target=to_table,\n                directed=True,  # Direction affects semantics but not table naming for now\n            )\n\n            # First check if the relationship exists\n            check_rel_query = (\n                f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}})\"\n                f\"-[r:{relationship_table_name}]-&gt;\"\n                f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n                f\"RETURN r\"\n            )\n            check_rel_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n\n            # Check if relationship exists\n            relationship_exists = self.query(check_rel_query, check_rel_params)\n            if not relationship_exists:\n                # Relationship doesn't exist - return False\n                return False\n\n            # Delete the specific relationship (we know it exists)\n            delete_query = (\n                f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}})\"\n                f\"-[r:{relationship_table_name}]-&gt;\"\n                f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n                f\"DELETE r\"\n            )\n            delete_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n\n            # Execute deletion\n            self.conn.execute(delete_query, parameters=delete_params)\n\n            # If we get here, deletion succeeded\n            return True\n\n        except Exception as e:\n            if isinstance(e, ValueError):\n                # Re-raise validation errors as-is\n                raise\n            raise DatabaseError(\n                f\"Failed to delete relationship {rel_type}\",\n                operation=\"delete_relationship\",\n                context={\n                    \"from_table\": from_table,\n                    \"to_table\": to_table,\n                    \"rel_type\": rel_type,\n                    \"from_id\": from_id,\n                    \"to_id\": to_id,\n                },\n                original_error=e,\n            ) from e\n\n    def _extract_query_results(self, query_result) -&gt; list[dict[str, Any]]:\n        \"\"\"Extract results from Kuzu QueryResult using raw iteration.\n\n        Args:\n            query_result: Kuzu QueryResult object.\n\n        Returns:\n            list[dict[str, Any]]: List of dictionaries containing query results.\n        \"\"\"\n        # Type annotations disabled for QueryResult - dynamic interface from kuzu package\n        qr = query_result  # type: ignore\n\n        results = []\n        column_names = qr.get_column_names()\n        while qr.has_next():\n            row = qr.get_next()\n            result = {}\n            for i, col_name in enumerate(column_names):\n                result[col_name] = row[i] if i &lt; len(row) else None\n            results.append(result)\n        return results\n\n    def query(self, cypher: str, params: dict[str, Any] | None = None) -&gt; list[dict[str, Any]]:\n        \"\"\"Execute Cypher query and return results.\n\n        Args:\n            cypher: Cypher query string.\n            params: Query parameters.\n\n        Returns:\n            list[dict[str, Any]]: Query results.\n\n        Raises:\n            DatabaseError: If query execution fails.\n        \"\"\"\n        try:\n            qr = self.conn.execute(cypher, parameters=params or {})\n            return self._extract_query_results(qr)\n        except Exception as e:\n            raise DatabaseError(\n                \"Failed to execute Kuzu query\",\n                operation=\"query\",\n                context={\"cypher\": cypher, \"params\": params},\n                original_error=e,\n            ) from e\n\n    def neighbors(\n        self,\n        node_label: str,\n        node_uuid: str,\n        user_id: str,\n        rel_types: list[str] | None = None,\n        direction: str = \"any\",\n        limit: int = 10,\n        neighbor_label: str | None = None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Fetch neighbors of a node by UUID only.\n\n        Args:\n            node_label: Node type/table name (e.g., \"Memory\", \"bug\") - NOT a UUID.\n            node_uuid: UUID of the specific node to find neighbors for.\n            user_id: User ID for isolation - only return neighbors belonging to this user.\n            rel_types: List of relationship types to filter by.\n            direction: \"in\", \"out\", or \"any\" for relationship direction.\n            limit: Maximum number of neighbors to return.\n            neighbor_label: Type of neighbor nodes to return.\n\n        Returns:\n            list[dict[str, Any]]: List of neighbor nodes with relationship info.\n\n        Raises:\n            ValueError: If node_label is a UUID or node_uuid is not a UUID.\n            DatabaseError: If neighbor query fails.\n        \"\"\"\n        # Validate parameters to prevent common bugs\n        if self._is_uuid(node_label):\n            raise ValueError(\n                f\"node_label must be a node type (e.g., 'Memory', 'bug'), not UUID: {node_label}. \"\n                f\"UUIDs should be passed as node_uuid parameter.\"\n            )\n\n        if not self._is_uuid(node_uuid):\n            raise ValueError(f\"node_uuid must be a valid UUID format, got: {node_uuid}\")\n\n        try:\n            # Use YamlTranslator to expand predicates to concrete relationship labels\n            if not self.yaml_translator:\n                raise DatabaseError(\n                    \"YamlTranslator required for neighbor operations\",\n                    operation=\"neighbors\",\n                    context={\"node_label\": node_label, \"rel_types\": rel_types},\n                )\n\n            # Get concrete relationship labels for this source and predicates\n            if rel_types:\n                relationship_labels = self.yaml_translator.get_labels_for_predicates(\n                    source_type=node_label,\n                    predicates=rel_types,\n                    neighbor_label=neighbor_label,\n                )\n                if not relationship_labels:\n                    # No matching relationships found - return empty\n                    return []\n\n                # Create relationship pattern with specific labels\n                rel_filter = \"|\".join(relationship_labels)\n                rel_part = f\":{rel_filter}\"\n            else:\n                # No filtering - match all relationships\n                rel_part = \"\"\n\n            # CRITICAL: User isolation - both source node and neighbors must belong to user\n            node_condition = f\"a:{node_label} {{id: $node_uuid, user_id: $user_id}}\"\n            neighbor = f\":{neighbor_label}\" if neighbor_label else \"\"\n            neighbor_condition = f\"n{neighbor} {{user_id: $user_id}}\"\n\n            # Build direction-aware pattern\n            if direction == \"out\":\n                pattern = f\"({node_condition})-[r{rel_part}]-&gt;({neighbor_condition})\"\n            elif direction == \"in\":\n                pattern = f\"({node_condition})&lt;-[r{rel_part}]-({neighbor_condition})\"\n            else:\n                pattern = f\"({node_condition})-[r{rel_part}]-({neighbor_condition})\"\n\n            # Return neighbors only if they belong to the same user\n            cypher = f\"\"\"\n            MATCH {pattern}\n            RETURN DISTINCT n.id as id,\n                            n.user_id as user_id,\n                            n.memory_type as memory_type,\n                            n.created_at as created_at,\n                            label(r) as rel_type,\n                            n as node\n            LIMIT $limit\n            \"\"\"\n            params = {\"node_uuid\": node_uuid, \"user_id\": user_id, \"limit\": limit}\n            return self.query(cypher, params)\n        except Exception as e:\n            raise DatabaseError(\n                \"Failed to fetch neighbors\",\n                operation=\"neighbors\",\n                context={\n                    \"node_label\": node_label,\n                    \"node_uuid\": node_uuid,\n                    \"user_id\": user_id,\n                    \"rel_types\": rel_types,\n                    \"direction\": direction,\n                },\n                original_error=e,\n            ) from e\n\n    def delete_node(self, table: str, node_uuid: str, user_id: str) -&gt; bool:\n        \"\"\"Delete a single node by UUID\"\"\"\n        try:\n            # CRITICAL: Check if node exists AND belongs to user\n            cypher_check = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) RETURN n.id as id\"\n            check_result = self.query(cypher_check, {\"uuid\": node_uuid, \"user_id\": user_id})\n\n            if not check_result:\n                # Node doesn't exist for this user, consider it successfully \"deleted\"\n                return True\n\n            # Delete the node - only if it belongs to the user\n            cypher_delete_node = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) DELETE n\"\n            self.conn.execute(\n                cypher_delete_node, parameters={\"uuid\": node_uuid, \"user_id\": user_id}\n            )\n            return True\n\n        except Exception as e:\n            error_msg = str(e).lower()\n            if \"delete undirected rel\" in error_msg or \"relationship\" in error_msg:\n                # Relationship constraint prevents deletion - this is a REAL FAILURE\n                # Don't lie by returning True - raise explicit error\n                raise DatabaseError(\n                    f\"Cannot delete node {node_uuid} from {table}: has existing relationships. \"\n                    f\"Delete relationships first or use CASCADE delete if supported.\",\n                    operation=\"delete_node\",\n                    context={\n                        \"table\": table,\n                        \"node_uuid\": node_uuid,\n                        \"constraint_error\": str(e),\n                    },\n                    original_error=e,\n                ) from e\n            # Other database error\n            raise DatabaseError(\n                f\"Failed to delete node from {table}\",\n                operation=\"delete_node\",\n                context={\"table\": table, \"node_uuid\": node_uuid, \"user_id\": user_id},\n                original_error=e,\n            ) from e\n\n    def get_nodes(\n        self,\n        user_id: str,\n        node_type: str | None = None,\n        filters: dict[str, Any] | None = None,\n        limit: int = 50,\n        offset: int = 0,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Get multiple nodes with filtering and pagination.\n\n        Args:\n            user_id: User ID for ownership verification.\n            node_type: Optional node type filter (e.g., \"task\", \"note\").\n            filters: Optional field filters (e.g., {\"status\": \"open\"}).\n            limit: Maximum number of nodes to return.\n            offset: Number of nodes to skip for pagination.\n\n        Returns:\n            list[dict[str, Any]]: List of node data from Kuzu.\n\n        Raises:\n            DatabaseError: If node retrieval fails.\n        \"\"\"\n        try:\n            filters = filters or {}\n\n            # Build MATCH clause\n            if node_type:\n                match_clause = f\"MATCH (n:{node_type} {{user_id: $user_id\"\n            else:\n                match_clause = \"MATCH (n {user_id: $user_id\"\n\n            # Add field filters\n            params = {\"user_id\": user_id, \"limit\": limit, \"offset\": offset}\n            for field_name, field_value in filters.items():\n                param_name = f\"filter_{field_name}\"\n                match_clause += f\", {field_name}: ${param_name}\"\n                params[param_name] = field_value\n\n            match_clause += \"})\"\n\n            # Build complete query\n            cypher_query = f\"\"\"\n            {match_clause}\n            RETURN n.id as id,\n                   n.user_id as user_id,\n                   n.memory_type as memory_type,\n                   n.created_at as created_at,\n                   n.updated_at as updated_at,\n                   n as node\n            ORDER BY n.created_at DESC\n            SKIP $offset\n            LIMIT $limit\n            \"\"\"\n\n            return self.query(cypher_query, params)\n\n        except Exception as e:\n            raise DatabaseError(\n                \"Failed to get nodes from Kuzu\",\n                operation=\"get_nodes\",\n                context={\n                    \"user_id\": user_id,\n                    \"node_type\": node_type,\n                    \"filters\": filters,\n                    \"limit\": limit,\n                    \"offset\": offset,\n                },\n                original_error=e,\n            ) from e\n\n    def _get_kuzu_type(self, key: str, value: Any) -&gt; str:\n        \"\"\"Map Python types to Kuzu types with proper validation.\n\n        Args:\n            key: Property key name.\n            value: Property value to type-check.\n\n        Returns:\n            str: Kuzu type name.\n\n        Raises:\n            DatabaseError: If the Python type is not supported by Kuzu.\n        \"\"\"\n        if isinstance(value, bool):\n            # Check bool first (bool is subclass of int in Python!)\n            return \"BOOLEAN\"\n        if isinstance(value, int):\n            return \"INT64\"\n        if isinstance(value, float):\n            return \"DOUBLE\"\n        if isinstance(value, str):\n            return \"STRING\"\n        if value is None:\n            # None values need special handling - default to STRING for now\n            return \"STRING\"\n        # Unsupported type - fail explicitly instead of silent STRING conversion\n        raise DatabaseError(\n            f\"Unsupported property type for key '{key}': {type(value).__name__}. \"\n            f\"Supported types: str, int, float, bool. \"\n            f\"Complex types must be serialized before storage.\",\n            operation=\"_get_kuzu_type\",\n            context={\"key\": key, \"value\": value, \"type\": type(value).__name__},\n        )\n\n    def _is_uuid(self, value: str) -&gt; bool:\n        \"\"\"Check if string looks like a UUID (36 chars with hyphens in right positions).\n\n        Args:\n            value: String to check.\n\n        Returns:\n            bool: True if value matches UUID format (8-4-4-4-12 hex pattern), False otherwise.\n        \"\"\"\n        if not isinstance(value, str) or len(value) != 36:\n            return False\n\n        # UUID format: 8-4-4-4-12 (e.g., 550e8400-e29b-41d4-a716-446655440000)\n        uuid_pattern = r\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\"\n        return bool(re.match(uuid_pattern, value, re.IGNORECASE))\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.KuzuInterface.__init__","title":"<code>__init__(connection, yaml_translator=None)</code>","text":"<p>Initialize with pre-created connection.</p> <p>Parameters:</p> Name Type Description Default <code>connection</code> <code>Connection</code> <p>Pre-initialized Kuzu connection from DatabaseClients.</p> required <code>yaml_translator</code> <p>Optional YamlTranslator for relationship operations.</p> <code>None</code> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def __init__(self, connection: kuzu.Connection, yaml_translator=None):\n    \"\"\"Initialize with pre-created connection.\n\n    Args:\n        connection: Pre-initialized Kuzu connection from DatabaseClients.\n        yaml_translator: Optional YamlTranslator for relationship operations.\n    \"\"\"\n    self.conn = connection\n    self.yaml_translator = yaml_translator\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.KuzuInterface.add_node","title":"<code>add_node(table, properties)</code>","text":"<p>Add a node to the graph - pure CRUD operation.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>Node table name.</p> required <code>properties</code> <code>dict[str, Any]</code> <p>Node properties.</p> required <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If node creation fails.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def add_node(self, table: str, properties: dict[str, Any]) -&gt; None:\n    \"\"\"Add a node to the graph - pure CRUD operation.\n\n    Args:\n        table: Node table name.\n        properties: Node properties.\n\n    Raises:\n        DatabaseError: If node creation fails.\n    \"\"\"\n    try:\n        props = \", \".join([f\"{k}: ${k}\" for k in properties])\n        query = f\"CREATE (:{table} {{{props}}})\"\n        self.conn.execute(query, parameters=properties)\n    except Exception as e:\n        raise DatabaseError(\n            f\"Failed to add node to {table}\",\n            operation=\"add_node\",\n            context={\"table\": table, \"properties\": properties},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.KuzuInterface.add_relationship","title":"<code>add_relationship(from_table, to_table, rel_type, from_id, to_id, user_id, props=None)</code>","text":"<p>Add relationship between nodes.</p> <p>Parameters:</p> Name Type Description Default <code>from_table</code> <code>str</code> <p>Source node table name.</p> required <code>to_table</code> <code>str</code> <p>Target node table name.</p> required <code>rel_type</code> <code>str</code> <p>Relationship type.</p> required <code>from_id</code> <code>str</code> <p>Source node ID.</p> required <code>to_id</code> <code>str</code> <p>Target node ID.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>props</code> <code>dict[str, Any] | None</code> <p>Optional relationship properties.</p> <code>None</code> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If relationship creation fails.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def add_relationship(\n    self,\n    from_table: str,\n    to_table: str,\n    rel_type: str,\n    from_id: str,\n    to_id: str,\n    user_id: str,\n    props: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"Add relationship between nodes.\n\n    Args:\n        from_table: Source node table name.\n        to_table: Target node table name.\n        rel_type: Relationship type.\n        from_id: Source node ID.\n        to_id: Target node ID.\n        user_id: User ID for ownership verification.\n        props: Optional relationship properties.\n\n    Raises:\n        DatabaseError: If relationship creation fails.\n    \"\"\"\n    try:\n        props = props or {}\n\n        # VALIDATE RELATIONSHIP AGAINST YAML SCHEMA - crash if invalid\n        if not validate_relation_predicate(rel_type):\n            raise ValueError(\n                f\"Invalid relationship predicate: {rel_type}. Must be defined in YAML schema.\"\n            )\n\n        # Use relationship type as-is (predicates from YAML) - no sanitization\n        # rel_type should already be a valid predicate (e.g., \"REFERENCED_BY\", \"ANNOTATES\")\n\n        # CRITICAL: Verify both nodes belong to the user before creating relationship\n        # First check if both nodes exist and belong to the user\n        check_query = (\n            f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}}), \"\n            f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n            f\"RETURN a.id, b.id\"\n        )\n        check_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n        check_result = self.query(check_query, check_params)\n\n        if not check_result:\n            raise ValueError(\n                f\"Cannot create relationship: one or both memories not found \"\n                f\"or don't belong to user {user_id}\"\n            )\n\n        # Generate relationship table name using YamlTranslator\n        if not self.yaml_translator:\n            raise DatabaseError(\n                \"YamlTranslator required for relationship operations\",\n                operation=\"add_relationship\",\n                context={\n                    \"from_table\": from_table,\n                    \"to_table\": to_table,\n                    \"rel_type\": rel_type,\n                },\n            )\n\n        relationship_table_name = self.yaml_translator.relationship_table_name(\n            source=from_table,\n            predicate=rel_type,\n            target=to_table,\n            directed=True,  # Direction affects semantics but not table naming for now\n        )\n\n        # Now create the relationship using the unique table name\n        prop_str = \", \".join([f\"{k}: ${k}\" for k in props.keys()]) if props else \"\"\n        rel_props = f\" {{{prop_str}}}\" if prop_str else \"\"\n        create_query = (\n            f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}}), \"\n            f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n            f\"CREATE (a)-[:{relationship_table_name}{rel_props}]-&gt;(b)\"\n        )\n        create_params = {\n            \"from_id\": from_id,\n            \"to_id\": to_id,\n            \"user_id\": user_id,\n            **props,\n        }\n        self.conn.execute(create_query, parameters=create_params)\n    except Exception as e:\n        raise DatabaseError(\n            f\"Failed to add relationship {rel_type}\",\n            operation=\"add_relationship\",\n            context={\n                \"from_table\": from_table,\n                \"to_table\": to_table,\n                \"rel_type\": rel_type,\n                \"from_id\": from_id,\n                \"to_id\": to_id,\n            },\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.KuzuInterface.delete_node","title":"<code>delete_node(table, node_uuid, user_id)</code>","text":"<p>Delete a single node by UUID</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def delete_node(self, table: str, node_uuid: str, user_id: str) -&gt; bool:\n    \"\"\"Delete a single node by UUID\"\"\"\n    try:\n        # CRITICAL: Check if node exists AND belongs to user\n        cypher_check = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) RETURN n.id as id\"\n        check_result = self.query(cypher_check, {\"uuid\": node_uuid, \"user_id\": user_id})\n\n        if not check_result:\n            # Node doesn't exist for this user, consider it successfully \"deleted\"\n            return True\n\n        # Delete the node - only if it belongs to the user\n        cypher_delete_node = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) DELETE n\"\n        self.conn.execute(\n            cypher_delete_node, parameters={\"uuid\": node_uuid, \"user_id\": user_id}\n        )\n        return True\n\n    except Exception as e:\n        error_msg = str(e).lower()\n        if \"delete undirected rel\" in error_msg or \"relationship\" in error_msg:\n            # Relationship constraint prevents deletion - this is a REAL FAILURE\n            # Don't lie by returning True - raise explicit error\n            raise DatabaseError(\n                f\"Cannot delete node {node_uuid} from {table}: has existing relationships. \"\n                f\"Delete relationships first or use CASCADE delete if supported.\",\n                operation=\"delete_node\",\n                context={\n                    \"table\": table,\n                    \"node_uuid\": node_uuid,\n                    \"constraint_error\": str(e),\n                },\n                original_error=e,\n            ) from e\n        # Other database error\n        raise DatabaseError(\n            f\"Failed to delete node from {table}\",\n            operation=\"delete_node\",\n            context={\"table\": table, \"node_uuid\": node_uuid, \"user_id\": user_id},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.KuzuInterface.delete_relationship","title":"<code>delete_relationship(from_table, to_table, rel_type, from_id, to_id, user_id)</code>","text":"<p>Delete relationship between nodes.</p> <p>Parameters:</p> Name Type Description Default <code>from_table</code> <code>str</code> <p>Source node table name.</p> required <code>to_table</code> <code>str</code> <p>Target node table name.</p> required <code>rel_type</code> <code>str</code> <p>Relationship type.</p> required <code>from_id</code> <code>str</code> <p>Source node ID.</p> required <code>to_id</code> <code>str</code> <p>Target node ID.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if deletion succeeded, False if relationship not found.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If relationship deletion fails due to system error.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def delete_relationship(\n    self,\n    from_table: str,\n    to_table: str,\n    rel_type: str,\n    from_id: str,\n    to_id: str,\n    user_id: str,\n) -&gt; bool:\n    \"\"\"Delete relationship between nodes.\n\n    Args:\n        from_table: Source node table name.\n        to_table: Target node table name.\n        rel_type: Relationship type.\n        from_id: Source node ID.\n        to_id: Target node ID.\n        user_id: User ID for ownership verification.\n\n    Returns:\n        bool: True if deletion succeeded, False if relationship not found.\n\n    Raises:\n        DatabaseError: If relationship deletion fails due to system error.\n    \"\"\"\n    try:\n        # VALIDATE RELATIONSHIP AGAINST YAML SCHEMA - crash if invalid\n        if not validate_relation_predicate(rel_type):\n            raise ValueError(\n                f\"Invalid relationship predicate: {rel_type}. Must be defined in YAML schema.\"\n            )\n\n        # CRITICAL: Verify both nodes belong to the user before deleting relationship\n        # First check if both nodes exist and belong to the user\n        check_query = (\n            f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}}), \"\n            f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n            f\"RETURN a.id, b.id\"\n        )\n        check_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n        check_result = self.query(check_query, check_params)\n\n        if not check_result:\n            # Nodes don't exist or don't belong to user - return False (not found)\n            return False\n\n        # Generate relationship table name using YamlTranslator\n        if not self.yaml_translator:\n            raise DatabaseError(\n                \"YamlTranslator required for relationship operations\",\n                operation=\"delete_relationship\",\n                context={\n                    \"from_table\": from_table,\n                    \"to_table\": to_table,\n                    \"rel_type\": rel_type,\n                },\n            )\n\n        relationship_table_name = self.yaml_translator.relationship_table_name(\n            source=from_table,\n            predicate=rel_type,\n            target=to_table,\n            directed=True,  # Direction affects semantics but not table naming for now\n        )\n\n        # First check if the relationship exists\n        check_rel_query = (\n            f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}})\"\n            f\"-[r:{relationship_table_name}]-&gt;\"\n            f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n            f\"RETURN r\"\n        )\n        check_rel_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n\n        # Check if relationship exists\n        relationship_exists = self.query(check_rel_query, check_rel_params)\n        if not relationship_exists:\n            # Relationship doesn't exist - return False\n            return False\n\n        # Delete the specific relationship (we know it exists)\n        delete_query = (\n            f\"MATCH (a:{from_table} {{id: $from_id, user_id: $user_id}})\"\n            f\"-[r:{relationship_table_name}]-&gt;\"\n            f\"(b:{to_table} {{id: $to_id, user_id: $user_id}}) \"\n            f\"DELETE r\"\n        )\n        delete_params = {\"from_id\": from_id, \"to_id\": to_id, \"user_id\": user_id}\n\n        # Execute deletion\n        self.conn.execute(delete_query, parameters=delete_params)\n\n        # If we get here, deletion succeeded\n        return True\n\n    except Exception as e:\n        if isinstance(e, ValueError):\n            # Re-raise validation errors as-is\n            raise\n        raise DatabaseError(\n            f\"Failed to delete relationship {rel_type}\",\n            operation=\"delete_relationship\",\n            context={\n                \"from_table\": from_table,\n                \"to_table\": to_table,\n                \"rel_type\": rel_type,\n                \"from_id\": from_id,\n                \"to_id\": to_id,\n            },\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.KuzuInterface.get_nodes","title":"<code>get_nodes(user_id, node_type=None, filters=None, limit=50, offset=0)</code>","text":"<p>Get multiple nodes with filtering and pagination.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>node_type</code> <code>str | None</code> <p>Optional node type filter (e.g., \"task\", \"note\").</p> <code>None</code> <code>filters</code> <code>dict[str, Any] | None</code> <p>Optional field filters (e.g., {\"status\": \"open\"}).</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of nodes to return.</p> <code>50</code> <code>offset</code> <code>int</code> <p>Number of nodes to skip for pagination.</p> <code>0</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: List of node data from Kuzu.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If node retrieval fails.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def get_nodes(\n    self,\n    user_id: str,\n    node_type: str | None = None,\n    filters: dict[str, Any] | None = None,\n    limit: int = 50,\n    offset: int = 0,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Get multiple nodes with filtering and pagination.\n\n    Args:\n        user_id: User ID for ownership verification.\n        node_type: Optional node type filter (e.g., \"task\", \"note\").\n        filters: Optional field filters (e.g., {\"status\": \"open\"}).\n        limit: Maximum number of nodes to return.\n        offset: Number of nodes to skip for pagination.\n\n    Returns:\n        list[dict[str, Any]]: List of node data from Kuzu.\n\n    Raises:\n        DatabaseError: If node retrieval fails.\n    \"\"\"\n    try:\n        filters = filters or {}\n\n        # Build MATCH clause\n        if node_type:\n            match_clause = f\"MATCH (n:{node_type} {{user_id: $user_id\"\n        else:\n            match_clause = \"MATCH (n {user_id: $user_id\"\n\n        # Add field filters\n        params = {\"user_id\": user_id, \"limit\": limit, \"offset\": offset}\n        for field_name, field_value in filters.items():\n            param_name = f\"filter_{field_name}\"\n            match_clause += f\", {field_name}: ${param_name}\"\n            params[param_name] = field_value\n\n        match_clause += \"})\"\n\n        # Build complete query\n        cypher_query = f\"\"\"\n        {match_clause}\n        RETURN n.id as id,\n               n.user_id as user_id,\n               n.memory_type as memory_type,\n               n.created_at as created_at,\n               n.updated_at as updated_at,\n               n as node\n        ORDER BY n.created_at DESC\n        SKIP $offset\n        LIMIT $limit\n        \"\"\"\n\n        return self.query(cypher_query, params)\n\n    except Exception as e:\n        raise DatabaseError(\n            \"Failed to get nodes from Kuzu\",\n            operation=\"get_nodes\",\n            context={\n                \"user_id\": user_id,\n                \"node_type\": node_type,\n                \"filters\": filters,\n                \"limit\": limit,\n                \"offset\": offset,\n            },\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.KuzuInterface.neighbors","title":"<code>neighbors(node_label, node_uuid, user_id, rel_types=None, direction='any', limit=10, neighbor_label=None)</code>","text":"<p>Fetch neighbors of a node by UUID only.</p> <p>Parameters:</p> Name Type Description Default <code>node_label</code> <code>str</code> <p>Node type/table name (e.g., \"Memory\", \"bug\") - NOT a UUID.</p> required <code>node_uuid</code> <code>str</code> <p>UUID of the specific node to find neighbors for.</p> required <code>user_id</code> <code>str</code> <p>User ID for isolation - only return neighbors belonging to this user.</p> required <code>rel_types</code> <code>list[str] | None</code> <p>List of relationship types to filter by.</p> <code>None</code> <code>direction</code> <code>str</code> <p>\"in\", \"out\", or \"any\" for relationship direction.</p> <code>'any'</code> <code>limit</code> <code>int</code> <p>Maximum number of neighbors to return.</p> <code>10</code> <code>neighbor_label</code> <code>str | None</code> <p>Type of neighbor nodes to return.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: List of neighbor nodes with relationship info.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If node_label is a UUID or node_uuid is not a UUID.</p> <code>DatabaseError</code> <p>If neighbor query fails.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def neighbors(\n    self,\n    node_label: str,\n    node_uuid: str,\n    user_id: str,\n    rel_types: list[str] | None = None,\n    direction: str = \"any\",\n    limit: int = 10,\n    neighbor_label: str | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Fetch neighbors of a node by UUID only.\n\n    Args:\n        node_label: Node type/table name (e.g., \"Memory\", \"bug\") - NOT a UUID.\n        node_uuid: UUID of the specific node to find neighbors for.\n        user_id: User ID for isolation - only return neighbors belonging to this user.\n        rel_types: List of relationship types to filter by.\n        direction: \"in\", \"out\", or \"any\" for relationship direction.\n        limit: Maximum number of neighbors to return.\n        neighbor_label: Type of neighbor nodes to return.\n\n    Returns:\n        list[dict[str, Any]]: List of neighbor nodes with relationship info.\n\n    Raises:\n        ValueError: If node_label is a UUID or node_uuid is not a UUID.\n        DatabaseError: If neighbor query fails.\n    \"\"\"\n    # Validate parameters to prevent common bugs\n    if self._is_uuid(node_label):\n        raise ValueError(\n            f\"node_label must be a node type (e.g., 'Memory', 'bug'), not UUID: {node_label}. \"\n            f\"UUIDs should be passed as node_uuid parameter.\"\n        )\n\n    if not self._is_uuid(node_uuid):\n        raise ValueError(f\"node_uuid must be a valid UUID format, got: {node_uuid}\")\n\n    try:\n        # Use YamlTranslator to expand predicates to concrete relationship labels\n        if not self.yaml_translator:\n            raise DatabaseError(\n                \"YamlTranslator required for neighbor operations\",\n                operation=\"neighbors\",\n                context={\"node_label\": node_label, \"rel_types\": rel_types},\n            )\n\n        # Get concrete relationship labels for this source and predicates\n        if rel_types:\n            relationship_labels = self.yaml_translator.get_labels_for_predicates(\n                source_type=node_label,\n                predicates=rel_types,\n                neighbor_label=neighbor_label,\n            )\n            if not relationship_labels:\n                # No matching relationships found - return empty\n                return []\n\n            # Create relationship pattern with specific labels\n            rel_filter = \"|\".join(relationship_labels)\n            rel_part = f\":{rel_filter}\"\n        else:\n            # No filtering - match all relationships\n            rel_part = \"\"\n\n        # CRITICAL: User isolation - both source node and neighbors must belong to user\n        node_condition = f\"a:{node_label} {{id: $node_uuid, user_id: $user_id}}\"\n        neighbor = f\":{neighbor_label}\" if neighbor_label else \"\"\n        neighbor_condition = f\"n{neighbor} {{user_id: $user_id}}\"\n\n        # Build direction-aware pattern\n        if direction == \"out\":\n            pattern = f\"({node_condition})-[r{rel_part}]-&gt;({neighbor_condition})\"\n        elif direction == \"in\":\n            pattern = f\"({node_condition})&lt;-[r{rel_part}]-({neighbor_condition})\"\n        else:\n            pattern = f\"({node_condition})-[r{rel_part}]-({neighbor_condition})\"\n\n        # Return neighbors only if they belong to the same user\n        cypher = f\"\"\"\n        MATCH {pattern}\n        RETURN DISTINCT n.id as id,\n                        n.user_id as user_id,\n                        n.memory_type as memory_type,\n                        n.created_at as created_at,\n                        label(r) as rel_type,\n                        n as node\n        LIMIT $limit\n        \"\"\"\n        params = {\"node_uuid\": node_uuid, \"user_id\": user_id, \"limit\": limit}\n        return self.query(cypher, params)\n    except Exception as e:\n        raise DatabaseError(\n            \"Failed to fetch neighbors\",\n            operation=\"neighbors\",\n            context={\n                \"node_label\": node_label,\n                \"node_uuid\": node_uuid,\n                \"user_id\": user_id,\n                \"rel_types\": rel_types,\n                \"direction\": direction,\n            },\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.KuzuInterface.query","title":"<code>query(cypher, params=None)</code>","text":"<p>Execute Cypher query and return results.</p> <p>Parameters:</p> Name Type Description Default <code>cypher</code> <code>str</code> <p>Cypher query string.</p> required <code>params</code> <code>dict[str, Any] | None</code> <p>Query parameters.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: Query results.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If query execution fails.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def query(self, cypher: str, params: dict[str, Any] | None = None) -&gt; list[dict[str, Any]]:\n    \"\"\"Execute Cypher query and return results.\n\n    Args:\n        cypher: Cypher query string.\n        params: Query parameters.\n\n    Returns:\n        list[dict[str, Any]]: Query results.\n\n    Raises:\n        DatabaseError: If query execution fails.\n    \"\"\"\n    try:\n        qr = self.conn.execute(cypher, parameters=params or {})\n        return self._extract_query_results(qr)\n    except Exception as e:\n        raise DatabaseError(\n            \"Failed to execute Kuzu query\",\n            operation=\"query\",\n            context={\"cypher\": cypher, \"params\": params},\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.KuzuInterface.update_node","title":"<code>update_node(table, node_uuid, properties, user_id)</code>","text":"<p>Update a node in the graph - pure CRUD operation.</p> <p>Parameters:</p> Name Type Description Default <code>table</code> <code>str</code> <p>Node table name.</p> required <code>node_uuid</code> <code>str</code> <p>UUID of the node to update.</p> required <code>properties</code> <code>dict[str, Any]</code> <p>Node properties to update.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if update succeeded, False if node not found.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If node update fails due to system error.</p> Source code in <code>src/memg_core/core/interfaces/kuzu.py</code> <pre><code>def update_node(\n    self, table: str, node_uuid: str, properties: dict[str, Any], user_id: str\n) -&gt; bool:\n    \"\"\"Update a node in the graph - pure CRUD operation.\n\n    Args:\n        table: Node table name.\n        node_uuid: UUID of the node to update.\n        properties: Node properties to update.\n        user_id: User ID for ownership verification.\n\n    Returns:\n        bool: True if update succeeded, False if node not found.\n\n    Raises:\n        DatabaseError: If node update fails due to system error.\n    \"\"\"\n    try:\n        # CRITICAL: Check if node exists AND belongs to user\n        check_query = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) RETURN n.id as id\"\n        check_result = self.query(check_query, {\"uuid\": node_uuid, \"user_id\": user_id})\n\n        if not check_result:\n            # Node doesn't exist for this user\n            return False\n\n        # Build SET clause for properties\n        set_clauses = []\n        params = {\"uuid\": node_uuid, \"user_id\": user_id}\n\n        for key, value in properties.items():\n            # Skip system fields that shouldn't be updated via this method\n            if key in (\"id\", \"user_id\"):\n                continue\n\n            param_name = f\"prop_{key}\"\n            set_clauses.append(f\"n.{key} = ${param_name}\")\n            params[param_name] = value\n\n        if not set_clauses:\n            # No properties to update (all were system fields)\n            return True\n\n        # Execute update query\n        set_clause = \", \".join(set_clauses)\n        update_query = f\"MATCH (n:{table} {{id: $uuid, user_id: $user_id}}) SET {set_clause}\"\n        self.conn.execute(update_query, parameters=params)\n\n        return True\n\n    except Exception as e:\n        raise DatabaseError(\n            f\"Failed to update node in {table}\",\n            operation=\"update_node\",\n            context={\n                \"table\": table,\n                \"node_uuid\": node_uuid,\n                \"properties\": properties,\n                \"user_id\": user_id,\n            },\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.QdrantInterface","title":"<code>QdrantInterface</code>","text":"<p>Pure CRUD wrapper around QdrantClient - NO DDL operations.</p> <p>Attributes:</p> Name Type Description <code>client</code> <p>Pre-initialized QdrantClient.</p> <code>collection_name</code> <p>Name of the Qdrant collection.</p> Source code in <code>src/memg_core/core/interfaces/qdrant.py</code> <pre><code>class QdrantInterface:\n    \"\"\"Pure CRUD wrapper around QdrantClient - NO DDL operations.\n\n    Attributes:\n        client: Pre-initialized QdrantClient.\n        collection_name: Name of the Qdrant collection.\n    \"\"\"\n\n    def __init__(self, client: QdrantClient, collection_name: str):\n        \"\"\"Initialize with pre-created client and collection.\n\n        Args:\n            client: Pre-initialized QdrantClient from DatabaseClients.\n            collection_name: Name of pre-created collection.\n        \"\"\"\n        self.client = client\n        self.collection_name = collection_name\n\n    def add_point(\n        self,\n        vector: list[float],\n        payload: dict[str, Any],\n        point_id: str | None = None,\n        collection: str | None = None,\n    ) -&gt; tuple[bool, str]:\n        \"\"\"Add a single point to collection - pure CRUD operation.\n\n        Args:\n            vector: Embedding vector.\n            payload: Point payload data.\n            point_id: Optional point ID (auto-generated if None).\n            collection: Optional collection name override.\n\n        Returns:\n            tuple[bool, str]: (success, point_id) where success indicates if operation succeeded.\n\n        Raises:\n            DatabaseError: If point addition fails.\n        \"\"\"\n        try:\n            collection = collection or self.collection_name\n\n            if point_id is None:\n                point_id = str(uuid.uuid4())\n\n            # Create PointStruct with VectorStruct\n            point = PointStruct(id=point_id, vector=vector, payload=payload)\n            result = self.client.upsert(collection_name=collection, points=[point])\n\n            # print(\"Qdrant result\", result)\n\n            # Determine success from returned UpdateResult status\n            success = True\n            status = getattr(result, \"status\", None)\n            if status is not None:\n                status_str = (\n                    getattr(status, \"value\", None) or getattr(status, \"name\", None) or str(status)\n                )\n                status_str = str(status_str).lower()\n                success = status_str in (\"acknowledged\", \"completed\")\n\n            return success, point_id\n\n        except Exception as e:\n            raise DatabaseError(\n                \"Qdrant add_point error\",\n                operation=\"add_point\",\n                original_error=e,\n            ) from e\n\n    def search_points(\n        self,\n        vector: list[float],\n        limit: int = 5,\n        collection: str | None = None,\n        filters: dict[str, Any] | None = None,\n        score_threshold: float | None = None,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"Search for similar points with mandatory user isolation - pure CRUD operation.\n\n        Args:\n            vector: Query embedding vector.\n            limit: Maximum number of results.\n            collection: Optional collection name override.\n            filters: Search filters (must include user_id for security).\n            score_threshold: Minimum similarity score threshold (0.0-1.0).\n\n        Returns:\n            list[dict[str, Any]]: List of search results with id, score, and payload.\n\n        Raises:\n            DatabaseError: If search fails or user_id is missing from filters.\n        \"\"\"\n        try:\n            # CRITICAL SECURITY: Validate user_id is present in filters\n            if not filters or \"user_id\" not in filters:\n                raise DatabaseError(\n                    \"user_id is mandatory in filters for data isolation\",\n                    operation=\"search_points_validation\",\n                    context={\"filters\": filters},\n                )\n\n            user_id = filters[\"user_id\"]\n            if not user_id or not isinstance(user_id, str) or not user_id.strip():\n                raise DatabaseError(\n                    \"user_id must be a non-empty string\",\n                    operation=\"search_points_validation\",\n                    context={\"user_id\": user_id},\n                )\n\n            collection = collection or self.collection_name\n\n            # Build query filter\n            query_filter = None\n            filter_conditions = []\n\n            # Add user_id filter - flat payload structure (always required)\n            filter_conditions.append(FieldCondition(key=\"user_id\", match=MatchValue(value=user_id)))\n\n            # Add additional filters (skip user_id since it's already added)\n            for key, value in filters.items():\n                if key == \"user_id\" or value is None:\n                    continue\n                # Handle range filters\n                if isinstance(value, dict):\n                    range_kwargs = {}\n                    for bound_key in (\"gt\", \"gte\", \"lt\", \"lte\"):\n                        if bound_key in value and value[bound_key] is not None:\n                            range_kwargs[bound_key] = value[bound_key]\n                    if range_kwargs:\n                        filter_conditions.append(\n                            FieldCondition(key=key, range=Range(**range_kwargs))\n                        )\n                        continue\n                # Handle list values\n                if isinstance(value, list):\n                    filter_conditions.append(FieldCondition(key=key, match=MatchAny(any=value)))\n                elif not isinstance(value, dict):  # Skip dict values that weren't handled as ranges\n                    filter_conditions.append(FieldCondition(key=key, match=MatchValue(value=value)))\n\n            if filter_conditions:\n                # Use type ignore for the Filter argument type mismatch\n                query_filter = Filter(must=filter_conditions)  # type: ignore\n\n            # Search using modern API\n            results = self.client.query_points(\n                collection_name=collection,\n                query=vector,\n                limit=limit,\n                query_filter=query_filter,\n                score_threshold=score_threshold,\n            ).points\n\n            # Convert to simplified results (score_threshold already applied by Qdrant)\n            return [\n                {\n                    \"id\": str(result.id),\n                    \"score\": result.score,\n                    \"payload\": result.payload,\n                }\n                for result in results\n            ]\n\n        except Exception as e:\n            raise DatabaseError(\n                \"Qdrant search_points error\",\n                operation=\"search_points\",\n                original_error=e,\n            ) from e\n\n    def get_point(self, point_id: str, collection: str | None = None) -&gt; dict[str, Any] | None:\n        \"\"\"Get a single point by ID - pure CRUD operation.\n\n        Args:\n            point_id: ID of the point to retrieve.\n            collection: Optional collection name override.\n\n        Returns:\n            dict[str, Any] | None: Point data including id, vector, and payload, or None if not found.\n\n        Raises:\n            DatabaseError: If retrieval fails.\n        \"\"\"\n        try:\n            collection = collection or self.collection_name\n\n            result = self.client.retrieve(\n                collection_name=collection,\n                ids=[point_id],\n            )\n\n            if result:\n                point = result[0]\n                return {\n                    \"id\": str(point.id),\n                    \"vector\": point.vector,\n                    \"payload\": point.payload,\n                }\n            return None\n        except Exception as e:\n            raise DatabaseError(\n                \"Qdrant get_point error\",\n                operation=\"get_point\",\n                original_error=e,\n            ) from e\n\n    def delete_points(\n        self, point_ids: list[str], user_id: str, collection: str | None = None\n    ) -&gt; bool:\n        \"\"\"Delete points by IDs with user ownership verification.\n\n        Args:\n            point_ids: List of point IDs to delete.\n            user_id: User ID for ownership verification.\n            collection: Optional collection name override.\n\n        Returns:\n            bool: True if deletion succeeded.\n\n        Raises:\n            DatabaseError: If points not found or don't belong to user, or deletion fails.\n        \"\"\"\n        try:\n            collection = collection or self.collection_name\n\n            # CRITICAL: Verify user ownership before deletion\n            # First, verify all points belong to the user\n            for point_id in point_ids:\n                points = self.client.retrieve(\n                    collection_name=collection, ids=[point_id], with_payload=True\n                )\n\n                if not points or not (\n                    points[0].payload and points[0].payload.get(\"user_id\") == user_id\n                ):\n                    raise DatabaseError(\n                        f\"Point {point_id} not found or doesn't belong to user {user_id}\",\n                        operation=\"delete_points\",\n                        context={\"point_id\": point_id, \"user_id\": user_id},\n                    )\n\n            # If all points belong to user, proceed with deletion\n            self.client.delete(\n                collection_name=collection,\n                points_selector=PointIdsList(points=[str(pid) for pid in point_ids]),\n            )\n            return True\n        except Exception as e:\n            raise DatabaseError(\n                \"Qdrant delete_points error\",\n                operation=\"delete_points\",\n                original_error=e,\n            ) from e\n\n    def get_collection_info(self, collection: str | None = None) -&gt; dict[str, Any]:\n        \"\"\"Get collection information - pure read operation.\n\n        Args:\n            collection: Optional collection name override.\n\n        Returns:\n            dict[str, Any]: Collection information including existence, vector count, point count, and config.\n\n        Raises:\n            DatabaseError: If collection info retrieval fails.\n        \"\"\"\n        try:\n            collection = collection or self.collection_name\n\n            info = self.client.get_collection(collection_name=collection)\n            # Handle different types of vector params\n            vector_size = None\n            vector_distance = None\n\n            vectors_param = info.config.params.vectors\n            if vectors_param is not None:\n                if hasattr(vectors_param, \"size\"):\n                    vector_size = vectors_param.size  # type: ignore\n                    vector_distance = vectors_param.distance  # type: ignore\n                elif isinstance(vectors_param, dict):\n                    # For multi-vector collections, use the first vector's params\n                    if vectors_param:\n                        vector_values = list(vectors_param.values())\n                        if vector_values:\n                            first_vector = vector_values[0]\n                            vector_size = first_vector.size\n                            vector_distance = first_vector.distance\n\n            return {\n                \"exists\": True,\n                \"vectors_count\": info.vectors_count,\n                \"points_count\": info.points_count,\n                \"config\": {\n                    \"vector_size\": vector_size,\n                    \"distance\": vector_distance,\n                },\n            }\n        except Exception as e:\n            raise DatabaseError(\n                \"Qdrant get_collection_info error\",\n                operation=\"get_collection_info\",\n                original_error=e,\n            ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.QdrantInterface.__init__","title":"<code>__init__(client, collection_name)</code>","text":"<p>Initialize with pre-created client and collection.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>QdrantClient</code> <p>Pre-initialized QdrantClient from DatabaseClients.</p> required <code>collection_name</code> <code>str</code> <p>Name of pre-created collection.</p> required Source code in <code>src/memg_core/core/interfaces/qdrant.py</code> <pre><code>def __init__(self, client: QdrantClient, collection_name: str):\n    \"\"\"Initialize with pre-created client and collection.\n\n    Args:\n        client: Pre-initialized QdrantClient from DatabaseClients.\n        collection_name: Name of pre-created collection.\n    \"\"\"\n    self.client = client\n    self.collection_name = collection_name\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.QdrantInterface.add_point","title":"<code>add_point(vector, payload, point_id=None, collection=None)</code>","text":"<p>Add a single point to collection - pure CRUD operation.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>list[float]</code> <p>Embedding vector.</p> required <code>payload</code> <code>dict[str, Any]</code> <p>Point payload data.</p> required <code>point_id</code> <code>str | None</code> <p>Optional point ID (auto-generated if None).</p> <code>None</code> <code>collection</code> <code>str | None</code> <p>Optional collection name override.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[bool, str]</code> <p>tuple[bool, str]: (success, point_id) where success indicates if operation succeeded.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If point addition fails.</p> Source code in <code>src/memg_core/core/interfaces/qdrant.py</code> <pre><code>def add_point(\n    self,\n    vector: list[float],\n    payload: dict[str, Any],\n    point_id: str | None = None,\n    collection: str | None = None,\n) -&gt; tuple[bool, str]:\n    \"\"\"Add a single point to collection - pure CRUD operation.\n\n    Args:\n        vector: Embedding vector.\n        payload: Point payload data.\n        point_id: Optional point ID (auto-generated if None).\n        collection: Optional collection name override.\n\n    Returns:\n        tuple[bool, str]: (success, point_id) where success indicates if operation succeeded.\n\n    Raises:\n        DatabaseError: If point addition fails.\n    \"\"\"\n    try:\n        collection = collection or self.collection_name\n\n        if point_id is None:\n            point_id = str(uuid.uuid4())\n\n        # Create PointStruct with VectorStruct\n        point = PointStruct(id=point_id, vector=vector, payload=payload)\n        result = self.client.upsert(collection_name=collection, points=[point])\n\n        # print(\"Qdrant result\", result)\n\n        # Determine success from returned UpdateResult status\n        success = True\n        status = getattr(result, \"status\", None)\n        if status is not None:\n            status_str = (\n                getattr(status, \"value\", None) or getattr(status, \"name\", None) or str(status)\n            )\n            status_str = str(status_str).lower()\n            success = status_str in (\"acknowledged\", \"completed\")\n\n        return success, point_id\n\n    except Exception as e:\n        raise DatabaseError(\n            \"Qdrant add_point error\",\n            operation=\"add_point\",\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.QdrantInterface.delete_points","title":"<code>delete_points(point_ids, user_id, collection=None)</code>","text":"<p>Delete points by IDs with user ownership verification.</p> <p>Parameters:</p> Name Type Description Default <code>point_ids</code> <code>list[str]</code> <p>List of point IDs to delete.</p> required <code>user_id</code> <code>str</code> <p>User ID for ownership verification.</p> required <code>collection</code> <code>str | None</code> <p>Optional collection name override.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if deletion succeeded.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If points not found or don't belong to user, or deletion fails.</p> Source code in <code>src/memg_core/core/interfaces/qdrant.py</code> <pre><code>def delete_points(\n    self, point_ids: list[str], user_id: str, collection: str | None = None\n) -&gt; bool:\n    \"\"\"Delete points by IDs with user ownership verification.\n\n    Args:\n        point_ids: List of point IDs to delete.\n        user_id: User ID for ownership verification.\n        collection: Optional collection name override.\n\n    Returns:\n        bool: True if deletion succeeded.\n\n    Raises:\n        DatabaseError: If points not found or don't belong to user, or deletion fails.\n    \"\"\"\n    try:\n        collection = collection or self.collection_name\n\n        # CRITICAL: Verify user ownership before deletion\n        # First, verify all points belong to the user\n        for point_id in point_ids:\n            points = self.client.retrieve(\n                collection_name=collection, ids=[point_id], with_payload=True\n            )\n\n            if not points or not (\n                points[0].payload and points[0].payload.get(\"user_id\") == user_id\n            ):\n                raise DatabaseError(\n                    f\"Point {point_id} not found or doesn't belong to user {user_id}\",\n                    operation=\"delete_points\",\n                    context={\"point_id\": point_id, \"user_id\": user_id},\n                )\n\n        # If all points belong to user, proceed with deletion\n        self.client.delete(\n            collection_name=collection,\n            points_selector=PointIdsList(points=[str(pid) for pid in point_ids]),\n        )\n        return True\n    except Exception as e:\n        raise DatabaseError(\n            \"Qdrant delete_points error\",\n            operation=\"delete_points\",\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.QdrantInterface.get_collection_info","title":"<code>get_collection_info(collection=None)</code>","text":"<p>Get collection information - pure read operation.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>str | None</code> <p>Optional collection name override.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>dict[str, Any]: Collection information including existence, vector count, point count, and config.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If collection info retrieval fails.</p> Source code in <code>src/memg_core/core/interfaces/qdrant.py</code> <pre><code>def get_collection_info(self, collection: str | None = None) -&gt; dict[str, Any]:\n    \"\"\"Get collection information - pure read operation.\n\n    Args:\n        collection: Optional collection name override.\n\n    Returns:\n        dict[str, Any]: Collection information including existence, vector count, point count, and config.\n\n    Raises:\n        DatabaseError: If collection info retrieval fails.\n    \"\"\"\n    try:\n        collection = collection or self.collection_name\n\n        info = self.client.get_collection(collection_name=collection)\n        # Handle different types of vector params\n        vector_size = None\n        vector_distance = None\n\n        vectors_param = info.config.params.vectors\n        if vectors_param is not None:\n            if hasattr(vectors_param, \"size\"):\n                vector_size = vectors_param.size  # type: ignore\n                vector_distance = vectors_param.distance  # type: ignore\n            elif isinstance(vectors_param, dict):\n                # For multi-vector collections, use the first vector's params\n                if vectors_param:\n                    vector_values = list(vectors_param.values())\n                    if vector_values:\n                        first_vector = vector_values[0]\n                        vector_size = first_vector.size\n                        vector_distance = first_vector.distance\n\n        return {\n            \"exists\": True,\n            \"vectors_count\": info.vectors_count,\n            \"points_count\": info.points_count,\n            \"config\": {\n                \"vector_size\": vector_size,\n                \"distance\": vector_distance,\n            },\n        }\n    except Exception as e:\n        raise DatabaseError(\n            \"Qdrant get_collection_info error\",\n            operation=\"get_collection_info\",\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.QdrantInterface.get_point","title":"<code>get_point(point_id, collection=None)</code>","text":"<p>Get a single point by ID - pure CRUD operation.</p> <p>Parameters:</p> Name Type Description Default <code>point_id</code> <code>str</code> <p>ID of the point to retrieve.</p> required <code>collection</code> <code>str | None</code> <p>Optional collection name override.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>dict[str, Any] | None: Point data including id, vector, and payload, or None if not found.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If retrieval fails.</p> Source code in <code>src/memg_core/core/interfaces/qdrant.py</code> <pre><code>def get_point(self, point_id: str, collection: str | None = None) -&gt; dict[str, Any] | None:\n    \"\"\"Get a single point by ID - pure CRUD operation.\n\n    Args:\n        point_id: ID of the point to retrieve.\n        collection: Optional collection name override.\n\n    Returns:\n        dict[str, Any] | None: Point data including id, vector, and payload, or None if not found.\n\n    Raises:\n        DatabaseError: If retrieval fails.\n    \"\"\"\n    try:\n        collection = collection or self.collection_name\n\n        result = self.client.retrieve(\n            collection_name=collection,\n            ids=[point_id],\n        )\n\n        if result:\n            point = result[0]\n            return {\n                \"id\": str(point.id),\n                \"vector\": point.vector,\n                \"payload\": point.payload,\n            }\n        return None\n    except Exception as e:\n        raise DatabaseError(\n            \"Qdrant get_point error\",\n            operation=\"get_point\",\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.QdrantInterface.search_points","title":"<code>search_points(vector, limit=5, collection=None, filters=None, score_threshold=None)</code>","text":"<p>Search for similar points with mandatory user isolation - pure CRUD operation.</p> <p>Parameters:</p> Name Type Description Default <code>vector</code> <code>list[float]</code> <p>Query embedding vector.</p> required <code>limit</code> <code>int</code> <p>Maximum number of results.</p> <code>5</code> <code>collection</code> <code>str | None</code> <p>Optional collection name override.</p> <code>None</code> <code>filters</code> <code>dict[str, Any] | None</code> <p>Search filters (must include user_id for security).</p> <code>None</code> <code>score_threshold</code> <code>float | None</code> <p>Minimum similarity score threshold (0.0-1.0).</p> <code>None</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>list[dict[str, Any]]: List of search results with id, score, and payload.</p> <p>Raises:</p> Type Description <code>DatabaseError</code> <p>If search fails or user_id is missing from filters.</p> Source code in <code>src/memg_core/core/interfaces/qdrant.py</code> <pre><code>def search_points(\n    self,\n    vector: list[float],\n    limit: int = 5,\n    collection: str | None = None,\n    filters: dict[str, Any] | None = None,\n    score_threshold: float | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"Search for similar points with mandatory user isolation - pure CRUD operation.\n\n    Args:\n        vector: Query embedding vector.\n        limit: Maximum number of results.\n        collection: Optional collection name override.\n        filters: Search filters (must include user_id for security).\n        score_threshold: Minimum similarity score threshold (0.0-1.0).\n\n    Returns:\n        list[dict[str, Any]]: List of search results with id, score, and payload.\n\n    Raises:\n        DatabaseError: If search fails or user_id is missing from filters.\n    \"\"\"\n    try:\n        # CRITICAL SECURITY: Validate user_id is present in filters\n        if not filters or \"user_id\" not in filters:\n            raise DatabaseError(\n                \"user_id is mandatory in filters for data isolation\",\n                operation=\"search_points_validation\",\n                context={\"filters\": filters},\n            )\n\n        user_id = filters[\"user_id\"]\n        if not user_id or not isinstance(user_id, str) or not user_id.strip():\n            raise DatabaseError(\n                \"user_id must be a non-empty string\",\n                operation=\"search_points_validation\",\n                context={\"user_id\": user_id},\n            )\n\n        collection = collection or self.collection_name\n\n        # Build query filter\n        query_filter = None\n        filter_conditions = []\n\n        # Add user_id filter - flat payload structure (always required)\n        filter_conditions.append(FieldCondition(key=\"user_id\", match=MatchValue(value=user_id)))\n\n        # Add additional filters (skip user_id since it's already added)\n        for key, value in filters.items():\n            if key == \"user_id\" or value is None:\n                continue\n            # Handle range filters\n            if isinstance(value, dict):\n                range_kwargs = {}\n                for bound_key in (\"gt\", \"gte\", \"lt\", \"lte\"):\n                    if bound_key in value and value[bound_key] is not None:\n                        range_kwargs[bound_key] = value[bound_key]\n                if range_kwargs:\n                    filter_conditions.append(\n                        FieldCondition(key=key, range=Range(**range_kwargs))\n                    )\n                    continue\n            # Handle list values\n            if isinstance(value, list):\n                filter_conditions.append(FieldCondition(key=key, match=MatchAny(any=value)))\n            elif not isinstance(value, dict):  # Skip dict values that weren't handled as ranges\n                filter_conditions.append(FieldCondition(key=key, match=MatchValue(value=value)))\n\n        if filter_conditions:\n            # Use type ignore for the Filter argument type mismatch\n            query_filter = Filter(must=filter_conditions)  # type: ignore\n\n        # Search using modern API\n        results = self.client.query_points(\n            collection_name=collection,\n            query=vector,\n            limit=limit,\n            query_filter=query_filter,\n            score_threshold=score_threshold,\n        ).points\n\n        # Convert to simplified results (score_threshold already applied by Qdrant)\n        return [\n            {\n                \"id\": str(result.id),\n                \"score\": result.score,\n                \"payload\": result.payload,\n            }\n            for result in results\n        ]\n\n    except Exception as e:\n        raise DatabaseError(\n            \"Qdrant search_points error\",\n            operation=\"search_points\",\n            original_error=e,\n        ) from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator","title":"<code>YamlTranslator</code>","text":"<p>Translates YAML schema definitions to Pydantic models for strict validation.</p> <p>Attributes:</p> Name Type Description <code>yaml_path</code> <p>Path to YAML schema file.</p> <code>_schema</code> <code>dict[str, Any] | None</code> <p>Cached schema dictionary.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>class YamlTranslator:\n    \"\"\"Translates YAML schema definitions to Pydantic models for strict validation.\n\n    Attributes:\n        yaml_path: Path to YAML schema file.\n        _schema: Cached schema dictionary.\n    \"\"\"\n\n    def __init__(self, yaml_path: str | None = None) -&gt; None:\n        \"\"\"Initialize YamlTranslator with YAML schema path.\n\n        Args:\n            yaml_path: Path to YAML schema file. If None, uses MEMG_YAML_SCHEMA env var.\n\n        Raises:\n            YamlTranslatorError: If YAML path not provided or TypeRegistry initialization fails.\n        \"\"\"\n        # Require explicit YAML path - no silent defaults\n        if yaml_path:\n            self.yaml_path = yaml_path\n        else:\n            env_path = os.getenv(\"MEMG_YAML_SCHEMA\")\n            if not env_path:\n                raise YamlTranslatorError(\n                    \"YAML schema path required. Set MEMG_YAML_SCHEMA environment variable \"\n                    \"or provide yaml_path parameter. No defaults allowed.\"\n                )\n            self.yaml_path = env_path\n\n        self._schema: dict[str, Any] | None = None\n        # NO model cache - TypeRegistry handles all caching\n\n        # Initialize TypeRegistry from YAML - crash early if invalid\n        try:\n            initialize_types_from_yaml(self.yaml_path)\n        except Exception as e:\n            raise YamlTranslatorError(f\"Failed to initialize TypeRegistry from YAML: {e}\") from e\n\n    @property\n    def schema(self) -&gt; dict[str, Any]:\n        \"\"\"Get the loaded YAML schema, loading it if necessary.\"\"\"\n        if self._schema is not None:\n            return self._schema\n\n        # Load schema from the required path - no fallbacks\n        if not self.yaml_path:\n            raise YamlTranslatorError(\n                \"YAML schema path not set. This should not happen after __init__.\"\n            )\n\n        self._schema = self._load_schema()\n        return self._schema\n\n    def _load_schema(self) -&gt; dict[str, Any]:\n        \"\"\"Load schema from the current yaml_path.\"\"\"\n        if not self.yaml_path:\n            raise YamlTranslatorError(\"YAML path is None\")\n        path = Path(self.yaml_path)\n        if not path.exists():\n            raise YamlTranslatorError(f\"YAML schema not found at {path}\")\n        try:\n            with path.open(encoding=\"utf-8\") as f:\n                data = yaml.safe_load(f)\n            if not data:\n                raise YamlTranslatorError(\"Empty YAML schema\")\n            if not isinstance(data, dict):\n                raise YamlTranslatorError(\"YAML schema root must be a mapping\")\n            return data\n        except yaml.YAMLError as e:\n            raise YamlTranslatorError(f\"Invalid YAML syntax: {e}\") from e\n\n    def _entities_map(self) -&gt; dict[str, dict[str, Any]]:\n        sch = self.schema\n        ents = sch.get(\"entities\")\n        if not ents:\n            return {}\n        if isinstance(ents, dict):\n            # Normalize keys to lower\n            return {str(k).lower(): v for k, v in ents.items()}\n        # list form\n        out: dict[str, dict[str, Any]] = {}\n        for item in ents:\n            if not isinstance(item, dict):\n                continue\n            key = (item.get(\"name\") or item.get(\"type\") or \"\").lower()\n            if key:\n                out[key] = item\n        return out\n\n    def get_entity_types(self) -&gt; list[str]:\n        \"\"\"Get list of available entity types from YAML schema.\"\"\"\n        return list(self._entities_map().keys())\n\n    # ================== RELATIONSHIP PARSING (TARGET-FIRST FORMAT) ==================\n\n    def _get_relations_mapping_for_entity(\n        self, entity_name: str\n    ) -&gt; dict[str, list[dict[str, Any]]]:\n        \"\"\"Return raw relations mapping for an entity in target-first schema format.\n\n        The expected YAML shape under an entity is:\n            relations:\n              target_entity_name:\n                - name: ...\n                  description: ...\n                  predicate: PREDICATE_NAME\n                  directed: true|false\n\n        Returns an empty dict when no relations are defined.\n        \"\"\"\n        entity_spec = self._resolve_entity_with_inheritance(entity_name)\n        relations_section = entity_spec.get(\"relations\")\n        if not relations_section or not isinstance(relations_section, dict):\n            return {}\n\n        # Normalize keys to lower for targets; keep items as-is\n        normalized: dict[str, list[dict[str, Any]]] = {}\n        for target_name, items in relations_section.items():\n            if not isinstance(items, list):\n                # Skip invalid shapes silently at this layer; validation is higher-level\n                continue\n            normalized[str(target_name).lower()] = [i for i in items if isinstance(i, dict)]\n        return normalized\n\n    def get_relations_for_source(self, entity_name: str) -&gt; list[dict[str, Any]]:\n        \"\"\"Get normalized relation specs for a source entity in target-first schema.\n\n        Returns list of dicts with keys:\n            - source (str)\n            - target (str)\n            - name (str | None)\n            - description (str | None)\n            - predicate (str)\n            - directed (bool)\n        \"\"\"\n        if not entity_name:\n            raise YamlTranslatorError(\"Empty entity name\")\n\n        source_l = entity_name.lower()\n        relations_map = self._get_relations_mapping_for_entity(source_l)\n        if not relations_map:\n            return []\n\n        out: list[dict[str, Any]] = []\n        for target_l, items in relations_map.items():\n            for item in items:\n                predicate = item.get(\"predicate\")\n                if not predicate or not isinstance(predicate, str):\n                    # Skip invalid entries - strict behavior can be added later\n                    continue\n                directed = bool(item.get(\"directed\", True))\n                out.append(\n                    {\n                        \"source\": source_l,\n                        \"target\": target_l,\n                        \"name\": item.get(\"name\"),\n                        \"description\": item.get(\"description\"),\n                        \"predicate\": predicate.upper(),\n                        \"directed\": directed,\n                    }\n                )\n        return out\n\n    @staticmethod\n    def relationship_table_name(\n        source: str,\n        predicate: str,\n        target: str,\n        *,\n        directed: bool = True,  # noqa: unused-argument\n    ) -&gt; str:\n        \"\"\"Generate relationship table name.\n\n        For now, table name does not encode direction; direction affects creation/query semantics.\n        Canonicalization for undirected pairs can be added here later if decided.\n        \"\"\"\n        return f\"{str(source).upper()}_{str(predicate).upper()}_{str(target).upper()}\"\n\n    def get_labels_for_predicates(\n        self,\n        source_type: str,\n        predicates: list[str] | None,\n        neighbor_label: str | None = None,\n    ) -&gt; list[str]:\n        \"\"\"Expand predicate names to concrete relationship labels for a given source.\n\n        Args:\n            source_type: Source entity type name\n            predicates: List of predicate names to include (case-insensitive). If None, include all.\n            neighbor_label: Optional target entity type filter (case-insensitive)\n\n        Returns:\n            List of concrete relationship labels (table names) matching the filter.\n        \"\"\"\n        if not source_type:\n            raise YamlTranslatorError(\"Empty source_type\")\n\n        preds_u = set(p.upper() for p in predicates) if predicates else None\n        neighbor_l = neighbor_label.lower() if neighbor_label else None\n\n        labels: list[str] = []\n        for spec in self.get_relations_for_source(source_type):\n            if preds_u is not None and spec[\"predicate\"].upper() not in preds_u:\n                continue\n            if neighbor_l is not None and spec[\"target\"].lower() != neighbor_l:\n                continue\n            labels.append(\n                self.relationship_table_name(\n                    source=spec[\"source\"],\n                    predicate=spec[\"predicate\"],\n                    target=spec[\"target\"],\n                    directed=spec[\"directed\"],\n                )\n            )\n        return labels\n\n    def debug_relation_map(self) -&gt; dict[str, dict[str, list[dict[str, Any]]]]:\n        \"\"\"Return a nested relation map for debugging/printing.\n\n        Structure:\n        {\n          source: {\n            target: [ {name, predicate, directed, description} ... ]\n          }\n        }\n        \"\"\"\n        out: dict[str, dict[str, list[dict[str, Any]]]] = {}\n        for source in self.get_entity_types():\n            specs = self.get_relations_for_source(source)\n            if not specs:\n                continue\n            if source not in out:\n                out[source] = {}\n            for spec in specs:\n                target = spec[\"target\"]\n                out[source].setdefault(target, [])\n                out[source][target].append(\n                    {\n                        \"name\": spec.get(\"name\"),\n                        \"predicate\": spec.get(\"predicate\"),\n                        \"directed\": spec.get(\"directed\", True),\n                        \"description\": spec.get(\"description\"),\n                    }\n                )\n        return out\n\n    def get_anchor_field(self, entity_name: str) -&gt; str:\n        \"\"\"Get the anchor field name for the given entity type from YAML schema.\n\n        Now reads from vector.anchored_to instead of separate anchor field.\n\n        Args:\n            entity_name: Name of the entity type.\n\n        Returns:\n            str: Anchor field name.\n\n        Raises:\n            YamlTranslatorError: If anchor field not found.\n        \"\"\"\n        if not entity_name:\n            raise YamlTranslatorError(\"Empty entity name\")\n\n        # Get entity spec with inheritance resolution\n        entity_spec = self._resolve_entity_with_inheritance(entity_name)\n\n        # Look for vector field with anchored_to\n        fields = entity_spec.get(\"fields\", {})\n        for _field_name, field_def in fields.items():\n            if isinstance(field_def, dict) and field_def.get(\"type\") == \"vector\":\n                anchored_to = field_def.get(\"anchored_to\")\n                if anchored_to:\n                    return str(anchored_to)\n\n        raise YamlTranslatorError(\n            f\"Entity '{entity_name}' has no vector field with 'anchored_to' property\"\n        )\n\n    def _resolve_entity_with_inheritance(self, entity_name: str) -&gt; dict[str, Any]:\n        \"\"\"Resolve entity specification with full inheritance chain.\"\"\"\n        name_l = entity_name.lower()\n        emap = self._entities_map()\n        spec_raw = emap.get(name_l)\n        if not spec_raw:\n            raise YamlTranslatorError(f\"Entity '{entity_name}' not found in YAML schema\")\n\n        # If no parent, return as-is\n        parent_name = spec_raw.get(\"parent\")\n        if not parent_name:\n            return spec_raw\n\n        # Recursively resolve parent and merge fields\n        parent_spec = self._resolve_entity_with_inheritance(parent_name)\n\n        # Merge parent fields with child fields (child overrides parent)\n        merged_fields = parent_spec.get(\"fields\", {}).copy()\n        merged_fields.update(spec_raw.get(\"fields\", {}))\n\n        # Create merged spec\n        merged_spec = spec_raw.copy()\n        merged_spec[\"fields\"] = merged_fields\n\n        return merged_spec\n\n    def get_see_also_config(self, entity_name: str) -&gt; dict[str, Any] | None:\n        \"\"\"Get the see_also configuration for the given entity type from YAML schema.\n\n        Returns:\n            Dict with keys: enabled, threshold, limit, target_types\n            None if see_also is not configured for this entity\n        \"\"\"\n        if not entity_name:\n            raise YamlTranslatorError(\"Empty entity name\")\n        name_l = entity_name.lower()\n        emap = self._entities_map()\n        spec_raw = emap.get(name_l)\n        if not spec_raw:\n            raise YamlTranslatorError(f\"Entity '{entity_name}' not found in YAML schema\")\n\n        see_also = spec_raw.get(\"see_also\")\n        if not see_also or not isinstance(see_also, dict):\n            return None\n\n        # Validate required fields\n        if not see_also.get(\"enabled\", False):\n            return None\n\n        return {\n            \"enabled\": see_also.get(\"enabled\", False),\n            \"threshold\": float(see_also.get(\"threshold\", 0.7)),\n            \"limit\": int(see_also.get(\"limit\", 3)),\n            \"target_types\": list(see_also.get(\"target_types\", [])),\n        }\n\n    def build_anchor_text(self, memory) -&gt; str:\n        \"\"\"Build anchor text for embedding from YAML-defined anchor field.\n\n        NO hardcoded field names - reads anchor field from YAML schema.\n\n        Args:\n            memory: Memory object containing payload data.\n\n        Returns:\n            str: Anchor text for embedding.\n\n        Raises:\n            YamlTranslatorError: If anchor field is missing or invalid.\n        \"\"\"\n        mem_type = getattr(memory, \"memory_type\", None)\n        if not mem_type:\n            raise YamlTranslatorError(\n                \"Memory object missing 'memory_type' field\",\n                operation=\"build_anchor_text\",\n            )\n\n        # Get anchor field from YAML schema\n        anchor_field = self.get_anchor_field(mem_type)\n\n        # Try to get anchor text from the specified field\n        anchor_text = None\n\n        # First check if it's a core field on the Memory object\n        if hasattr(memory, anchor_field):\n            anchor_text = getattr(memory, anchor_field, None)\n        # Otherwise check in the payload\n        elif hasattr(memory, \"payload\") and isinstance(memory.payload, dict):\n            anchor_text = memory.payload.get(anchor_field)\n\n        if isinstance(anchor_text, str):\n            stripped_text = anchor_text.strip()\n            if stripped_text:\n                return stripped_text\n\n        # Anchor field missing, empty, or invalid\n        raise YamlTranslatorError(\n            f\"Anchor field '{anchor_field}' is missing, empty, or invalid \"\n            f\"for memory type '{mem_type}'\",\n            operation=\"build_anchor_text\",\n            context={\n                \"memory_type\": mem_type,\n                \"anchor_field\": anchor_field,\n                \"anchor_value\": anchor_text,\n            },\n        )\n\n    def _fields_contract(self, spec: dict[str, Any]) -&gt; tuple[list[str], list[str]]:\n        \"\"\"Extract required and optional fields from entity specification.\n\n        Supports either:\n        - fields: {required:[...], optional:[...]} format\n        - Individual field definitions with required flags\n\n        Args:\n            spec: Entity specification dictionary.\n\n        Returns:\n            tuple[list[str], list[str]]: (required_fields, optional_fields)\n        \"\"\"\n        # supports either fields: {required:[...], optional:[...]} OR flat dict\n        fields = spec.get(\"fields\") or {}\n        if \"required\" in fields or \"optional\" in fields:\n            req = [str(x) for x in fields.get(\"required\", [])]\n            opt = [str(x) for x in fields.get(\"optional\", [])]\n            return req, opt\n\n        # Resolve all fields including inherited ones\n        all_fields = self._resolve_inherited_fields(spec)\n\n        # Parse individual field definitions for required flag\n        required_fields = []\n        optional_fields = []\n\n        for field_name, field_def in all_fields.items():\n            if isinstance(field_def, dict) and field_def.get(\"required\", False):\n                # Skip system fields - they're handled by the system\n                if not field_def.get(\"system\", False):\n                    required_fields.append(field_name)\n                else:\n                    optional_fields.append(field_name)\n            else:\n                optional_fields.append(field_name)\n\n        return required_fields, optional_fields\n\n    def _resolve_inherited_fields(self, spec: dict[str, Any]) -&gt; dict[str, Any]:\n        \"\"\"Resolve all fields including inherited ones from parent entities.\n\n        Args:\n            spec: Entity specification dictionary.\n\n        Returns:\n            dict[str, Any]: Dictionary containing all fields (inherited + current).\n        \"\"\"\n        all_fields = {}\n        entities_map = self._entities_map()\n\n        # If entity has a parent, resolve parent fields first\n        parent_name = spec.get(\"parent\")\n        if parent_name:\n            parent_spec = entities_map.get(parent_name.lower())\n            if parent_spec:\n                # Recursively resolve parent fields\n                parent_fields = self._resolve_inherited_fields(parent_spec)\n                all_fields.update(parent_fields)\n\n        # Add/override with current entity's fields\n        current_fields = spec.get(\"fields\") or {}\n        all_fields.update(current_fields)\n\n        return all_fields\n\n    def _get_system_fields(self, spec: dict[str, Any]) -&gt; set[str]:\n        \"\"\"Extract system fields from YAML schema (fields marked with system: true).\n\n        Args:\n            spec: Entity specification dictionary.\n\n        Returns:\n            set[str]: Set of field names that are marked as system fields.\n        \"\"\"\n        system_fields = set()\n        all_fields = self._resolve_inherited_fields(spec)\n\n        for field_name, field_def in all_fields.items():\n            if isinstance(field_def, dict) and field_def.get(\"system\", False):\n                system_fields.add(field_name)\n\n        return system_fields\n\n    def _validate_enum_fields(self, memory_type: str, payload: dict[str, Any]) -&gt; None:\n        \"\"\"Validate enum fields against YAML schema choices.\n\n        Args:\n            memory_type: Entity type from YAML schema.\n            payload: Memory data to validate.\n\n        Raises:\n            YamlTranslatorError: If enum field has invalid value.\n        \"\"\"\n        emap = self._entities_map()\n        spec = emap.get(memory_type.lower())\n        if not spec:\n            return  # Entity validation happens elsewhere\n\n        # Get field definitions for this entity type\n        fields = spec.get(\"fields\", {})\n\n        # Check each field in the payload\n        for field_name, field_value in payload.items():\n            if field_name in fields:\n                field_def = fields[field_name]\n\n                # Check if this is an enum field\n                if field_def.get(\"type\") == \"enum\":\n                    choices = field_def.get(\"choices\", [])\n\n                    # Validate the value against choices\n                    if field_value is not None and field_value not in choices:\n                        raise YamlTranslatorError(\n                            f\"Invalid {field_name} value '{field_value}'. Valid choices: {choices}\",\n                            context={\n                                \"memory_type\": memory_type,\n                                \"field_name\": field_name,\n                                \"invalid_value\": field_value,\n                                \"valid_choices\": choices,\n                            },\n                        )\n\n    def validate_memory_against_yaml(\n        self, memory_type: str, payload: dict[str, Any]\n    ) -&gt; dict[str, Any]:\n        \"\"\"Validate memory payload against YAML schema and return cleaned payload.\"\"\"\n        if not memory_type:\n            raise YamlTranslatorError(\"memory_type is required\")\n        if payload is None:\n            raise YamlTranslatorError(\"payload is required\")\n\n        # Strict validation - entity type MUST exist in YAML\n        emap = self._entities_map()\n        spec = emap.get(memory_type.lower())\n        if not spec:\n            raise YamlTranslatorError(\n                f\"Unknown entity type '{memory_type}'. All types must be defined in YAML schema.\",\n                context={\n                    \"memory_type\": memory_type,\n                    \"available_types\": list(emap.keys()),\n                },\n            )\n\n        req, _opt = self._fields_contract(spec)\n        missing = [k for k in req if not payload.get(k)]\n        if missing:\n            raise YamlTranslatorError(\n                f\"Missing required fields: {missing}\",\n                context={\"memory_type\": memory_type},\n            )\n\n        # Validate enum fields against YAML schema choices\n        self._validate_enum_fields(memory_type, payload)\n\n        # Validate that all fields are defined in YAML schema\n        req, opt = self._fields_contract(spec)\n        valid_fields = set(req + opt)\n        system_fields = self._get_system_fields(spec)\n        invalid_fields = set(payload.keys()) - valid_fields - system_fields\n        if invalid_fields:\n            raise YamlTranslatorError(\n                f\"Invalid fields not defined in schema: {sorted(invalid_fields)}\",\n                context={\n                    \"memory_type\": memory_type,\n                    \"valid_fields\": sorted(valid_fields),\n                    \"invalid_fields\": sorted(invalid_fields),\n                },\n            )\n\n        # Strip system-reserved fields if present\n        cleaned = dict(payload)\n        for syskey in system_fields:\n            cleaned.pop(syskey, None)\n        return cleaned\n\n    def create_memory_from_yaml(self, memory_type: str, payload: dict[str, Any], user_id: str):\n        \"\"\"Create a Memory object from YAML-validated payload.\"\"\"\n\n        # Get anchor field from YAML schema\n        anchor_field = self.get_anchor_field(memory_type)\n\n        # Extract anchor text from payload\n        anchor_text = payload.get(anchor_field)\n        if not anchor_text or not isinstance(anchor_text, str):\n            raise YamlTranslatorError(\n                f\"Missing or invalid anchor field '{anchor_field}' in payload \"\n                f\"for memory type '{memory_type}'\"\n            )\n\n        # Validate full payload against YAML schema\n        validated_payload = self.validate_memory_against_yaml(memory_type, payload)\n\n        # Construct Memory with YAML-defined payload only\n        return Memory(\n            memory_type=memory_type,\n            payload=validated_payload,\n            user_id=user_id,\n        )\n\n    def get_entity_model(self, entity_name: str):\n        \"\"\"Get Pydantic model from TypeRegistry - NO REDUNDANCY.\"\"\"\n        return get_entity_model(entity_name)\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.schema","title":"<code>schema</code>  <code>property</code>","text":"<p>Get the loaded YAML schema, loading it if necessary.</p>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.__init__","title":"<code>__init__(yaml_path=None)</code>","text":"<p>Initialize YamlTranslator with YAML schema path.</p> <p>Parameters:</p> Name Type Description Default <code>yaml_path</code> <code>str | None</code> <p>Path to YAML schema file. If None, uses MEMG_YAML_SCHEMA env var.</p> <code>None</code> <p>Raises:</p> Type Description <code>YamlTranslatorError</code> <p>If YAML path not provided or TypeRegistry initialization fails.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def __init__(self, yaml_path: str | None = None) -&gt; None:\n    \"\"\"Initialize YamlTranslator with YAML schema path.\n\n    Args:\n        yaml_path: Path to YAML schema file. If None, uses MEMG_YAML_SCHEMA env var.\n\n    Raises:\n        YamlTranslatorError: If YAML path not provided or TypeRegistry initialization fails.\n    \"\"\"\n    # Require explicit YAML path - no silent defaults\n    if yaml_path:\n        self.yaml_path = yaml_path\n    else:\n        env_path = os.getenv(\"MEMG_YAML_SCHEMA\")\n        if not env_path:\n            raise YamlTranslatorError(\n                \"YAML schema path required. Set MEMG_YAML_SCHEMA environment variable \"\n                \"or provide yaml_path parameter. No defaults allowed.\"\n            )\n        self.yaml_path = env_path\n\n    self._schema: dict[str, Any] | None = None\n    # NO model cache - TypeRegistry handles all caching\n\n    # Initialize TypeRegistry from YAML - crash early if invalid\n    try:\n        initialize_types_from_yaml(self.yaml_path)\n    except Exception as e:\n        raise YamlTranslatorError(f\"Failed to initialize TypeRegistry from YAML: {e}\") from e\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.build_anchor_text","title":"<code>build_anchor_text(memory)</code>","text":"<p>Build anchor text for embedding from YAML-defined anchor field.</p> <p>NO hardcoded field names - reads anchor field from YAML schema.</p> <p>Parameters:</p> Name Type Description Default <code>memory</code> <p>Memory object containing payload data.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Anchor text for embedding.</p> <p>Raises:</p> Type Description <code>YamlTranslatorError</code> <p>If anchor field is missing or invalid.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def build_anchor_text(self, memory) -&gt; str:\n    \"\"\"Build anchor text for embedding from YAML-defined anchor field.\n\n    NO hardcoded field names - reads anchor field from YAML schema.\n\n    Args:\n        memory: Memory object containing payload data.\n\n    Returns:\n        str: Anchor text for embedding.\n\n    Raises:\n        YamlTranslatorError: If anchor field is missing or invalid.\n    \"\"\"\n    mem_type = getattr(memory, \"memory_type\", None)\n    if not mem_type:\n        raise YamlTranslatorError(\n            \"Memory object missing 'memory_type' field\",\n            operation=\"build_anchor_text\",\n        )\n\n    # Get anchor field from YAML schema\n    anchor_field = self.get_anchor_field(mem_type)\n\n    # Try to get anchor text from the specified field\n    anchor_text = None\n\n    # First check if it's a core field on the Memory object\n    if hasattr(memory, anchor_field):\n        anchor_text = getattr(memory, anchor_field, None)\n    # Otherwise check in the payload\n    elif hasattr(memory, \"payload\") and isinstance(memory.payload, dict):\n        anchor_text = memory.payload.get(anchor_field)\n\n    if isinstance(anchor_text, str):\n        stripped_text = anchor_text.strip()\n        if stripped_text:\n            return stripped_text\n\n    # Anchor field missing, empty, or invalid\n    raise YamlTranslatorError(\n        f\"Anchor field '{anchor_field}' is missing, empty, or invalid \"\n        f\"for memory type '{mem_type}'\",\n        operation=\"build_anchor_text\",\n        context={\n            \"memory_type\": mem_type,\n            \"anchor_field\": anchor_field,\n            \"anchor_value\": anchor_text,\n        },\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.create_memory_from_yaml","title":"<code>create_memory_from_yaml(memory_type, payload, user_id)</code>","text":"<p>Create a Memory object from YAML-validated payload.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def create_memory_from_yaml(self, memory_type: str, payload: dict[str, Any], user_id: str):\n    \"\"\"Create a Memory object from YAML-validated payload.\"\"\"\n\n    # Get anchor field from YAML schema\n    anchor_field = self.get_anchor_field(memory_type)\n\n    # Extract anchor text from payload\n    anchor_text = payload.get(anchor_field)\n    if not anchor_text or not isinstance(anchor_text, str):\n        raise YamlTranslatorError(\n            f\"Missing or invalid anchor field '{anchor_field}' in payload \"\n            f\"for memory type '{memory_type}'\"\n        )\n\n    # Validate full payload against YAML schema\n    validated_payload = self.validate_memory_against_yaml(memory_type, payload)\n\n    # Construct Memory with YAML-defined payload only\n    return Memory(\n        memory_type=memory_type,\n        payload=validated_payload,\n        user_id=user_id,\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.debug_relation_map","title":"<code>debug_relation_map()</code>","text":"<p>Return a nested relation map for debugging/printing.</p> <p>Structure: {   source: {     target: [ {name, predicate, directed, description} ... ]   } }</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def debug_relation_map(self) -&gt; dict[str, dict[str, list[dict[str, Any]]]]:\n    \"\"\"Return a nested relation map for debugging/printing.\n\n    Structure:\n    {\n      source: {\n        target: [ {name, predicate, directed, description} ... ]\n      }\n    }\n    \"\"\"\n    out: dict[str, dict[str, list[dict[str, Any]]]] = {}\n    for source in self.get_entity_types():\n        specs = self.get_relations_for_source(source)\n        if not specs:\n            continue\n        if source not in out:\n            out[source] = {}\n        for spec in specs:\n            target = spec[\"target\"]\n            out[source].setdefault(target, [])\n            out[source][target].append(\n                {\n                    \"name\": spec.get(\"name\"),\n                    \"predicate\": spec.get(\"predicate\"),\n                    \"directed\": spec.get(\"directed\", True),\n                    \"description\": spec.get(\"description\"),\n                }\n            )\n    return out\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.get_anchor_field","title":"<code>get_anchor_field(entity_name)</code>","text":"<p>Get the anchor field name for the given entity type from YAML schema.</p> <p>Now reads from vector.anchored_to instead of separate anchor field.</p> <p>Parameters:</p> Name Type Description Default <code>entity_name</code> <code>str</code> <p>Name of the entity type.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Anchor field name.</p> <p>Raises:</p> Type Description <code>YamlTranslatorError</code> <p>If anchor field not found.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_anchor_field(self, entity_name: str) -&gt; str:\n    \"\"\"Get the anchor field name for the given entity type from YAML schema.\n\n    Now reads from vector.anchored_to instead of separate anchor field.\n\n    Args:\n        entity_name: Name of the entity type.\n\n    Returns:\n        str: Anchor field name.\n\n    Raises:\n        YamlTranslatorError: If anchor field not found.\n    \"\"\"\n    if not entity_name:\n        raise YamlTranslatorError(\"Empty entity name\")\n\n    # Get entity spec with inheritance resolution\n    entity_spec = self._resolve_entity_with_inheritance(entity_name)\n\n    # Look for vector field with anchored_to\n    fields = entity_spec.get(\"fields\", {})\n    for _field_name, field_def in fields.items():\n        if isinstance(field_def, dict) and field_def.get(\"type\") == \"vector\":\n            anchored_to = field_def.get(\"anchored_to\")\n            if anchored_to:\n                return str(anchored_to)\n\n    raise YamlTranslatorError(\n        f\"Entity '{entity_name}' has no vector field with 'anchored_to' property\"\n    )\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.get_entity_model","title":"<code>get_entity_model(entity_name)</code>","text":"<p>Get Pydantic model from TypeRegistry - NO REDUNDANCY.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_entity_model(self, entity_name: str):\n    \"\"\"Get Pydantic model from TypeRegistry - NO REDUNDANCY.\"\"\"\n    return get_entity_model(entity_name)\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.get_entity_types","title":"<code>get_entity_types()</code>","text":"<p>Get list of available entity types from YAML schema.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_entity_types(self) -&gt; list[str]:\n    \"\"\"Get list of available entity types from YAML schema.\"\"\"\n    return list(self._entities_map().keys())\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.get_labels_for_predicates","title":"<code>get_labels_for_predicates(source_type, predicates, neighbor_label=None)</code>","text":"<p>Expand predicate names to concrete relationship labels for a given source.</p> <p>Parameters:</p> Name Type Description Default <code>source_type</code> <code>str</code> <p>Source entity type name</p> required <code>predicates</code> <code>list[str] | None</code> <p>List of predicate names to include (case-insensitive). If None, include all.</p> required <code>neighbor_label</code> <code>str | None</code> <p>Optional target entity type filter (case-insensitive)</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of concrete relationship labels (table names) matching the filter.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_labels_for_predicates(\n    self,\n    source_type: str,\n    predicates: list[str] | None,\n    neighbor_label: str | None = None,\n) -&gt; list[str]:\n    \"\"\"Expand predicate names to concrete relationship labels for a given source.\n\n    Args:\n        source_type: Source entity type name\n        predicates: List of predicate names to include (case-insensitive). If None, include all.\n        neighbor_label: Optional target entity type filter (case-insensitive)\n\n    Returns:\n        List of concrete relationship labels (table names) matching the filter.\n    \"\"\"\n    if not source_type:\n        raise YamlTranslatorError(\"Empty source_type\")\n\n    preds_u = set(p.upper() for p in predicates) if predicates else None\n    neighbor_l = neighbor_label.lower() if neighbor_label else None\n\n    labels: list[str] = []\n    for spec in self.get_relations_for_source(source_type):\n        if preds_u is not None and spec[\"predicate\"].upper() not in preds_u:\n            continue\n        if neighbor_l is not None and spec[\"target\"].lower() != neighbor_l:\n            continue\n        labels.append(\n            self.relationship_table_name(\n                source=spec[\"source\"],\n                predicate=spec[\"predicate\"],\n                target=spec[\"target\"],\n                directed=spec[\"directed\"],\n            )\n        )\n    return labels\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.get_relations_for_source","title":"<code>get_relations_for_source(entity_name)</code>","text":"<p>Get normalized relation specs for a source entity in target-first schema.</p> Returns list of dicts with keys <ul> <li>source (str)</li> <li>target (str)</li> <li>name (str | None)</li> <li>description (str | None)</li> <li>predicate (str)</li> <li>directed (bool)</li> </ul> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_relations_for_source(self, entity_name: str) -&gt; list[dict[str, Any]]:\n    \"\"\"Get normalized relation specs for a source entity in target-first schema.\n\n    Returns list of dicts with keys:\n        - source (str)\n        - target (str)\n        - name (str | None)\n        - description (str | None)\n        - predicate (str)\n        - directed (bool)\n    \"\"\"\n    if not entity_name:\n        raise YamlTranslatorError(\"Empty entity name\")\n\n    source_l = entity_name.lower()\n    relations_map = self._get_relations_mapping_for_entity(source_l)\n    if not relations_map:\n        return []\n\n    out: list[dict[str, Any]] = []\n    for target_l, items in relations_map.items():\n        for item in items:\n            predicate = item.get(\"predicate\")\n            if not predicate or not isinstance(predicate, str):\n                # Skip invalid entries - strict behavior can be added later\n                continue\n            directed = bool(item.get(\"directed\", True))\n            out.append(\n                {\n                    \"source\": source_l,\n                    \"target\": target_l,\n                    \"name\": item.get(\"name\"),\n                    \"description\": item.get(\"description\"),\n                    \"predicate\": predicate.upper(),\n                    \"directed\": directed,\n                }\n            )\n    return out\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.get_see_also_config","title":"<code>get_see_also_config(entity_name)</code>","text":"<p>Get the see_also configuration for the given entity type from YAML schema.</p> <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dict with keys: enabled, threshold, limit, target_types</p> <code>dict[str, Any] | None</code> <p>None if see_also is not configured for this entity</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def get_see_also_config(self, entity_name: str) -&gt; dict[str, Any] | None:\n    \"\"\"Get the see_also configuration for the given entity type from YAML schema.\n\n    Returns:\n        Dict with keys: enabled, threshold, limit, target_types\n        None if see_also is not configured for this entity\n    \"\"\"\n    if not entity_name:\n        raise YamlTranslatorError(\"Empty entity name\")\n    name_l = entity_name.lower()\n    emap = self._entities_map()\n    spec_raw = emap.get(name_l)\n    if not spec_raw:\n        raise YamlTranslatorError(f\"Entity '{entity_name}' not found in YAML schema\")\n\n    see_also = spec_raw.get(\"see_also\")\n    if not see_also or not isinstance(see_also, dict):\n        return None\n\n    # Validate required fields\n    if not see_also.get(\"enabled\", False):\n        return None\n\n    return {\n        \"enabled\": see_also.get(\"enabled\", False),\n        \"threshold\": float(see_also.get(\"threshold\", 0.7)),\n        \"limit\": int(see_also.get(\"limit\", 3)),\n        \"target_types\": list(see_also.get(\"target_types\", [])),\n    }\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.relationship_table_name","title":"<code>relationship_table_name(source, predicate, target, *, directed=True)</code>  <code>staticmethod</code>","text":"<p>Generate relationship table name.</p> <p>For now, table name does not encode direction; direction affects creation/query semantics. Canonicalization for undirected pairs can be added here later if decided.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>@staticmethod\ndef relationship_table_name(\n    source: str,\n    predicate: str,\n    target: str,\n    *,\n    directed: bool = True,  # noqa: unused-argument\n) -&gt; str:\n    \"\"\"Generate relationship table name.\n\n    For now, table name does not encode direction; direction affects creation/query semantics.\n    Canonicalization for undirected pairs can be added here later if decided.\n    \"\"\"\n    return f\"{str(source).upper()}_{str(predicate).upper()}_{str(target).upper()}\"\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.YamlTranslator.validate_memory_against_yaml","title":"<code>validate_memory_against_yaml(memory_type, payload)</code>","text":"<p>Validate memory payload against YAML schema and return cleaned payload.</p> Source code in <code>src/memg_core/core/yaml_translator.py</code> <pre><code>def validate_memory_against_yaml(\n    self, memory_type: str, payload: dict[str, Any]\n) -&gt; dict[str, Any]:\n    \"\"\"Validate memory payload against YAML schema and return cleaned payload.\"\"\"\n    if not memory_type:\n        raise YamlTranslatorError(\"memory_type is required\")\n    if payload is None:\n        raise YamlTranslatorError(\"payload is required\")\n\n    # Strict validation - entity type MUST exist in YAML\n    emap = self._entities_map()\n    spec = emap.get(memory_type.lower())\n    if not spec:\n        raise YamlTranslatorError(\n            f\"Unknown entity type '{memory_type}'. All types must be defined in YAML schema.\",\n            context={\n                \"memory_type\": memory_type,\n                \"available_types\": list(emap.keys()),\n            },\n        )\n\n    req, _opt = self._fields_contract(spec)\n    missing = [k for k in req if not payload.get(k)]\n    if missing:\n        raise YamlTranslatorError(\n            f\"Missing required fields: {missing}\",\n            context={\"memory_type\": memory_type},\n        )\n\n    # Validate enum fields against YAML schema choices\n    self._validate_enum_fields(memory_type, payload)\n\n    # Validate that all fields are defined in YAML schema\n    req, opt = self._fields_contract(spec)\n    valid_fields = set(req + opt)\n    system_fields = self._get_system_fields(spec)\n    invalid_fields = set(payload.keys()) - valid_fields - system_fields\n    if invalid_fields:\n        raise YamlTranslatorError(\n            f\"Invalid fields not defined in schema: {sorted(invalid_fields)}\",\n            context={\n                \"memory_type\": memory_type,\n                \"valid_fields\": sorted(valid_fields),\n                \"invalid_fields\": sorted(invalid_fields),\n            },\n        )\n\n    # Strip system-reserved fields if present\n    cleaned = dict(payload)\n    for syskey in system_fields:\n        cleaned.pop(syskey, None)\n    return cleaned\n</code></pre>"},{"location":"reference/api/#memg_core.utils.db_clients.get_config","title":"<code>get_config()</code>","text":"<p>Get system configuration, preferring environment variables.</p> <p>Returns:</p> Name Type Description <code>MemorySystemConfig</code> <code>MemorySystemConfig</code> <p>System configuration instance.</p> Source code in <code>src/memg_core/core/config.py</code> <pre><code>def get_config() -&gt; MemorySystemConfig:\n    \"\"\"Get system configuration, preferring environment variables.\n\n    Returns:\n        MemorySystemConfig: System configuration instance.\n    \"\"\"\n    return MemorySystemConfig.from_env()\n</code></pre>"}]}